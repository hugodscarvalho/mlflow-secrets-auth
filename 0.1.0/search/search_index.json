{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MLflow Secrets Auth","text":"<p>A plugin for MLflow that automatically injects authentication headers from secret managers into tracking requests \u2014 securely, transparently, and with zero secret leaks.</p>"},{"location":"#overview","title":"Overview","text":"<p>MLflow Secrets Auth enables seamless authentication for MLflow tracking requests by retrieving credentials from enterprise secret management systems. The plugin supports multiple providers and maintains security best practices through host allowlisting, credential redaction, and secure caching.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Multi-Provider Support: HashiCorp Vault, AWS Secrets Manager, and Azure Key Vault</li> <li>Transparent Integration: Zero code changes required in existing MLflow workflows</li> <li>Security First: Host allowlisting, credential redaction, and secure in-memory caching</li> <li>Production Ready: Configurable TTL, retry logic with jitter, and comprehensive error handling</li> <li>Flexible Authentication: Bearer tokens, Basic auth, and custom header support</li> </ul>"},{"location":"#supported-providers","title":"Supported Providers","text":"Provider Status Auth Methods Secret Types HashiCorp Vault \u2705 Stable Token, AppRole KV v1/v2 AWS Secrets Manager \u2705 Stable IAM, AssumeRole SecretString, SecretBinary Azure Key Vault \u2705 Stable DefaultAzureCredential Secrets"},{"location":"#architecture","title":"Architecture","text":"<p>The plugin implements MLflow's <code>RequestAuthProvider</code> interface using a factory pattern that automatically selects and configures the first available provider. Secret resolution follows a secure flow with caching, retries, and comprehensive error handling.</p> <pre><code>graph TB\n    A[MLflow Client] --&gt; B[SecretsAuthProviderFactory]\n    B --&gt; C{Provider Selection}\n    C --&gt; D[Vault Provider]\n    C --&gt; E[AWS Provider]\n    C --&gt; F[Azure Provider]\n    D --&gt; G[Secret Resolution]\n    E --&gt; G\n    F --&gt; G\n    G --&gt; H[Cache Layer]\n    H --&gt; I[Auth Header Injection]</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code># Basic installation\npip install mlflow-secrets-auth\n\n# With specific provider support\npip install mlflow-secrets-auth[vault]\npip install mlflow-secrets-auth[aws]\npip install mlflow-secrets-auth[azure]\n\n# All providers\npip install mlflow-secrets-auth[vault,aws,azure]\n</code></pre>"},{"location":"#minimal-configuration","title":"Minimal Configuration","text":"<p>Configure your preferred provider and enable the plugin:</p> <pre><code># Vault example\nexport VAULT_ADDR=\"https://vault.company.com\"\nexport VAULT_TOKEN=\"hvs.XXXXXXXXXXXXXXXX\"\nexport MLFLOW_VAULT_SECRET_PATH=\"secret/mlflow/auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"vault\"\n\n# Your existing MLflow code works unchanged\nmlflow.start_run()\nmlflow.log_metric(\"accuracy\", 0.95)\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>import mlflow\n\n# No code changes required - authentication happens automatically\nmlflow.set_tracking_uri(\"https://mlflow.company.com\")\nmlflow.start_run()\nmlflow.log_param(\"model_type\", \"random_forest\")\nmlflow.log_metric(\"accuracy\", 0.95)\nmlflow.end_run()\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation Guide - Complete installation instructions with provider-specific dependencies</li> <li>Configuration Reference - Environment variables and configuration options</li> <li>Getting Started - Step-by-step setup guide with examples</li> <li>Provider Documentation - Provider-specific configuration and examples</li> <li>CLI Tools - Command-line utilities for diagnostics and troubleshooting</li> </ul>"},{"location":"#support","title":"Support","text":"<ul> <li>Documentation: Comprehensive guides and examples</li> <li>CLI Diagnostics: Built-in <code>doctor</code> command for troubleshooting</li> <li>Security: Host allowlisting and credential redaction</li> <li>Monitoring: Detailed logging and error reporting</li> </ul> <p>For issues and feature requests, please visit the GitHub repository.</p>"},{"location":"changelog/","title":"CHANGELOG","text":"<p>All notable changes to the <code>mlflow-secrets-auth</code> package will be documented in this file.</p> <p>This project adheres to Semantic Versioning and follows changelog conventions inspired by Keep a Changelog.</p>"},{"location":"changelog/#v010-2025-08-19","title":"[v0.1.0] \u2013 2025-08-19","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Initial placeholder release of <code>mlflow-secrets-auth</code> on PyPI.</li> <li>Included a minimal <code>MLflowClient</code> wrapper module.</li> </ul>"},{"location":"changelog/#notes","title":"Notes","text":"<ul> <li>This version was intentionally published with limited functionality to reserve the <code>mlflow-secrets-auth</code> package name on PyPI.</li> </ul>"},{"location":"cli/","title":"CLI Reference","text":"<p>The MLflow Secrets Auth CLI provides utilities for configuration validation, diagnostics, and troubleshooting. All commands support comprehensive logging and error reporting.</p>"},{"location":"cli/#overview","title":"Overview","text":"<p>The CLI tool is automatically installed with the plugin and provides two main commands:</p> <ul> <li><code>info</code> - Display plugin version, configuration, and provider status</li> <li><code>doctor</code> - Run comprehensive diagnostics and optional dry-run testing</li> </ul>"},{"location":"cli/#installation","title":"Installation","text":"<p>The CLI is available after installing the plugin:</p> <pre><code>pip install mlflow-secrets-auth[vault]\nmlflow-secrets-auth --help\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#info","title":"info","text":"<p>Display plugin information, version, and current configuration snapshot.</p>"},{"location":"cli/#usage","title":"Usage","text":"<pre><code>mlflow-secrets-auth info\n</code></pre>"},{"location":"cli/#output","title":"Output","text":"<p>The <code>info</code> command displays:</p> <ul> <li>Plugin version and installation status</li> <li>Enabled providers and their availability</li> <li>Current configuration summary (with sensitive data redacted)</li> <li>Cache status and statistics</li> <li>Security settings (allowed hosts, auth header)</li> </ul>"},{"location":"cli/#example-output","title":"Example Output","text":"<pre><code>MLflow Secrets Auth \u2013 Info\n==========================\n\nVersion: 0.1.0\nInstallation: Package installed\n\nProviders:\n\u2713 vault: Enabled and available\n\u2717 aws-secrets-manager: Disabled\n\u2717 azure-key-vault: Disabled\n\nConfiguration:\n  Auth Mode: bearer\n  Auth Header: Authorization\n  Cache TTL: 300 seconds\n  Allowed Hosts: *.company.com, localhost\n\nCache Status:\n  Entries: 1\n  Hit Rate: 85.2%\n\nSecurity:\n  Host Allowlisting: Enabled\n  Credential Redaction: Enabled\n</code></pre>"},{"location":"cli/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code> - Success</li> <li><code>1</code> - Plugin not properly installed or configured</li> </ul>"},{"location":"cli/#doctor","title":"doctor","text":"<p>Run comprehensive diagnostics against the configured provider with optional dry-run testing.</p>"},{"location":"cli/#usage_1","title":"Usage","text":"<pre><code>mlflow-secrets-auth doctor [OPTIONS]\n</code></pre>"},{"location":"cli/#options","title":"Options","text":"<ul> <li><code>--dry-run URL</code> - Test authentication against the specified MLflow tracking URL</li> </ul>"},{"location":"cli/#diagnostic-steps","title":"Diagnostic Steps","text":"<p>The <code>doctor</code> command performs the following checks:</p> <ol> <li>Provider Resolution - Identifies and validates the active provider</li> <li>Configuration Validation - Checks all required environment variables</li> <li>Authentication Test - Verifies provider credentials and connectivity</li> <li>Secret Retrieval - Tests secret fetching and parsing</li> <li>Auth Construction - Validates authentication header creation</li> <li>Dry-Run Test (optional) - Tests against actual MLflow server</li> </ol>"},{"location":"cli/#example-usage","title":"Example Usage","text":"<pre><code># Basic diagnostics\nmlflow-secrets-auth doctor\n\n# Test against specific MLflow server\nmlflow-secrets-auth doctor --dry-run https://mlflow.company.com\n\n# Debug mode with verbose output\nMLFLOW_SECRETS_LOG_LEVEL=DEBUG mlflow-secrets-auth doctor\n</code></pre>"},{"location":"cli/#example-output_1","title":"Example Output","text":"<pre><code>MLflow Secrets Auth \u2013 Doctor\n============================\n\n\u2713 Provider Resolution\n  Active Provider: vault\n  Provider Status: Enabled and configured\n\n\u2713 Configuration Validation\n  Vault Address: https://vault.company.com\n  Auth Mode: bearer\n  Secret Path: secret/mlflow/auth\n  TTL: 300 seconds\n  Allowed Hosts: *.company.com\n\n\u2713 Authentication Test\n  Connection: Successful\n  Authentication: Valid token\n  Permissions: Read access confirmed\n\n\u2713 Secret Retrieval\n  Secret Found: Yes\n  Secret Format: Valid JSON\n  Required Fields: token (present)\n\n\u2713 Auth Construction\n  Header Name: Authorization\n  Header Format: Bearer ****...****\n  Auth Object: Valid\n\n\u2713 Dry-Run Test (https://mlflow.company.com)\n  Host Check: mlflow.company.com allowed\n  Connection: Successful\n  Auth Header: Applied correctly\n  Response: 200 OK\n\nAll checks passed! \u2713\n</code></pre>"},{"location":"cli/#exit-codes_1","title":"Exit Codes","text":"<ul> <li><code>0</code> - All diagnostics passed</li> <li><code>1</code> - One or more diagnostic checks failed</li> </ul>"},{"location":"cli/#failure-examples","title":"Failure Examples","text":"<p>Provider Not Enabled: <pre><code>\u2717 Provider Resolution\n  Error: No providers enabled\n  Solution: Set MLFLOW_SECRETS_AUTH_ENABLE environment variable\n</code></pre></p> <p>Authentication Failed: <pre><code>\u2717 Authentication Test\n  Error: Vault authentication failed\n  Details: Invalid token or expired\n  Solution: Check VAULT_TOKEN or VAULT_ROLE_ID/VAULT_SECRET_ID\n</code></pre></p> <p>Secret Not Found: <pre><code>\u2717 Secret Retrieval\n  Error: Secret not found at path: secret/mlflow/auth\n  Solution: Verify secret exists and path is correct\n</code></pre></p> <p>Host Not Allowed: <pre><code>\u2717 Dry-Run Test (https://external.example.com)\n  Error: Host not in allowlist\n  Host: external.example.com\n  Allowed: *.company.com, localhost\n  Solution: Add host to MLFLOW_SECRETS_ALLOWED_HOSTS\n</code></pre></p>"},{"location":"cli/#global-options","title":"Global Options","text":""},{"location":"cli/#logging","title":"Logging","text":"<p>Control CLI output verbosity:</p> <pre><code># Debug level logging\nMLFLOW_SECRETS_LOG_LEVEL=DEBUG mlflow-secrets-auth doctor\n\n# Quiet mode (errors only)\nMLFLOW_SECRETS_LOG_LEVEL=ERROR mlflow-secrets-auth info\n\n# Default: INFO level\nmlflow-secrets-auth doctor\n</code></pre>"},{"location":"cli/#configuration-override","title":"Configuration Override","text":"<p>Test different configurations without modifying environment:</p> <pre><code># Test with different provider\nMLFLOW_SECRETS_AUTH_ENABLE=aws-secrets-manager mlflow-secrets-auth doctor\n\n# Test with different secret path\nMLFLOW_VAULT_SECRET_PATH=secret/test/auth mlflow-secrets-auth doctor\n\n# Test with different allowed hosts\nMLFLOW_SECRETS_ALLOWED_HOSTS=test.example.com mlflow-secrets-auth doctor --dry-run https://test.example.com\n</code></pre>"},{"location":"cli/#use-cases","title":"Use Cases","text":""},{"location":"cli/#development-workflow","title":"Development Workflow","text":"<pre><code># 1. Initial setup validation\nmlflow-secrets-auth info\n\n# 2. Test provider configuration\nmlflow-secrets-auth doctor\n\n# 3. Validate against development server\nmlflow-secrets-auth doctor --dry-run http://localhost:5000\n\n# 4. Debug connection issues\nMLFLOW_SECRETS_LOG_LEVEL=DEBUG mlflow-secrets-auth doctor --dry-run http://localhost:5000\n</code></pre>"},{"location":"cli/#cicd-integration","title":"CI/CD Integration","text":"<pre><code>#!/bin/bash\n# CI/CD pipeline validation script\n\necho \"Validating MLflow Secrets Auth configuration...\"\n\n# Check plugin installation\nif ! mlflow-secrets-auth info &gt; /dev/null 2&gt;&amp;1; then\n    echo \"\u274c Plugin not properly installed\"\n    exit 1\nfi\n\n# Run diagnostics\nif ! mlflow-secrets-auth doctor; then\n    echo \"\u274c Configuration validation failed\"\n    exit 1\nfi\n\n# Test against staging environment\nif ! mlflow-secrets-auth doctor --dry-run \"$MLFLOW_TRACKING_URI\"; then\n    echo \"\u274c Staging environment test failed\"\n    exit 1\nfi\n\necho \"\u2705 All validation checks passed\"\n</code></pre>"},{"location":"cli/#production-monitoring","title":"Production Monitoring","text":"<pre><code>#!/bin/bash\n# Health check script for production\n\n# Set monitoring-friendly output\nexport MLFLOW_SECRETS_LOG_LEVEL=ERROR\n\n# Quick configuration check\nif mlflow-secrets-auth info &gt; /dev/null 2&gt;&amp;1; then\n    echo \"HEALTHY: Plugin configuration valid\"\nelse\n    echo \"UNHEALTHY: Plugin configuration invalid\"\n    exit 1\nfi\n\n# Test secret retrieval\nif mlflow-secrets-auth doctor &gt; /dev/null 2&gt;&amp;1; then\n    echo \"HEALTHY: Secret retrieval working\"\nelse\n    echo \"UNHEALTHY: Secret retrieval failed\"\n    exit 1\nfi\n</code></pre>"},{"location":"cli/#troubleshooting-workflow","title":"Troubleshooting Workflow","text":"<pre><code># Step 1: Check basic configuration\nmlflow-secrets-auth info\n\n# Step 2: Enable debug logging and run diagnostics\nMLFLOW_SECRETS_LOG_LEVEL=DEBUG mlflow-secrets-auth doctor\n\n# Step 3: Test specific scenarios\nmlflow-secrets-auth doctor --dry-run https://problematic-server.com\n\n# Step 4: Test with minimal configuration\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"*\" mlflow-secrets-auth doctor --dry-run https://any-server.com\n</code></pre>"},{"location":"cli/#error-messages","title":"Error Messages","text":""},{"location":"cli/#common-error-patterns","title":"Common Error Patterns","text":""},{"location":"cli/#configuration-errors","title":"Configuration Errors","text":"<pre><code>Error: VAULT_ADDR environment variable is required\nSolution: export VAULT_ADDR=\"https://vault.company.com\"\n\nError: No providers enabled\nSolution: export MLFLOW_SECRETS_AUTH_ENABLE=\"vault\"\n\nError: Secret path not configured\nSolution: export MLFLOW_VAULT_SECRET_PATH=\"secret/mlflow/auth\"\n</code></pre>"},{"location":"cli/#authentication-errors","title":"Authentication Errors","text":"<pre><code>Error: Vault authentication failed\nDetails: 403 Forbidden\nSolution: Check token permissions or use valid AppRole credentials\n\nError: AWS credentials not found\nSolution: Configure AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY\n\nError: Azure authentication failed\nDetails: AADSTS70002: Error validating credentials\nSolution: Check AZURE_TENANT_ID, AZURE_CLIENT_ID, and AZURE_CLIENT_SECRET\n</code></pre>"},{"location":"cli/#network-errors","title":"Network Errors","text":"<pre><code>Error: Connection timeout to vault.company.com\nSolution: Check network connectivity and firewall rules\n\nError: Host not allowed: external.example.com\nSolution: Add to MLFLOW_SECRETS_ALLOWED_HOSTS or verify URL\n\nError: SSL verification failed\nSolution: Check TLS certificates or consider VAULT_SKIP_VERIFY (not recommended)\n</code></pre>"},{"location":"cli/#advanced-usage","title":"Advanced Usage","text":""},{"location":"cli/#custom-validation-scripts","title":"Custom Validation Scripts","text":"<p>Create custom validation scripts using the CLI:</p> <pre><code>#!/bin/bash\n# custom-validation.sh\n\n# Function to check specific provider\ncheck_provider() {\n    local provider=$1\n    echo \"Checking $provider provider...\"\n\n    if MLFLOW_SECRETS_AUTH_ENABLE=$provider mlflow-secrets-auth doctor; then\n        echo \"\u2705 $provider provider working\"\n        return 0\n    else\n        echo \"\u274c $provider provider failed\"\n        return 1\n    fi\n}\n\n# Test all providers\nproviders=(\"vault\" \"aws-secrets-manager\" \"azure-key-vault\")\nfailed=0\n\nfor provider in \"${providers[@]}\"; do\n    if ! check_provider $provider; then\n        ((failed++))\n    fi\ndone\n\nif [ $failed -eq 0 ]; then\n    echo \"All providers validated successfully\"\nelse\n    echo \"$failed provider(s) failed validation\"\n    exit 1\nfi\n</code></pre>"},{"location":"cli/#performance-testing","title":"Performance Testing","text":"<pre><code>#!/bin/bash\n# performance-test.sh\n\necho \"Testing secret retrieval performance...\"\n\n# Warm up cache\nmlflow-secrets-auth doctor &gt; /dev/null 2&gt;&amp;1\n\n# Time multiple retrievals\nfor i in {1..10}; do\n    start_time=$(date +%s%N)\n    mlflow-secrets-auth doctor &gt; /dev/null 2&gt;&amp;1\n    end_time=$(date +%s%N)\n    duration=$(( (end_time - start_time) / 1000000 ))\n    echo \"Run $i: ${duration}ms\"\ndone\n</code></pre>"},{"location":"cli/#integration-examples","title":"Integration Examples","text":""},{"location":"cli/#docker-health-checks","title":"Docker Health Checks","text":"<pre><code>FROM python:3.11-slim\n\n# Install plugin\nRUN pip install mlflow-secrets-auth[vault]\n\n# Add health check\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n  CMD mlflow-secrets-auth doctor || exit 1\n\n# Your application\nCOPY . /app\nWORKDIR /app\n</code></pre>"},{"location":"cli/#kubernetes-readiness-probe","title":"Kubernetes Readiness Probe","text":"<pre><code>apiVersion: v1\nkind: Pod\nspec:\n  containers:\n  - name: mlflow-app\n    image: mlflow-app:latest\n    readinessProbe:\n      exec:\n        command:\n        - /bin/sh\n        - -c\n        - mlflow-secrets-auth doctor\n      initialDelaySeconds: 10\n      periodSeconds: 30\n</code></pre>"},{"location":"cli/#monitoring-integration","title":"Monitoring Integration","text":"<pre><code>#!/bin/bash\n# monitoring-check.sh for Prometheus/monitoring systems\n\n# Output metrics format\necho \"# HELP mlflow_secrets_auth_status Plugin configuration status\"\necho \"# TYPE mlflow_secrets_auth_status gauge\"\n\nif mlflow-secrets-auth doctor &gt; /dev/null 2&gt;&amp;1; then\n    echo \"mlflow_secrets_auth_status 1\"\nelse\n    echo \"mlflow_secrets_auth_status 0\"\nfi\n</code></pre>"},{"location":"cli/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Reference - Complete environment variable reference</li> <li>Troubleshooting Guide - Common issues and solutions</li> <li>Provider Documentation - Provider-specific configuration</li> <li>Security Best Practices - Security guidelines and recommendations</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>Complete reference for configuring MLflow Secrets Auth, including environment variables, security settings, and provider-specific options.</p>"},{"location":"configuration/#overview","title":"Overview","text":"<p>MLflow Secrets Auth is configured entirely through environment variables, making it suitable for containerized deployments and CI/CD pipelines. Configuration covers provider selection, authentication parameters, security settings, and performance tuning.</p>"},{"location":"configuration/#global-configuration","title":"Global Configuration","text":""},{"location":"configuration/#provider-selection","title":"Provider Selection","text":""},{"location":"configuration/#primary-control","title":"Primary Control","text":"<pre><code># Enable specific providers (comma-separated)\nMLFLOW_SECRETS_AUTH_ENABLE=\"vault,aws-secrets-manager,azure-key-vault\"\n\n# Provider priority order (first available is used):\n# 1. vault\n# 2. aws-secrets-manager  \n# 3. azure-key-vault\n</code></pre>"},{"location":"configuration/#per-provider-control","title":"Per-Provider Control","text":"<pre><code># Individual provider toggles\nMLFLOW_SECRETS_AUTH_ENABLE_VAULT=true\nMLFLOW_SECRETS_AUTH_ENABLE_AWS_SECRETS_MANAGER=true\nMLFLOW_SECRETS_AUTH_ENABLE_AZURE_KEY_VAULT=true\n</code></pre>"},{"location":"configuration/#security-configuration","title":"Security Configuration","text":""},{"location":"configuration/#host-allowlisting","title":"Host Allowlisting","text":"<p>Control which MLflow servers can receive authentication credentials:</p> <pre><code># Exact hostnames\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com,mlflow-staging.company.com\"\n\n# Wildcard patterns (shell-style globbing)\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"*.company.com,localhost,127.0.0.1\"\n\n# Mixed patterns\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.prod.com,*.staging.com,localhost\"\n</code></pre> <p>Wildcard Examples: - <code>*.company.com</code> - Matches any subdomain of company.com - <code>mlflow-*</code> - Matches hostnames starting with \"mlflow-\" - <code>api.*.com</code> - Matches api with any middle component</p> <p>Security Note: Always use allowlisting in production environments to prevent credential leakage to unauthorized hosts.</p>"},{"location":"configuration/#authentication-headers","title":"Authentication Headers","text":"<pre><code># Custom authentication header name (default: \"Authorization\")\nMLFLOW_AUTH_HEADER_NAME=\"X-MLflow-Auth\"\n\n# Authentication modes supported:\n# - bearer: Authorization: Bearer &lt;token&gt;\n# - basic: Authorization: Basic &lt;base64(username:password)&gt;\n</code></pre>"},{"location":"configuration/#logging-configuration","title":"Logging Configuration","text":"<pre><code># Log level for secrets auth components\nMLFLOW_SECRETS_LOG_LEVEL=\"INFO\"  # DEBUG, INFO, WARNING, ERROR\n\n# Logging behavior:\n# - Automatic credential redaction in all log output\n# - Structured logging for integration with monitoring systems\n# - Provider-specific debug information when enabled\n</code></pre>"},{"location":"configuration/#provider-specific-configuration","title":"Provider-Specific Configuration","text":""},{"location":"configuration/#hashicorp-vault","title":"HashiCorp Vault","text":""},{"location":"configuration/#authentication","title":"Authentication","text":"<pre><code># Vault server address (required)\nVAULT_ADDR=\"https://vault.company.com\"\n\n# Token authentication (preferred for simplicity)\nVAULT_TOKEN=\"hvs.XXXXXXXXXXXXXXXX\"\n\n# AppRole authentication (preferred for automation)\nVAULT_ROLE_ID=\"role-id-value\"\nVAULT_SECRET_ID=\"secret-id-value\"\n</code></pre>"},{"location":"configuration/#secret-path-configuration","title":"Secret Path Configuration","text":"<pre><code># Secret path in Vault (required)\nMLFLOW_VAULT_SECRET_PATH=\"secret/mlflow/auth\"\n\n# Path formats supported:\n# - KV v2: \"secret/mlflow/auth\" (auto-detects and uses secret/data/mlflow/auth)\n# - KV v2 explicit: \"secret/data/mlflow/auth\"\n# - KV v1: \"secret/mlflow/auth\" (fallback behavior)\n</code></pre>"},{"location":"configuration/#vault-specific-options","title":"Vault-Specific Options","text":"<pre><code># Authentication mode\nMLFLOW_VAULT_AUTH_MODE=\"bearer\"  # bearer, basic\n\n# Cache TTL in seconds\nMLFLOW_VAULT_TTL_SEC=300  # 5 minutes (default)\n\n# Vault client configuration (advanced)\nVAULT_NAMESPACE=\"namespace\"  # For Vault Enterprise\nVAULT_SKIP_VERIFY=\"false\"   # Skip TLS verification (not recommended)\n</code></pre>"},{"location":"configuration/#aws-secrets-manager","title":"AWS Secrets Manager","text":""},{"location":"configuration/#aws-authentication","title":"AWS Authentication","text":"<pre><code># AWS region (required)\nAWS_REGION=\"us-east-1\"\n\n# AWS credentials (one method required):\n# 1. IAM User credentials\nAWS_ACCESS_KEY_ID=\"AKIAXXXXXXXXXXXXXXXX\"\nAWS_SECRET_ACCESS_KEY=\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n\n# 2. IAM Role (EC2/ECS/Lambda)\n# Automatically detected via instance metadata\n\n# 3. AWS Profile\nAWS_PROFILE=\"mlflow-profile\"\n\n# 4. AssumeRole\nAWS_ROLE_ARN=\"arn:aws:iam::123456789012:role/MLflowRole\"\nAWS_ROLE_SESSION_NAME=\"mlflow-session\"\n</code></pre>"},{"location":"configuration/#secret-configuration","title":"Secret Configuration","text":"<pre><code># Secret name or ARN (required)\nMLFLOW_AWS_SECRET_NAME=\"mlflow/auth\"\n# OR\nMLFLOW_AWS_SECRET_NAME=\"arn:aws:secretsmanager:us-east-1:123456789012:secret:mlflow/auth-AbCdEf\"\n\n# Version handling\nMLFLOW_AWS_SECRET_VERSION=\"AWSCURRENT\"  # AWSCURRENT, AWSPENDING, or specific version\n</code></pre>"},{"location":"configuration/#aws-specific-options","title":"AWS-Specific Options","text":"<pre><code># Authentication mode\nMLFLOW_AWS_AUTH_MODE=\"bearer\"  # bearer, basic\n\n# Cache TTL in seconds\nMLFLOW_AWS_TTL_SEC=300  # 5 minutes (default)\n\n# Retry configuration\nMLFLOW_AWS_MAX_RETRIES=3\nMLFLOW_AWS_RETRY_MODE=\"adaptive\"  # legacy, standard, adaptive\n</code></pre>"},{"location":"configuration/#azure-key-vault","title":"Azure Key Vault","text":""},{"location":"configuration/#azure-authentication","title":"Azure Authentication","text":"<pre><code># Service Principal authentication\nAZURE_TENANT_ID=\"tenant-id-uuid\"\nAZURE_CLIENT_ID=\"client-id-uuid\"\nAZURE_CLIENT_SECRET=\"client-secret-value\"\n\n# Or Certificate-based authentication\nAZURE_CLIENT_CERTIFICATE_PATH=\"/path/to/certificate.pem\"\n\n# Or Managed Identity (Azure VMs/App Service)\nAZURE_CLIENT_ID=\"managed-identity-client-id\"  # Optional for user-assigned MI\n</code></pre>"},{"location":"configuration/#key-vault-configuration","title":"Key Vault Configuration","text":"<pre><code># Key Vault URL (required)\nMLFLOW_AZURE_KEY_VAULT_URL=\"https://your-vault.vault.azure.net/\"\n\n# Secret name (required)\nMLFLOW_AZURE_SECRET_NAME=\"mlflow-auth\"\n\n# Secret version (optional)\nMLFLOW_AZURE_SECRET_VERSION=\"latest\"  # latest, or specific version ID\n</code></pre>"},{"location":"configuration/#azure-specific-options","title":"Azure-Specific Options","text":"<pre><code># Authentication mode\nMLFLOW_AZURE_AUTH_MODE=\"bearer\"  # bearer, basic\n\n# Cache TTL in seconds\nMLFLOW_AZURE_TTL_SEC=300  # 5 minutes (default)\n\n# Azure cloud environment\nAZURE_CLOUD_ENVIRONMENT=\"AzurePublicCloud\"  # AzurePublicCloud, AzureUSGovernment, etc.\n</code></pre>"},{"location":"configuration/#secret-format-requirements","title":"Secret Format Requirements","text":""},{"location":"configuration/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<p>Secrets should contain a <code>token</code> field:</p> <pre><code>{\n  \"token\": \"your-bearer-token-value\"\n}\n</code></pre>"},{"location":"configuration/#basic-authentication","title":"Basic Authentication","text":"<p>Secrets should contain <code>username</code> and <code>password</code> fields:</p> <pre><code>{\n  \"username\": \"mlflow-user\",\n  \"password\": \"secure-password\"\n}\n</code></pre>"},{"location":"configuration/#custom-authentication","title":"Custom Authentication","text":"<p>For custom header formats, include the complete header value:</p> <pre><code>{\n  \"token\": \"custom-auth-scheme token-value\"\n}\n</code></pre>"},{"location":"configuration/#performance-configuration","title":"Performance Configuration","text":""},{"location":"configuration/#caching","title":"Caching","text":"<pre><code># Cache TTL per provider (seconds)\nMLFLOW_VAULT_TTL_SEC=300\nMLFLOW_AWS_TTL_SEC=300\nMLFLOW_AZURE_TTL_SEC=300\n\n# Cache behavior:\n# - In-memory only (not persisted)\n# - Automatic cache busting on 401/403 responses\n# - Per-configuration caching (different configs = different cache entries)\n</code></pre>"},{"location":"configuration/#retry-configuration","title":"Retry Configuration","text":"<pre><code># Retry attempts for secret fetching\nMLFLOW_SECRETS_MAX_RETRIES=3\n\n# Retry behavior:\n# - Exponential backoff with jitter\n# - Automatic retry on transient failures\n# - Different retry strategies per provider\n</code></pre>"},{"location":"configuration/#environment-specific-examples","title":"Environment-Specific Examples","text":""},{"location":"configuration/#development-environment","title":"Development Environment","text":"<pre><code># Local development with Vault\nexport VAULT_ADDR=\"http://localhost:8200\"\nexport VAULT_TOKEN=\"dev-token\"\nexport MLFLOW_VAULT_SECRET_PATH=\"secret/dev/mlflow\"\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"localhost,127.0.0.1,*.local\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"vault\"\nexport MLFLOW_SECRETS_LOG_LEVEL=\"DEBUG\"\n</code></pre>"},{"location":"configuration/#staging-environment","title":"Staging Environment","text":"<pre><code># AWS Secrets Manager for staging\nexport AWS_REGION=\"us-east-1\"\nexport MLFLOW_AWS_SECRET_NAME=\"staging/mlflow/auth\"\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"*.staging.company.com\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"aws-secrets-manager\"\nexport MLFLOW_SECRETS_LOG_LEVEL=\"INFO\"\nexport MLFLOW_AWS_TTL_SEC=600  # 10 minutes for staging\n</code></pre>"},{"location":"configuration/#production-environment","title":"Production Environment","text":"<pre><code># Azure Key Vault for production\nexport AZURE_TENANT_ID=\"${AZURE_TENANT_ID}\"\nexport AZURE_CLIENT_ID=\"${AZURE_CLIENT_ID}\"\nexport AZURE_CLIENT_SECRET=\"${AZURE_CLIENT_SECRET}\"\nexport MLFLOW_AZURE_KEY_VAULT_URL=\"https://prod-vault.vault.azure.net/\"\nexport MLFLOW_AZURE_SECRET_NAME=\"mlflow-prod-auth\"\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"azure-key-vault\"\nexport MLFLOW_SECRETS_LOG_LEVEL=\"WARNING\"\nexport MLFLOW_AZURE_TTL_SEC=900  # 15 minutes for production\n</code></pre>"},{"location":"configuration/#multi-provider-fallback","title":"Multi-Provider Fallback","text":"<pre><code># Production with multiple providers for resilience\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"vault,aws-secrets-manager,azure-key-vault\"\n\n# Vault (primary)\nexport VAULT_ADDR=\"https://vault.company.com\"\nexport VAULT_TOKEN=\"${VAULT_TOKEN}\"\nexport MLFLOW_VAULT_SECRET_PATH=\"secret/mlflow/auth\"\n\n# AWS (secondary)\nexport AWS_REGION=\"us-east-1\"\nexport MLFLOW_AWS_SECRET_NAME=\"mlflow/auth\"\n\n# Azure (tertiary)\nexport MLFLOW_AZURE_KEY_VAULT_URL=\"https://backup-vault.vault.azure.net/\"\nexport MLFLOW_AZURE_SECRET_NAME=\"mlflow-auth\"\n\n# Shared configuration\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com\"\nexport MLFLOW_SECRETS_LOG_LEVEL=\"INFO\"\n</code></pre>"},{"location":"configuration/#configuration-validation","title":"Configuration Validation","text":""},{"location":"configuration/#cli-validation","title":"CLI Validation","text":"<pre><code># Check current configuration\nmlflow-secrets-auth info\n\n# Test configuration against specific URL\nmlflow-secrets-auth doctor --dry-run https://mlflow.company.com\n\n# Debug configuration issues\nMLFLOW_SECRETS_LOG_LEVEL=DEBUG mlflow-secrets-auth doctor\n</code></pre>"},{"location":"configuration/#programmatic-validation","title":"Programmatic Validation","text":"<pre><code>from mlflow_secrets_auth.config import (\n    is_provider_enabled,\n    get_allowed_hosts,\n    get_auth_header_name\n)\n\n# Check if providers are enabled\nprint(f\"Vault enabled: {is_provider_enabled('vault')}\")\nprint(f\"AWS enabled: {is_provider_enabled('aws-secrets-manager')}\")\nprint(f\"Azure enabled: {is_provider_enabled('azure-key-vault')}\")\n\n# Check security configuration\nprint(f\"Allowed hosts: {get_allowed_hosts()}\")\nprint(f\"Auth header: {get_auth_header_name()}\")\n</code></pre>"},{"location":"configuration/#security-best-practices","title":"Security Best Practices","text":""},{"location":"configuration/#environment-variable-security","title":"Environment Variable Security","text":"<ol> <li>Use Secret Management: Store sensitive values in your platform's secret management system</li> <li>Limit Scope: Use environment-specific configurations</li> <li>Rotate Regularly: Implement automatic credential rotation</li> <li>Monitor Access: Log and monitor configuration access</li> </ol>"},{"location":"configuration/#host-allowlisting_1","title":"Host Allowlisting","text":"<ol> <li>Always Enable: Use <code>MLFLOW_SECRETS_ALLOWED_HOSTS</code> in production</li> <li>Principle of Least Privilege: Only allow necessary hosts</li> <li>Wildcard Caution: Use wildcards carefully and specifically</li> <li>Regular Review: Audit allowed hosts regularly</li> </ol>"},{"location":"configuration/#provider-security","title":"Provider Security","text":"<ol> <li>IAM Best Practices: Use minimal required permissions</li> <li>Network Security: Use private networks and VPNs when possible</li> <li>Audit Logging: Enable audit logging on secret management systems</li> <li>Regular Updates: Keep provider SDKs updated</li> </ol>"},{"location":"configuration/#troubleshooting-configuration","title":"Troubleshooting Configuration","text":""},{"location":"configuration/#common-issues","title":"Common Issues","text":"<ol> <li>Provider Not Recognized: Check <code>MLFLOW_SECRETS_AUTH_ENABLE</code> value</li> <li>Host Not Allowed: Verify <code>MLFLOW_SECRETS_ALLOWED_HOSTS</code> patterns</li> <li>Secret Not Found: Validate secret paths and names</li> <li>Authentication Failed: Check provider credentials and permissions</li> </ol>"},{"location":"configuration/#debug-commands","title":"Debug Commands","text":"<pre><code># Enable verbose logging\nexport MLFLOW_SECRETS_LOG_LEVEL=DEBUG\n\n# Test provider authentication\nmlflow-secrets-auth doctor\n\n# Check configuration summary\nmlflow-secrets-auth info\n</code></pre>"},{"location":"configuration/#next-steps","title":"Next Steps","text":"<ul> <li>CLI Reference - Command-line tools for testing and diagnostics</li> <li>Provider Documentation - Provider-specific configuration details</li> <li>Security Guide - Security concepts and best practices</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"faq/","title":"FAQ","text":"<p>Frequently asked questions about MLflow Secrets Auth, covering common use cases, configuration scenarios, and implementation details.</p>"},{"location":"faq/#general-questions","title":"General Questions","text":""},{"location":"faq/#what-is-mlflow-secrets-auth","title":"What is MLflow Secrets Auth?","text":"<p>MLflow Secrets Auth is a plugin for MLflow that automatically injects authentication headers from secret management systems (Vault, AWS Secrets Manager, Azure Key Vault) into tracking requests. It provides secure, transparent authentication without requiring code changes in MLflow applications.</p>"},{"location":"faq/#which-secret-managers-are-supported","title":"Which secret managers are supported?","text":"<p>Currently supported providers: - HashiCorp Vault - KV v1 and KV v2 engines - AWS Secrets Manager - SecretString and SecretBinary support - Azure Key Vault - Native Azure AD integration</p>"},{"location":"faq/#does-this-require-changes-to-my-mlflow-code","title":"Does this require changes to my MLflow code?","text":"<p>No. The plugin integrates transparently with MLflow's authentication system. Your existing MLflow code continues to work unchanged:</p> <pre><code>import mlflow\n\n# No changes needed - authentication happens automatically\nmlflow.set_tracking_uri(\"https://mlflow.company.com\")\nmlflow.start_run()\nmlflow.log_metric(\"accuracy\", 0.95)\n</code></pre>"},{"location":"faq/#how-does-the-plugin-select-which-provider-to-use","title":"How does the plugin select which provider to use?","text":"<p>The plugin uses a priority-based selection: 1. HashiCorp Vault (first priority) 2. AWS Secrets Manager (second priority) 3. Azure Key Vault (third priority)</p> <p>The first enabled and properly configured provider is used. Enable providers using: <pre><code>export MLFLOW_SECRETS_AUTH_ENABLE=\"vault,aws-secrets-manager,azure-key-vault\"\n</code></pre></p>"},{"location":"faq/#authentication-modes","title":"Authentication Modes","text":""},{"location":"faq/#what-authentication-modes-are-supported","title":"What authentication modes are supported?","text":"<p>Two authentication modes are supported:</p> <p>Bearer Token (default): <pre><code>Authorization: Bearer &lt;token&gt;\n</code></pre></p> <p>Basic Authentication: <pre><code>Authorization: Basic &lt;base64(username:password)&gt;\n</code></pre></p> <p>Configure the mode per provider: <pre><code>export MLFLOW_VAULT_AUTH_MODE=\"bearer\"      # or \"basic\"\nexport MLFLOW_AWS_AUTH_MODE=\"bearer\"        # or \"basic\"  \nexport MLFLOW_AZURE_AUTH_MODE=\"bearer\"      # or \"basic\"\n</code></pre></p>"},{"location":"faq/#can-i-use-custom-headers-instead-of-authorization","title":"Can I use custom headers instead of \"Authorization\"?","text":"<p>Yes, configure a custom header name: <pre><code>export MLFLOW_AUTH_HEADER_NAME=\"X-MLflow-Auth\"\n</code></pre></p> <p>This changes the header from: <pre><code>Authorization: Bearer &lt;token&gt;\n</code></pre> to: <pre><code>X-MLflow-Auth: Bearer &lt;token&gt;\n</code></pre></p>"},{"location":"faq/#how-do-i-handle-token-rotation","title":"How do I handle token rotation?","text":"<p>The plugin supports automatic token rotation through several mechanisms:</p> <ol> <li> <p>Cache TTL: Configure short TTL for frequent rotation    <pre><code>export MLFLOW_VAULT_TTL_SEC=300  # 5 minutes\n</code></pre></p> </li> <li> <p>Automatic Cache Busting: Authentication failures (401/403) automatically clear cache</p> </li> <li> <p>Version Support: AWS and Azure support specific secret versions    <pre><code>export MLFLOW_AWS_SECRET_VERSION=\"AWSCURRENT\"\nexport MLFLOW_AZURE_SECRET_VERSION=\"latest\"\n</code></pre></p> </li> </ol>"},{"location":"faq/#host-allowlisting","title":"Host Allowlisting","text":""},{"location":"faq/#what-is-host-allowlisting-and-why-should-i-use-it","title":"What is host allowlisting and why should I use it?","text":"<p>Host allowlisting prevents credentials from being sent to unauthorized servers. It's a critical security feature that ensures secrets only reach intended MLflow servers.</p> <p>Without allowlisting: Credentials could be sent to any server With allowlisting: Credentials only sent to approved hosts</p> <pre><code>export MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com,*.staging.company.com\"\n</code></pre>"},{"location":"faq/#how-do-wildcard-patterns-work","title":"How do wildcard patterns work?","text":"<p>The plugin uses shell-style globbing patterns:</p> <ul> <li><code>*.company.com</code> - Matches any subdomain of company.com</li> <li><code>mlflow-*</code> - Matches hostnames starting with \"mlflow-\"</li> <li><code>api.*.com</code> - Matches api with any middle component</li> </ul> <p>Examples: <pre><code># Specific hosts\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.prod.com,mlflow.staging.com\"\n\n# Subdomain wildcards\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"*.company.com\"\n\n# Multiple patterns\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.prod.com,*.staging.com,localhost\"\n</code></pre></p>"},{"location":"faq/#what-happens-if-i-dont-configure-host-allowlisting","title":"What happens if I don't configure host allowlisting?","text":"<p>If <code>MLFLOW_SECRETS_ALLOWED_HOSTS</code> is not set, the plugin allows all hosts by default. This is convenient for development but not recommended for production.</p> <p>Development (permissive): <pre><code># No restrictions - allows all hosts\nunset MLFLOW_SECRETS_ALLOWED_HOSTS\n</code></pre></p> <p>Production (secure): <pre><code># Restrict to specific hosts\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com\"\n</code></pre></p>"},{"location":"faq/#can-i-use-localhost-for-development","title":"Can I use localhost for development?","text":"<p>Yes, include localhost and common development patterns: <pre><code>export MLFLOW_SECRETS_ALLOWED_HOSTS=\"localhost,127.0.0.1,*.local,mlflow.company.com\"\n</code></pre></p>"},{"location":"faq/#binary-secrets","title":"Binary Secrets","text":""},{"location":"faq/#does-the-plugin-support-binary-secrets","title":"Does the plugin support binary secrets?","text":"<p>Yes, particularly with AWS Secrets Manager:</p> <p>AWS Secrets Manager: - SecretString: Standard JSON secrets (preferred) - SecretBinary: Binary data automatically base64 encoded/decoded</p> <p>Vault: Supports binary data as base64-encoded strings in JSON</p> <p>Azure Key Vault: Supports binary data as base64-encoded strings</p>"},{"location":"faq/#how-are-binary-secrets-handled","title":"How are binary secrets handled?","text":"<p>Binary secrets are automatically converted to base64 strings for transport and parsed back to the appropriate format:</p> <pre><code># Internal handling (automatic)\nimport base64\n\n# Binary secret from AWS\nbinary_data = secret_response['SecretBinary']\ntoken = base64.b64encode(binary_data).decode('utf-8')\n\n# Use in authentication header\nauth_header = f\"Bearer {token}\"\n</code></pre>"},{"location":"faq/#what-formats-work-for-binary-tokens","title":"What formats work for binary tokens?","text":"<p>Common binary token formats that work:</p> <ol> <li>JWT tokens (binary-encoded)</li> <li>Custom binary tokens</li> <li>Encrypted token data</li> <li>Certificate-based tokens</li> </ol> <p>Store as binary in the secret manager, and the plugin handles encoding automatically.</p>"},{"location":"faq/#caching-and-performance","title":"Caching and Performance","text":""},{"location":"faq/#how-does-caching-work","title":"How does caching work?","text":"<p>The plugin implements in-memory caching with configurable TTL:</p> <ol> <li>First Request: Fetch secret from provider, cache result</li> <li>Subsequent Requests: Return cached secret if not expired</li> <li>Cache Expiry: Re-fetch secret after TTL expires</li> <li>Auth Failures: Automatically clear cache on 401/403 responses</li> </ol>"},{"location":"faq/#how-do-i-configure-cache-ttl","title":"How do I configure cache TTL?","text":"<p>Set TTL per provider (in seconds): <pre><code>export MLFLOW_VAULT_TTL_SEC=300      # 5 minutes\nexport MLFLOW_AWS_TTL_SEC=600        # 10 minutes\nexport MLFLOW_AZURE_TTL_SEC=900      # 15 minutes\n</code></pre></p> <p>Considerations: - Short TTL: Better security, more API calls - Long TTL: Better performance, less responsive to changes - Production: 15-30 minutes typical - Development: 1-5 minutes for rapid iteration</p>"},{"location":"faq/#what-happens-when-secrets-change","title":"What happens when secrets change?","text":"<p>When secrets are updated in the secret manager:</p> <ol> <li>Cached Entries: Continue using old secret until TTL expires</li> <li>Authentication Failures: Automatically trigger cache refresh</li> <li>Manual Refresh: Restart application to clear cache immediately</li> </ol> <p>Future Enhancement: CLI command to manually clear cache: <pre><code># Future feature\nmlflow-secrets-auth cache clear\n</code></pre></p>"},{"location":"faq/#how-can-i-optimize-performance","title":"How can I optimize performance?","text":"<ol> <li> <p>Appropriate TTL: Balance security and performance    <pre><code>export MLFLOW_VAULT_TTL_SEC=1800  # 30 minutes for high-frequency access\n</code></pre></p> </li> <li> <p>Regional Proximity: Use secret managers in the same region</p> </li> <li>Connection Reuse: Plugin automatically reuses connections</li> <li>Monitor Cache Hit Rate: Check with <code>mlflow-secrets-auth info</code></li> </ol>"},{"location":"faq/#security","title":"Security","text":""},{"location":"faq/#is-it-safe-to-use-in-production","title":"Is it safe to use in production?","text":"<p>Yes, the plugin is designed with production security in mind:</p> <ol> <li>Host Allowlisting: Prevents credential leakage</li> <li>Credential Redaction: Automatic masking in logs</li> <li>In-Memory Only: No disk persistence of secrets</li> <li>TLS Enforcement: All communications use HTTPS</li> <li>Principle of Least Privilege: Minimal required permissions</li> </ol>"},{"location":"faq/#how-are-secrets-protected-in-logs","title":"How are secrets protected in logs?","text":"<p>All sensitive data is automatically redacted:</p> <p>Before Redaction: <pre><code>Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\nSecret: {\"token\": \"abc123def456\", \"password\": \"secret123\"}\n</code></pre></p> <p>After Redaction: <pre><code>Authorization: Bearer eyJh********cCI6\nSecret: {\"token\": \"abc1********def4\", \"password\": \"secr********123\"}\n</code></pre></p>"},{"location":"faq/#what-permissions-are-needed","title":"What permissions are needed?","text":"<p>Vault: <pre><code>path \"secret/data/mlflow/*\" {\n  capabilities = [\"read\"]\n}\n</code></pre></p> <p>AWS: <pre><code>{\n  \"Effect\": \"Allow\",\n  \"Action\": [\"secretsmanager:GetSecretValue\"],\n  \"Resource\": \"arn:aws:secretsmanager:region:account:secret:mlflow/*\"\n}\n</code></pre></p> <p>Azure: <pre><code># Key Vault Secrets User role\naz role assignment create \\\n  --role \"Key Vault Secrets User\" \\\n  --assignee \"$AZURE_CLIENT_ID\"\n</code></pre></p>"},{"location":"faq/#how-do-i-handle-credential-rotation","title":"How do I handle credential rotation?","text":"<ol> <li>Automatic Detection: Plugin detects authentication failures and refreshes cache</li> <li>Short TTL: Use shorter cache TTL for more frequent rotation</li> <li>Staged Rotation: Update secrets during low-traffic periods</li> <li>Monitoring: Monitor authentication failure rates</li> </ol>"},{"location":"faq/#deployment","title":"Deployment","text":""},{"location":"faq/#how-do-i-deploy-in-docker","title":"How do I deploy in Docker?","text":"<pre><code>FROM python:3.11-slim\n\n# Install with provider support\nRUN pip install mlflow-secrets-auth[vault,aws,azure]\n\n# Copy application\nCOPY . /app\nWORKDIR /app\n\n# Environment variables provided at runtime\nENV MLFLOW_SECRETS_AUTH_ENABLE=\"\"\nENV VAULT_ADDR=\"\"\nENV MLFLOW_VAULT_SECRET_PATH=\"\"\n\nCMD [\"python\", \"app.py\"]\n</code></pre> <p>Runtime Configuration: <pre><code>docker run -e VAULT_ADDR=\"https://vault.company.com\" \\\n           -e VAULT_TOKEN=\"$VAULT_TOKEN\" \\\n           -e MLFLOW_VAULT_SECRET_PATH=\"secret/mlflow/auth\" \\\n           -e MLFLOW_SECRETS_AUTH_ENABLE=\"vault\" \\\n           mlflow-app\n</code></pre></p>"},{"location":"faq/#how-do-i-deploy-in-kubernetes","title":"How do I deploy in Kubernetes?","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mlflow-app\nspec:\n  template:\n    spec:\n      containers:\n      - name: mlflow-app\n        image: mlflow-app:latest\n        env:\n        - name: VAULT_ADDR\n          value: \"https://vault.company.com\"\n        - name: VAULT_TOKEN\n          valueFrom:\n            secretKeyRef:\n              name: vault-auth\n              key: token\n        - name: MLFLOW_VAULT_SECRET_PATH\n          value: \"secret/mlflow/auth\"\n        - name: MLFLOW_SECRETS_AUTH_ENABLE\n          value: \"vault\"\n</code></pre>"},{"location":"faq/#how-do-i-handle-multiple-environments","title":"How do I handle multiple environments?","text":"<p>Use environment-specific configuration:</p> <pre><code>#!/bin/bash\ncase \"$ENVIRONMENT\" in\n  development)\n    export VAULT_ADDR=\"http://localhost:8200\"\n    export MLFLOW_VAULT_SECRET_PATH=\"secret/dev/mlflow\"\n    export MLFLOW_SECRETS_ALLOWED_HOSTS=\"localhost,*.local\"\n    ;;\n  staging)\n    export VAULT_ADDR=\"https://vault-staging.company.com\"\n    export MLFLOW_VAULT_SECRET_PATH=\"secret/staging/mlflow\"\n    export MLFLOW_SECRETS_ALLOWED_HOSTS=\"*.staging.company.com\"\n    ;;\n  production)\n    export VAULT_ADDR=\"https://vault.company.com\"\n    export MLFLOW_VAULT_SECRET_PATH=\"secret/prod/mlflow\"\n    export MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com\"\n    ;;\nesac\n</code></pre>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/#how-do-i-debug-authentication-issues","title":"How do I debug authentication issues?","text":"<ol> <li> <p>Enable Debug Logging:    <pre><code>export MLFLOW_SECRETS_LOG_LEVEL=DEBUG\nmlflow-secrets-auth doctor\n</code></pre></p> </li> <li> <p>Test Each Component:    <pre><code># Test plugin status\nmlflow-secrets-auth info\n\n# Test provider connectivity\nmlflow-secrets-auth doctor\n\n# Test against MLflow server\nmlflow-secrets-auth doctor --dry-run https://mlflow.company.com\n</code></pre></p> </li> <li> <p>Check Provider Access:    <pre><code># Vault\nvault kv get secret/mlflow/auth\n\n# AWS\naws secretsmanager get-secret-value --secret-id mlflow/auth\n\n# Azure\naz keyvault secret show --vault-name vault --name mlflow-auth\n</code></pre></p> </li> </ol>"},{"location":"faq/#why-isnt-my-secret-being-found","title":"Why isn't my secret being found?","text":"<p>Common causes:</p> <ol> <li>Wrong Path/Name: Verify exact path or name</li> <li>Permissions: Ensure read access to the secret</li> <li>Case Sensitivity: Secret names are case-sensitive</li> <li>Provider Selection: Verify correct provider is enabled and selected</li> </ol> <p>Debug with: <pre><code># List available secrets\nvault kv list secret/                              # Vault\naws secretsmanager list-secrets                    # AWS\naz keyvault secret list --vault-name vault-name    # Azure\n</code></pre></p>"},{"location":"faq/#why-is-authentication-slow","title":"Why is authentication slow?","text":"<p>Performance factors:</p> <ol> <li>Network Latency: Distance to secret manager</li> <li>Cache Miss: First request or expired cache</li> <li>Provider Performance: Secret manager response time</li> </ol> <p>Optimize with: <pre><code># Increase cache TTL\nexport MLFLOW_VAULT_TTL_SEC=1800  # 30 minutes\n\n# Use regional endpoints\nexport AWS_REGION=\"us-east-1\"  # Same region as application\n</code></pre></p>"},{"location":"faq/#how-do-i-verify-the-plugin-is-working","title":"How do I verify the plugin is working?","text":"<ol> <li> <p>Check Plugin Status:    <pre><code>mlflow-secrets-auth info\n</code></pre></p> </li> <li> <p>Monitor Network Traffic: Should see HTTPS requests to secret managers</p> </li> <li> <p>Check MLflow Logs: Should see authentication headers being added</p> </li> <li> <p>Test with Debug Mode:    <pre><code>MLFLOW_SECRETS_LOG_LEVEL=DEBUG python your_mlflow_script.py\n</code></pre></p> </li> </ol>"},{"location":"faq/#migration-and-integration","title":"Migration and Integration","text":""},{"location":"faq/#how-do-i-migrate-from-hardcoded-credentials","title":"How do I migrate from hardcoded credentials?","text":"<ol> <li> <p>Store Credentials in Secret Manager:    <pre><code># Move from code/config files to secret manager\nvault kv put secret/mlflow/auth token=\"$EXISTING_TOKEN\"\n</code></pre></p> </li> <li> <p>Remove Hardcoded Values:    <pre><code># Before\nmlflow.set_tracking_uri(\"https://token:password@mlflow.company.com\")\n\n# After (plugin handles authentication)\nmlflow.set_tracking_uri(\"https://mlflow.company.com\")\n</code></pre></p> </li> <li> <p>Configure Plugin:    <pre><code>export MLFLOW_SECRETS_AUTH_ENABLE=\"vault\"\nexport VAULT_ADDR=\"https://vault.company.com\"\nexport MLFLOW_VAULT_SECRET_PATH=\"secret/mlflow/auth\"\n</code></pre></p> </li> </ol>"},{"location":"faq/#can-i-use-this-with-existing-mlflow-authentication","title":"Can I use this with existing MLflow authentication?","text":"<p>The plugin works alongside MLflow's existing authentication mechanisms:</p> <ol> <li>Plugin First: If enabled and configured, plugin provides authentication</li> <li>Fallback: If plugin disabled/fails, MLflow uses its default authentication</li> <li>Override: Plugin authentication takes precedence when available</li> </ol>"},{"location":"faq/#how-do-i-test-before-full-deployment","title":"How do I test before full deployment?","text":"<ol> <li>Staging Environment: Test in staging with same configuration</li> <li>Gradual Rollout: Enable for subset of applications first</li> <li>A/B Testing: Run with and without plugin in parallel</li> <li>Dry Run Testing: Use CLI dry-run mode extensively</li> </ol> <pre><code># Test without affecting production\nmlflow-secrets-auth doctor --dry-run https://staging.mlflow.company.com\n</code></pre>"},{"location":"faq/#compatibility","title":"Compatibility","text":""},{"location":"faq/#what-mlflow-versions-are-supported","title":"What MLflow versions are supported?","text":"<ul> <li>Minimum: MLflow 2.20.4</li> <li>Recommended: Latest stable MLflow version</li> <li>Compatibility: Tested with MLflow 2.x series</li> </ul>"},{"location":"faq/#what-python-versions-are-supported","title":"What Python versions are supported?","text":"<ul> <li>Supported: Python 3.9, 3.10, 3.11, 3.12</li> <li>Recommended: Python 3.11 or higher</li> <li>End of Life: Python versions past EOL not supported</li> </ul>"},{"location":"faq/#are-there-any-known-conflicts","title":"Are there any known conflicts?","text":"<p>Generally compatible with: - MLflow tracking, models, projects - Other MLflow plugins - Common Python web frameworks - Cloud deployment platforms</p> <p>Potential conflicts: - Custom authentication plugins (first loaded wins) - Applications that modify <code>requests.Session</code> globally - Very old versions of provider SDKs</p>"},{"location":"faq/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Quick start guide</li> <li>Configuration Reference - Complete configuration options</li> <li>Troubleshooting Guide - Detailed troubleshooting</li> <li>Provider Documentation - Provider-specific information</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide provides a step-by-step walkthrough for setting up MLflow Secrets Auth with your preferred secret management provider.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9 or higher</li> <li>MLflow 2.20.4 or higher</li> <li>Access to one of the supported secret managers:</li> <li>HashiCorp Vault</li> <li>AWS Secrets Manager</li> <li>Azure Key Vault</li> </ul>"},{"location":"getting-started/#step-1-installation","title":"Step 1: Installation","text":"<p>Choose your installation method based on your secret management provider:</p>"},{"location":"getting-started/#basic-installation","title":"Basic Installation","text":"<pre><code>pip install mlflow-secrets-auth\n</code></pre>"},{"location":"getting-started/#provider-specific-installation","title":"Provider-Specific Installation","text":"<pre><code># For HashiCorp Vault\npip install mlflow-secrets-auth[vault]\n\n# For AWS Secrets Manager\npip install mlflow-secrets-auth[aws]\n\n# For Azure Key Vault\npip install mlflow-secrets-auth[azure]\n\n# For multiple providers\npip install mlflow-secrets-auth[vault,aws,azure]\n</code></pre>"},{"location":"getting-started/#step-2-provider-setup","title":"Step 2: Provider Setup","text":""},{"location":"getting-started/#option-a-hashicorp-vault","title":"Option A: HashiCorp Vault","text":"<ol> <li> <p>Configure Vault Access <pre><code>export VAULT_ADDR=\"https://vault.company.com\"\nexport VAULT_TOKEN=\"hvs.XXXXXXXXXXXXXXXX\"\n# OR use AppRole authentication\nexport VAULT_ROLE_ID=\"role-id-value\"\nexport VAULT_SECRET_ID=\"secret-id-value\"\n</code></pre></p> </li> <li> <p>Set Secret Path <pre><code>export MLFLOW_VAULT_SECRET_PATH=\"secret/mlflow/auth\"\n</code></pre></p> </li> <li> <p>Store Secret in Vault <pre><code># For Bearer token authentication\nvault kv put secret/mlflow/auth token=\"your-mlflow-token\"\n\n# For Basic authentication\nvault kv put secret/mlflow/auth username=\"user\" password=\"pass\"\n</code></pre></p> </li> </ol>"},{"location":"getting-started/#option-b-aws-secrets-manager","title":"Option B: AWS Secrets Manager","text":"<ol> <li> <p>Configure AWS Credentials <pre><code>export AWS_REGION=\"us-east-1\"\n# AWS credentials via IAM role, profile, or environment variables\n</code></pre></p> </li> <li> <p>Set Secret Name <pre><code>export MLFLOW_AWS_SECRET_NAME=\"mlflow/auth\"\n</code></pre></p> </li> <li> <p>Create Secret in AWS <pre><code>aws secretsmanager create-secret \\\n  --name \"mlflow/auth\" \\\n  --secret-string '{\"token\":\"your-mlflow-token\"}'\n</code></pre></p> </li> </ol>"},{"location":"getting-started/#option-c-azure-key-vault","title":"Option C: Azure Key Vault","text":"<ol> <li> <p>Configure Azure Authentication <pre><code>export AZURE_TENANT_ID=\"your-tenant-id\"\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\n</code></pre></p> </li> <li> <p>Set Key Vault Details <pre><code>export MLFLOW_AZURE_KEY_VAULT_URL=\"https://your-vault.vault.azure.net/\"\nexport MLFLOW_AZURE_SECRET_NAME=\"mlflow-auth\"\n</code></pre></p> </li> <li> <p>Store Secret in Azure Key Vault <pre><code>az keyvault secret set \\\n  --vault-name \"your-vault\" \\\n  --name \"mlflow-auth\" \\\n  --value '{\"token\":\"your-mlflow-token\"}'\n</code></pre></p> </li> </ol>"},{"location":"getting-started/#step-3-enable-the-plugin","title":"Step 3: Enable the Plugin","text":"<p>Enable your chosen provider:</p> <pre><code># Enable specific provider\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"vault\"\n# OR\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"aws-secrets-manager\"\n# OR\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"azure-key-vault\"\n\n# Enable multiple providers (first available will be used)\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"vault,aws-secrets-manager,azure-key-vault\"\n</code></pre>"},{"location":"getting-started/#step-4-configure-security-recommended","title":"Step 4: Configure Security (Recommended)","text":"<p>Set up host allowlisting to restrict which MLflow servers can receive credentials:</p> <pre><code># Allow specific hosts\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com,mlflow-staging.company.com\"\n\n# Allow wildcard patterns\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"*.company.com,localhost\"\n</code></pre>"},{"location":"getting-started/#step-5-test-the-setup","title":"Step 5: Test the Setup","text":""},{"location":"getting-started/#verify-configuration","title":"Verify Configuration","text":"<pre><code># Check plugin status and configuration\nmlflow-secrets-auth info\n\n# Run diagnostics\nmlflow-secrets-auth doctor\n\n# Test against your MLflow server\nmlflow-secrets-auth doctor --dry-run https://mlflow.company.com\n</code></pre>"},{"location":"getting-started/#test-with-mlflow","title":"Test with MLflow","text":"<pre><code>import mlflow\n\n# Set your MLflow tracking URI\nmlflow.set_tracking_uri(\"https://mlflow.company.com\")\n\n# Authentication happens automatically\nmlflow.start_run()\nmlflow.log_param(\"test\", \"setup\")\nmlflow.log_metric(\"status\", 1.0)\nmlflow.end_run()\n\nprint(\"Setup successful!\")\n</code></pre>"},{"location":"getting-started/#step-6-environment-variables-summary","title":"Step 6: Environment Variables Summary","text":"<p>Create a <code>.env</code> file or set these environment variables in your deployment:</p> <pre><code># Provider Selection\nMLFLOW_SECRETS_AUTH_ENABLE=vault\n\n# Vault Configuration (if using Vault)\nVAULT_ADDR=https://vault.company.com\nVAULT_TOKEN=hvs.XXXXXXXXXXXXXXXX\nMLFLOW_VAULT_SECRET_PATH=secret/mlflow/auth\n\n# Security Configuration\nMLFLOW_SECRETS_ALLOWED_HOSTS=*.company.com,localhost\n\n# Optional: Logging and Performance\nMLFLOW_SECRETS_LOG_LEVEL=INFO\nMLFLOW_VAULT_TTL_SEC=300\n</code></pre>"},{"location":"getting-started/#common-use-cases","title":"Common Use Cases","text":""},{"location":"getting-started/#development-environment","title":"Development Environment","text":"<pre><code># Local development with Vault\nexport VAULT_ADDR=\"http://localhost:8200\"\nexport VAULT_TOKEN=\"dev-token\"\nexport MLFLOW_VAULT_SECRET_PATH=\"secret/dev/mlflow\"\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"localhost,127.0.0.1\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"vault\"\n</code></pre>"},{"location":"getting-started/#production-environment","title":"Production Environment","text":"<pre><code># Production with AWS Secrets Manager\nexport AWS_REGION=\"us-east-1\"\nexport MLFLOW_AWS_SECRET_NAME=\"production/mlflow/auth\"\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"aws-secrets-manager\"\nexport MLFLOW_SECRETS_LOG_LEVEL=\"WARNING\"\n</code></pre>"},{"location":"getting-started/#cicd-pipeline","title":"CI/CD Pipeline","text":"<pre><code># Azure Key Vault for CI/CD\nexport AZURE_TENANT_ID=\"${AZURE_TENANT_ID}\"\nexport AZURE_CLIENT_ID=\"${AZURE_CLIENT_ID}\"\nexport AZURE_CLIENT_SECRET=\"${AZURE_CLIENT_SECRET}\"\nexport MLFLOW_AZURE_KEY_VAULT_URL=\"https://ci-vault.vault.azure.net/\"\nexport MLFLOW_AZURE_SECRET_NAME=\"mlflow-ci-auth\"\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow-ci.company.com\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"azure-key-vault\"\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Reference - Complete environment variable reference</li> <li>Provider Documentation - Provider-specific configuration details</li> <li>CLI Tools - Command-line utilities and diagnostics</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"getting-started/#troubleshooting-quick-start","title":"Troubleshooting Quick Start","text":"<p>If you encounter issues during setup:</p> <ol> <li> <p>Check Plugin Status <pre><code>mlflow-secrets-auth info\n</code></pre></p> </li> <li> <p>Run Diagnostics <pre><code>mlflow-secrets-auth doctor --dry-run https://your-mlflow-server.com\n</code></pre></p> </li> <li> <p>Enable Debug Logging <pre><code>export MLFLOW_SECRETS_LOG_LEVEL=DEBUG\n</code></pre></p> </li> <li> <p>Verify Provider Dependencies <pre><code>python -c \"import hvac; print('Vault OK')\"  # For Vault\npython -c \"import boto3; print('AWS OK')\"   # For AWS\npython -c \"import azure.identity; print('Azure OK')\"  # For Azure\n</code></pre></p> </li> </ol> <p>For detailed troubleshooting, see the Troubleshooting Guide.</p>"},{"location":"installation/","title":"Installation","text":"<p>This guide covers installation of MLflow Secrets Auth with provider-specific dependencies and configuration requirements.</p>"},{"location":"installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python: 3.9 or higher</li> <li>MLflow: 2.20.4 or higher (mlflow-skinny supported)</li> <li>Operating System: Linux, macOS, Windows</li> <li>Secret Manager Access: Valid credentials for at least one supported provider</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#basic-installation","title":"Basic Installation","text":"<p>Install the core plugin without provider dependencies:</p> <pre><code>pip install mlflow-secrets-auth\n</code></pre> <p>This installation includes the plugin framework but requires manual installation of provider SDKs.</p>"},{"location":"installation/#provider-specific-installation","title":"Provider-Specific Installation","text":"<p>Install with provider-specific dependencies using extras:</p>"},{"location":"installation/#hashicorp-vault","title":"HashiCorp Vault","text":"<pre><code>pip install mlflow-secrets-auth[vault]\n</code></pre> <p>Includes: <code>hvac&gt;=2.3.0</code></p>"},{"location":"installation/#aws-secrets-manager","title":"AWS Secrets Manager","text":"<pre><code>pip install mlflow-secrets-auth[aws]\n</code></pre> <p>Includes: <code>boto3&gt;=1.40.11</code></p>"},{"location":"installation/#azure-key-vault","title":"Azure Key Vault","text":"<pre><code>pip install mlflow-secrets-auth[azure]\n</code></pre> <p>Includes: <code>azure-identity&gt;=1.24.0</code>, <code>azure-keyvault-secrets&gt;=4.10.0</code></p>"},{"location":"installation/#multiple-providers","title":"Multiple Providers","text":"<p>Install support for multiple providers:</p> <pre><code># All providers\npip install mlflow-secrets-auth[vault,aws,azure]\n\n# Specific combinations\npip install mlflow-secrets-auth[vault,aws]\npip install mlflow-secrets-auth[aws,azure]\n</code></pre>"},{"location":"installation/#advanced-installation-options","title":"Advanced Installation Options","text":""},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For development or contributing to the project:</p> <pre><code>git clone https://github.com/hugodscarvalho/mlflow-secrets-auth.git\ncd mlflow-secrets-auth\npip install -e .[vault,aws,azure]\n</code></pre>"},{"location":"installation/#poetry-installation","title":"Poetry Installation","text":"<p>If using Poetry for dependency management:</p> <pre><code># Add to pyproject.toml\npoetry add mlflow-secrets-auth[vault,aws,azure]\n\n# Or install specific providers\npoetry add mlflow-secrets-auth[vault]\n</code></pre>"},{"location":"installation/#docker-installation","title":"Docker Installation","text":"<p>For containerized environments:</p> <pre><code># Dockerfile example\nFROM python:3.11-slim\n\n# Install with all providers\nRUN pip install mlflow-secrets-auth[vault,aws,azure]\n\n# Your application code\nCOPY . /app\nWORKDIR /app\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":""},{"location":"installation/#check-installation","title":"Check Installation","text":"<p>Verify the plugin is installed correctly:</p> <pre><code># Check package installation\npip show mlflow-secrets-auth\n\n# Verify plugin registration\npython -c \"import mlflow_secrets_auth; print(mlflow_secrets_auth.__version__)\"\n\n# Check CLI availability\nmlflow-secrets-auth info\n</code></pre>"},{"location":"installation/#verify-provider-dependencies","title":"Verify Provider Dependencies","text":"<p>Check that provider dependencies are available:</p> <pre><code># Vault support\npython -c \"import hvac; print('\u2713 Vault support available')\"\n\n# AWS support\npython -c \"import boto3; print('\u2713 AWS support available')\"\n\n# Azure support\npython -c \"import azure.identity, azure.keyvault.secrets; print('\u2713 Azure support available')\"\n</code></pre>"},{"location":"installation/#provider-specific-setup","title":"Provider-Specific Setup","text":""},{"location":"installation/#hashicorp-vault_1","title":"HashiCorp Vault","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Vault server accessible from your environment</li> <li>Valid authentication method (token or AppRole)</li> <li>Appropriate policies for secret access</li> </ul>"},{"location":"installation/#required-permissions","title":"Required Permissions","text":"<p>Vault policy example for KV v2:</p> <pre><code># Policy: mlflow-secrets-auth\npath \"secret/data/mlflow/*\" {\n  capabilities = [\"read\"]\n}\n\npath \"secret/metadata/mlflow/*\" {\n  capabilities = [\"read\"]\n}\n</code></pre>"},{"location":"installation/#minimal-configuration","title":"Minimal Configuration","text":"<pre><code>export VAULT_ADDR=\"https://vault.company.com\"\nexport VAULT_TOKEN=\"hvs.XXXXXXXXXXXXXXXX\"\nexport MLFLOW_VAULT_SECRET_PATH=\"secret/mlflow/auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"vault\"\n</code></pre>"},{"location":"installation/#aws-secrets-manager_1","title":"AWS Secrets Manager","text":""},{"location":"installation/#prerequisites_1","title":"Prerequisites","text":"<ul> <li>AWS account with Secrets Manager access</li> <li>Valid AWS credentials (IAM user, role, or instance profile)</li> <li>Appropriate IAM permissions</li> </ul>"},{"location":"installation/#required-iam-permissions","title":"Required IAM Permissions","text":"<pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"secretsmanager:GetSecretValue\"\n      ],\n      \"Resource\": \"arn:aws:secretsmanager:region:account:secret:mlflow/*\"\n    }\n  ]\n}\n</code></pre>"},{"location":"installation/#minimal-configuration_1","title":"Minimal Configuration","text":"<pre><code>export AWS_REGION=\"us-east-1\"\nexport MLFLOW_AWS_SECRET_NAME=\"mlflow/auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"aws-secrets-manager\"\n</code></pre>"},{"location":"installation/#azure-key-vault_1","title":"Azure Key Vault","text":""},{"location":"installation/#prerequisites_2","title":"Prerequisites","text":"<ul> <li>Azure subscription with Key Vault access</li> <li>Service principal or managed identity</li> <li>Appropriate access policies</li> </ul>"},{"location":"installation/#required-access-policies","title":"Required Access Policies","text":"<p>Key Vault access policy for secrets:</p> <pre><code>az keyvault set-policy \\\n  --name \"your-vault\" \\\n  --spn \"service-principal-id\" \\\n  --secret-permissions get\n</code></pre>"},{"location":"installation/#minimal-configuration_2","title":"Minimal Configuration","text":"<pre><code>export AZURE_TENANT_ID=\"your-tenant-id\"\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\nexport MLFLOW_AZURE_KEY_VAULT_URL=\"https://your-vault.vault.azure.net/\"\nexport MLFLOW_AZURE_SECRET_NAME=\"mlflow-auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"azure-key-vault\"\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"installation/#mlflow-server","title":"MLflow Server","text":"<p>For local MLflow server development:</p> <pre><code>pip install mlflow-secrets-auth[vault] mlflow\n</code></pre>"},{"location":"installation/#testing-dependencies","title":"Testing Dependencies","text":"<p>For running tests:</p> <pre><code>pip install mlflow-secrets-auth[vault,aws,azure] pytest pytest-cov\n</code></pre>"},{"location":"installation/#environment-specific-considerations","title":"Environment-Specific Considerations","text":""},{"location":"installation/#production-environments","title":"Production Environments","text":"<ul> <li>Use specific version pins for reproducible deployments</li> <li>Consider security scanning of dependencies</li> <li>Implement proper secret rotation strategies</li> <li>Use managed identities when available</li> </ul>"},{"location":"installation/#cicd-pipelines","title":"CI/CD Pipelines","text":"<ul> <li>Cache pip dependencies for faster builds</li> <li>Use environment-specific extras</li> <li>Implement proper credential management</li> <li>Test with minimal permission sets</li> </ul>"},{"location":"installation/#kubernetes-deployments","title":"Kubernetes Deployments","text":"<ul> <li>Use init containers for dependency installation</li> <li>Leverage service accounts for cloud provider authentication</li> <li>Implement proper resource limits</li> <li>Consider using distroless base images</li> </ul>"},{"location":"installation/#troubleshooting-installation","title":"Troubleshooting Installation","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":""},{"location":"installation/#missing-provider-dependencies","title":"Missing Provider Dependencies","text":"<p>Error: <code>ImportError: No module named 'hvac'</code></p> <p>Solution: Install with provider extras: <pre><code>pip install mlflow-secrets-auth[vault]\n</code></pre></p>"},{"location":"installation/#version-conflicts","title":"Version Conflicts","text":"<p>Error: Package version conflicts</p> <p>Solution: Use virtual environments: <pre><code>python -m venv mlflow-env\nsource mlflow-env/bin/activate  # Linux/macOS\n# mlflow-env\\Scripts\\activate  # Windows\npip install mlflow-secrets-auth[vault,aws,azure]\n</code></pre></p>"},{"location":"installation/#plugin-not-recognized","title":"Plugin Not Recognized","text":"<p>Error: MLflow doesn't recognize the auth provider</p> <p>Solution: Verify entry point registration: <pre><code>python -c \"\nimport pkg_resources\nfor ep in pkg_resources.iter_entry_points('mlflow.request_auth_provider'):\n    print(f'{ep.name}: {ep.module_name}')\n\"\n</code></pre></p>"},{"location":"installation/#debug-installation","title":"Debug Installation","text":"<p>Enable verbose logging during installation:</p> <pre><code>pip install -v mlflow-secrets-auth[vault,aws,azure]\n</code></pre> <p>Check installed packages and versions:</p> <pre><code>pip list | grep -E \"(mlflow|vault|boto3|azure)\"\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li>Configuration - Set up environment variables and security settings</li> <li>Getting Started - Quick start guide with examples</li> <li>Provider Documentation - Provider-specific configuration</li> <li>CLI Tools - Command-line utilities for testing and diagnostics</li> </ol>"},{"location":"installation/#uninstallation","title":"Uninstallation","text":"<p>To remove the plugin and its dependencies:</p> <pre><code># Remove the main package\npip uninstall mlflow-secrets-auth\n\n# Remove provider dependencies if not needed\npip uninstall hvac boto3 azure-identity azure-keyvault-secrets\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This guide covers common issues, diagnostic procedures, and solutions for MLflow Secrets Auth. Use this guide to resolve configuration problems, authentication failures, and performance issues.</p>"},{"location":"troubleshooting/#quick-diagnostics","title":"Quick Diagnostics","text":""},{"location":"troubleshooting/#check-plugin-status","title":"Check Plugin Status","text":"<p>Start troubleshooting with basic status checks:</p> <pre><code># Check plugin installation and configuration\nmlflow-secrets-auth info\n\n# Run comprehensive diagnostics\nmlflow-secrets-auth doctor\n\n# Test against specific MLflow server\nmlflow-secrets-auth doctor --dry-run https://your-mlflow-server.com\n</code></pre>"},{"location":"troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<p>Enable detailed logging for troubleshooting:</p> <pre><code>export MLFLOW_SECRETS_LOG_LEVEL=DEBUG\nmlflow-secrets-auth doctor\n</code></pre>"},{"location":"troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"troubleshooting/#plugin-not-recognized","title":"Plugin Not Recognized","text":""},{"location":"troubleshooting/#symptoms","title":"Symptoms","text":"<ul> <li>MLflow doesn't use authentication</li> <li>No authentication headers in requests</li> <li>Plugin appears inactive</li> </ul>"},{"location":"troubleshooting/#diagnosis","title":"Diagnosis","text":"<pre><code># Check if plugin is installed\npip show mlflow-secrets-auth\n\n# Verify entry point registration\npython -c \"\nimport pkg_resources\nfor ep in pkg_resources.iter_entry_points('mlflow.request_auth_provider'):\n    print(f'{ep.name}: {ep.module_name}')\n\"\n\n# Check if any provider is enabled\npython -c \"\nfrom mlflow_secrets_auth.config import is_provider_enabled\nproviders = ['vault', 'aws-secrets-manager', 'azure-key-vault']\nenabled = [p for p in providers if is_provider_enabled(p)]\nprint(f'Enabled providers: {enabled}')\n\"\n</code></pre>"},{"location":"troubleshooting/#solutions","title":"Solutions","text":"<ol> <li> <p>Install the Plugin:    <pre><code>pip install mlflow-secrets-auth[vault,aws,azure]\n</code></pre></p> </li> <li> <p>Enable a Provider:    <pre><code>export MLFLOW_SECRETS_AUTH_ENABLE=\"vault\"\n# OR\nexport MLFLOW_SECRETS_AUTH_ENABLE_VAULT=true\n</code></pre></p> </li> <li> <p>Verify MLflow Version:    <pre><code>pip install \"mlflow&gt;=2.20.4\"\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#authentication-failures","title":"Authentication Failures","text":""},{"location":"troubleshooting/#symptoms_1","title":"Symptoms","text":"<ul> <li>\"Authentication failed\" errors</li> <li>401/403 HTTP responses</li> <li>Secret retrieval failures</li> </ul>"},{"location":"troubleshooting/#provider-specific-diagnosis","title":"Provider-Specific Diagnosis","text":"<p>Vault: <pre><code># Test Vault connectivity\ncurl -k \"$VAULT_ADDR/v1/sys/health\"\n\n# Check token validity\nvault token lookup \"$VAULT_TOKEN\"\n\n# Test secret access\nvault kv get \"$MLFLOW_VAULT_SECRET_PATH\"\n</code></pre></p> <p>AWS: <pre><code># Check AWS credentials\naws sts get-caller-identity\n\n# Test secret access\naws secretsmanager get-secret-value --secret-id \"$MLFLOW_AWS_SECRET_NAME\"\n\n# Verify permissions\naws iam simulate-principal-policy \\\n  --policy-source-arn \"$(aws sts get-caller-identity --query Arn --output text)\" \\\n  --action-names \"secretsmanager:GetSecretValue\" \\\n  --resource-arns \"arn:aws:secretsmanager:region:account:secret:$MLFLOW_AWS_SECRET_NAME-*\"\n</code></pre></p> <p>Azure: <pre><code># Check Azure login\naz account show\n\n# Test Key Vault access\naz keyvault secret show \\\n  --vault-name \"vault-name\" \\\n  --name \"$MLFLOW_AZURE_SECRET_NAME\"\n\n# Check access policies\naz keyvault show \\\n  --name \"vault-name\" \\\n  --query \"properties.accessPolicies\"\n</code></pre></p>"},{"location":"troubleshooting/#solutions_1","title":"Solutions","text":"<ol> <li>Verify Credentials: Ensure authentication credentials are valid and not expired</li> <li>Check Permissions: Verify the service has appropriate permissions to read secrets</li> <li>Test Connectivity: Ensure network connectivity to the secret management service</li> <li>Validate Configuration: Check all required environment variables are set</li> </ol>"},{"location":"troubleshooting/#host-not-allowed","title":"Host Not Allowed","text":""},{"location":"troubleshooting/#symptoms_2","title":"Symptoms","text":"<ul> <li>\"Host not allowed\" errors</li> <li>Authentication works for some URLs but not others</li> <li>Wildcard patterns not matching expected hosts</li> </ul>"},{"location":"troubleshooting/#diagnosis_1","title":"Diagnosis","text":"<pre><code># Check current allowlist configuration\npython -c \"\nfrom mlflow_secrets_auth.config import get_allowed_hosts\nprint(f'Allowed hosts: {get_allowed_hosts()}')\n\"\n\n# Test host matching\npython -c \"\nimport fnmatch\nfrom mlflow_secrets_auth.config import get_allowed_hosts\nfrom urllib.parse import urlparse\n\nurl = 'https://your-server.com'\nhostname = urlparse(url).hostname\nallowed = get_allowed_hosts()\n\nif allowed:\n    matches = [pattern for pattern in allowed if fnmatch.fnmatch(hostname, pattern)]\n    print(f'Host: {hostname}')\n    print(f'Patterns: {allowed}')\n    print(f'Matches: {matches}')\nelse:\n    print('No host restrictions configured')\n\"\n</code></pre>"},{"location":"troubleshooting/#solutions_2","title":"Solutions","text":"<ol> <li> <p>Add Host to Allowlist:    <pre><code>export MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com,existing-hosts\"\n</code></pre></p> </li> <li> <p>Use Wildcard Patterns:    <pre><code>export MLFLOW_SECRETS_ALLOWED_HOSTS=\"*.company.com\"\n</code></pre></p> </li> <li> <p>Temporary Testing (not recommended for production):    <pre><code>unset MLFLOW_SECRETS_ALLOWED_HOSTS  # Allows all hosts\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#secret-not-found","title":"Secret Not Found","text":""},{"location":"troubleshooting/#symptoms_3","title":"Symptoms","text":"<ul> <li>\"Secret not found\" errors</li> <li>Path or name not found messages</li> <li>Empty secret responses</li> </ul>"},{"location":"troubleshooting/#diagnosis_2","title":"Diagnosis","text":"<pre><code># List available secrets\n# Vault\nvault kv list secret/\n\n# AWS\naws secretsmanager list-secrets\n\n# Azure\naz keyvault secret list --vault-name \"your-vault\"\n\n# Check secret content\n# Vault\nvault kv get secret/path/to/secret\n\n# AWS\naws secretsmanager get-secret-value --secret-id \"secret-name\"\n\n# Azure\naz keyvault secret show --vault-name \"vault\" --name \"secret-name\"\n</code></pre>"},{"location":"troubleshooting/#solutions_3","title":"Solutions","text":"<ol> <li>Verify Secret Path/Name: Ensure the path or name exactly matches the stored secret</li> <li>Check Secret Format: Verify the secret contains expected fields (<code>token</code>, <code>username</code>, <code>password</code>)</li> <li>Validate Permissions: Ensure read access to the specific secret</li> <li>Test Different Versions: For AWS/Azure, try different secret versions</li> </ol>"},{"location":"troubleshooting/#cache-issues","title":"Cache Issues","text":""},{"location":"troubleshooting/#symptoms_4","title":"Symptoms","text":"<ul> <li>Stale authentication credentials</li> <li>Authentication works intermittently</li> <li>Changes to secrets not reflected</li> </ul>"},{"location":"troubleshooting/#diagnosis_3","title":"Diagnosis","text":"<pre><code># Check cache status (future feature)\nmlflow-secrets-auth info  # Shows cache hit rate\n\n# Test with debug logging\nMLFLOW_SECRETS_LOG_LEVEL=DEBUG mlflow-secrets-auth doctor\n</code></pre>"},{"location":"troubleshooting/#solutions_4","title":"Solutions","text":"<ol> <li> <p>Clear Cache (restart application):    <pre><code># Current: restart the application\n# Future: mlflow-secrets-auth cache clear\n</code></pre></p> </li> <li> <p>Reduce TTL:    <pre><code>export MLFLOW_VAULT_TTL_SEC=60      # 1 minute\nexport MLFLOW_AWS_TTL_SEC=60\nexport MLFLOW_AZURE_TTL_SEC=60\n</code></pre></p> </li> <li> <p>Force Cache Bust: Authentication failures automatically clear cache</p> </li> </ol>"},{"location":"troubleshooting/#network-connectivity","title":"Network Connectivity","text":""},{"location":"troubleshooting/#symptoms_5","title":"Symptoms","text":"<ul> <li>Connection timeouts</li> <li>DNS resolution failures</li> <li>SSL/TLS errors</li> </ul>"},{"location":"troubleshooting/#diagnosis_4","title":"Diagnosis","text":"<pre><code># Test basic connectivity\n# Vault\ncurl -v \"$VAULT_ADDR/v1/sys/health\"\n\n# AWS (test any AWS service)\naws sts get-caller-identity\n\n# Azure\ncurl -v \"https://vault-name.vault.azure.net/\"\n\n# Check DNS resolution\nnslookup vault.company.com\nnslookup secretsmanager.us-east-1.amazonaws.com\nnslookup vault-name.vault.azure.net\n\n# Test SSL/TLS\nopenssl s_client -connect vault.company.com:443 -servername vault.company.com\n</code></pre>"},{"location":"troubleshooting/#solutions_5","title":"Solutions","text":"<ol> <li>Verify Network Access: Ensure outbound connectivity to required endpoints</li> <li>Check Firewall Rules: Verify firewall allows HTTPS traffic</li> <li>Validate DNS: Ensure DNS resolution works for the secret management service</li> <li>Certificate Issues: For Vault, consider <code>VAULT_SKIP_VERIFY=true</code> for testing (not production)</li> </ol>"},{"location":"troubleshooting/#configuration-errors","title":"Configuration Errors","text":""},{"location":"troubleshooting/#symptoms_6","title":"Symptoms","text":"<ul> <li>Missing environment variable errors</li> <li>Invalid configuration warnings</li> <li>Unexpected default values</li> </ul>"},{"location":"troubleshooting/#diagnosis_5","title":"Diagnosis","text":"<pre><code># Check all environment variables\nenv | grep -E \"(VAULT_|AWS_|AZURE_|MLFLOW_SECRETS_)\"\n\n# Validate configuration\nmlflow-secrets-auth info\n</code></pre>"},{"location":"troubleshooting/#solutions_6","title":"Solutions","text":"<ol> <li>Set Required Variables: Ensure all required environment variables are set</li> <li>Check Variable Names: Verify correct spelling and format of environment variables</li> <li>Validate Values: Ensure values are in the expected format (URLs, regions, etc.)</li> </ol>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#slow-secret-retrieval","title":"Slow Secret Retrieval","text":""},{"location":"troubleshooting/#symptoms_7","title":"Symptoms","text":"<ul> <li>Long delays in authentication</li> <li>Timeouts during secret fetching</li> <li>Poor application performance</li> </ul>"},{"location":"troubleshooting/#diagnosis_6","title":"Diagnosis","text":"<pre><code># Time secret retrieval\ntime mlflow-secrets-auth doctor\n\n# Check network latency\nping vault.company.com\nping secretsmanager.us-east-1.amazonaws.com\n</code></pre>"},{"location":"troubleshooting/#solutions_7","title":"Solutions","text":"<ol> <li> <p>Optimize TTL: Increase cache TTL for better performance:    <pre><code>export MLFLOW_VAULT_TTL_SEC=1800    # 30 minutes\n</code></pre></p> </li> <li> <p>Use Regional Endpoints: Ensure using the closest regional endpoint</p> </li> <li>Network Optimization: Use VPC endpoints, private networking</li> <li>Connection Pooling: The plugin automatically reuses connections</li> </ol>"},{"location":"troubleshooting/#high-memory-usage","title":"High Memory Usage","text":""},{"location":"troubleshooting/#symptoms_8","title":"Symptoms","text":"<ul> <li>Excessive memory consumption</li> <li>Memory leaks over time</li> <li>Out of memory errors</li> </ul>"},{"location":"troubleshooting/#diagnosis_7","title":"Diagnosis","text":"<pre><code># Monitor memory usage\nps aux | grep python\ntop -p $(pgrep -f mlflow)\n\n# Check cache size (future feature)\n# mlflow-secrets-auth cache status\n</code></pre>"},{"location":"troubleshooting/#solutions_8","title":"Solutions","text":"<ol> <li> <p>Reduce Cache TTL: Lower TTL reduces memory usage:    <pre><code>export MLFLOW_VAULT_TTL_SEC=300     # 5 minutes\n</code></pre></p> </li> <li> <p>Monitor Cache: Restart applications periodically if needed</p> </li> <li>Update Plugin: Ensure using the latest version with memory optimizations</li> </ol>"},{"location":"troubleshooting/#environment-specific-issues","title":"Environment-Specific Issues","text":""},{"location":"troubleshooting/#development-environment","title":"Development Environment","text":""},{"location":"troubleshooting/#common-issues_1","title":"Common Issues","text":"<ul> <li>Local secret managers not configured</li> <li>Development certificates/tokens</li> <li>Network access restrictions</li> </ul>"},{"location":"troubleshooting/#solutions_9","title":"Solutions","text":"<pre><code># Use local Vault for development\nexport VAULT_ADDR=\"http://localhost:8200\"\nexport VAULT_TOKEN=\"dev-only-token\"\nexport MLFLOW_VAULT_SECRET_PATH=\"secret/dev/mlflow\"\n\n# Disable host restrictions for development\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"localhost,127.0.0.1,*.local\"\n\n# Enable debug logging\nexport MLFLOW_SECRETS_LOG_LEVEL=\"DEBUG\"\n</code></pre>"},{"location":"troubleshooting/#cicd-environment","title":"CI/CD Environment","text":""},{"location":"troubleshooting/#common-issues_2","title":"Common Issues","text":"<ul> <li>Missing environment variables</li> <li>Temporary credentials</li> <li>Build pipeline failures</li> </ul>"},{"location":"troubleshooting/#solutions_10","title":"Solutions","text":"<pre><code># Validate configuration in CI\nmlflow-secrets-auth doctor\nif [ $? -ne 0 ]; then\n    echo \"MLflow Secrets Auth configuration failed\"\n    exit 1\nfi\n\n# Use short TTL in CI\nexport MLFLOW_VAULT_TTL_SEC=60\n\n# Test against staging environment\nmlflow-secrets-auth doctor --dry-run \"$STAGING_MLFLOW_URL\"\n</code></pre>"},{"location":"troubleshooting/#production-environment","title":"Production Environment","text":""},{"location":"troubleshooting/#common-issues_3","title":"Common Issues","text":"<ul> <li>Credential rotation</li> <li>High availability requirements</li> <li>Security restrictions</li> </ul>"},{"location":"troubleshooting/#solutions_11","title":"Solutions","text":"<pre><code># Use appropriate TTL for production\nexport MLFLOW_VAULT_TTL_SEC=900     # 15 minutes\n\n# Enable appropriate logging level\nexport MLFLOW_SECRETS_LOG_LEVEL=\"WARNING\"\n\n# Use production-grade allowlisting\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com\"\n\n# Monitor authentication failures\n# (Set up alerting on authentication errors)\n</code></pre>"},{"location":"troubleshooting/#provider-specific-troubleshooting","title":"Provider-Specific Troubleshooting","text":""},{"location":"troubleshooting/#vault-troubleshooting","title":"Vault Troubleshooting","text":""},{"location":"troubleshooting/#kv-version-issues","title":"KV Version Issues","text":"<pre><code># Check KV engine version\nvault secrets list -detailed | grep secret\n\n# Test both KV v1 and v2 paths\nvault kv get secret/mlflow/auth          # KV v2\nvault read secret/mlflow/auth            # KV v1\n</code></pre>"},{"location":"troubleshooting/#approle-issues","title":"AppRole Issues","text":"<pre><code># Test AppRole login\nvault write auth/approle/login \\\n  role_id=\"$VAULT_ROLE_ID\" \\\n  secret_id=\"$VAULT_SECRET_ID\"\n\n# Check role configuration\nvault read auth/approle/role/mlflow-secrets-auth\n</code></pre>"},{"location":"troubleshooting/#aws-troubleshooting","title":"AWS Troubleshooting","text":""},{"location":"troubleshooting/#iam-issues","title":"IAM Issues","text":"<pre><code># Check effective permissions\naws iam get-account-authorization-details\n\n# Test assume role\naws sts assume-role \\\n  --role-arn \"$AWS_ROLE_ARN\" \\\n  --role-session-name \"test-session\"\n</code></pre>"},{"location":"troubleshooting/#cross-region-issues","title":"Cross-Region Issues","text":"<pre><code># List secrets in different regions\naws secretsmanager list-secrets --region us-east-1\naws secretsmanager list-secrets --region us-west-2\n</code></pre>"},{"location":"troubleshooting/#azure-troubleshooting","title":"Azure Troubleshooting","text":""},{"location":"troubleshooting/#managed-identity-issues","title":"Managed Identity Issues","text":"<pre><code># Test managed identity from Azure VM\ncurl -H \"Metadata:true\" \\\n  \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&amp;resource=https://vault.azure.net/\"\n</code></pre>"},{"location":"troubleshooting/#rbac-vs-access-policy","title":"RBAC vs Access Policy","text":"<pre><code># Check if RBAC is enabled\naz keyvault show --name \"vault-name\" --query \"properties.enableRbacAuthorization\"\n\n# List RBAC assignments\naz role assignment list --assignee \"$AZURE_CLIENT_ID\"\n</code></pre>"},{"location":"troubleshooting/#advanced-debugging","title":"Advanced Debugging","text":""},{"location":"troubleshooting/#packet-capture","title":"Packet Capture","text":"<p>For network-level debugging:</p> <pre><code># Capture HTTPS traffic (requires root)\nsudo tcpdump -i any -w mlflow-auth.pcap host vault.company.com\n\n# Analyze with Wireshark or tshark\ntshark -r mlflow-auth.pcap -Y \"ssl\"\n</code></pre>"},{"location":"troubleshooting/#python-debugging","title":"Python Debugging","text":"<p>For code-level debugging:</p> <pre><code>import logging\nimport mlflow_secrets_auth\n\n# Enable debug logging for all components\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger('mlflow_secrets_auth')\nlogger.setLevel(logging.DEBUG)\n\n# Test provider directly\nfrom mlflow_secrets_auth import SecretsAuthProviderFactory\nfactory = SecretsAuthProviderFactory()\nauth = factory.get_request_auth(\"https://mlflow.company.com\")\nprint(f\"Auth object: {auth}\")\n</code></pre>"},{"location":"troubleshooting/#logging-analysis","title":"Logging Analysis","text":"<p>Understanding log output:</p> <pre><code># Normal operation\nINFO: Secret fetched successfully (provider=vault, cache_hit=false)\nINFO: Authentication successful (provider=vault, auth_mode=bearer)\n\n# Cache hits\nDEBUG: Cache hit for key: vault:https://vault.company.com:secret/mlflow/auth\nINFO: Secret fetched successfully (provider=vault, cache_hit=true)\n\n# Errors\nERROR: Vault authentication failed: 403 Forbidden\nWARNING: Host not allowed: external.example.com\nERROR: Secret not found at path: secret/wrong/path\n</code></pre>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"troubleshooting/#before-asking-for-help","title":"Before Asking for Help","text":"<ol> <li>Check the Logs: Enable debug logging and review the output</li> <li>Run Diagnostics: Use <code>mlflow-secrets-auth doctor</code></li> <li>Test Components: Test each component (network, auth, secrets) individually</li> <li>Review Configuration: Double-check all environment variables</li> <li>Check Documentation: Review provider-specific documentation</li> </ol>"},{"location":"troubleshooting/#information-to-include","title":"Information to Include","text":"<p>When reporting issues, include:</p> <ol> <li>Plugin Version: <code>pip show mlflow-secrets-auth</code></li> <li>Python Version: <code>python --version</code></li> <li>MLflow Version: <code>pip show mlflow</code></li> <li>Environment: Development/staging/production</li> <li>Provider: Vault/AWS/Azure</li> <li>Configuration: Relevant environment variables (redacted)</li> <li>Error Messages: Full error messages and stack traces</li> <li>Debug Logs: Output from debug logging</li> <li>Diagnostic Output: Output from <code>mlflow-secrets-auth doctor</code></li> </ol>"},{"location":"troubleshooting/#useful-commands-for-bug-reports","title":"Useful Commands for Bug Reports","text":"<pre><code># Collect system information\necho \"Plugin version:\"\npip show mlflow-secrets-auth\n\necho \"Python version:\"\npython --version\n\necho \"MLflow version:\"\npip show mlflow\n\necho \"Environment variables:\"\nenv | grep -E \"(VAULT_|AWS_|AZURE_|MLFLOW_SECRETS_)\" | sed 's/=.*/=***/'\n\necho \"Diagnostic output:\"\nMLFLOW_SECRETS_LOG_LEVEL=DEBUG mlflow-secrets-auth doctor\n</code></pre>"},{"location":"troubleshooting/#prevention","title":"Prevention","text":""},{"location":"troubleshooting/#best-practices-for-avoiding-issues","title":"Best Practices for Avoiding Issues","text":"<ol> <li>Test in Staging: Always test configuration changes in staging first</li> <li>Monitor Logs: Set up log monitoring for authentication failures</li> <li>Health Checks: Implement health checks using the CLI</li> <li>Documentation: Document your configuration and troubleshooting steps</li> <li>Regular Updates: Keep the plugin and dependencies updated</li> </ol>"},{"location":"troubleshooting/#monitoring-and-alerting","title":"Monitoring and Alerting","text":"<pre><code># Health check script\n#!/bin/bash\nif ! mlflow-secrets-auth doctor &gt; /dev/null 2&gt;&amp;1; then\n    echo \"ALERT: MLflow Secrets Auth health check failed\"\n    exit 1\nfi\n\n# Performance monitoring\n#!/bin/bash\nstart_time=$(date +%s%N)\nmlflow-secrets-auth doctor &gt; /dev/null 2&gt;&amp;1\nend_time=$(date +%s%N)\nduration=$(( (end_time - start_time) / 1000000 ))  # milliseconds\n\nif [ $duration -gt 5000 ]; then  # 5 seconds\n    echo \"ALERT: MLflow Secrets Auth response time: ${duration}ms\"\nfi\n</code></pre>"},{"location":"troubleshooting/#configuration-validation","title":"Configuration Validation","text":"<pre><code>#!/bin/bash\n# Configuration validation script\n\nrequired_vars=()\ncase \"$MLFLOW_SECRETS_AUTH_ENABLE\" in\n    *vault*)\n        required_vars+=(\"VAULT_ADDR\" \"MLFLOW_VAULT_SECRET_PATH\")\n        ;;\n    *aws-secrets-manager*)\n        required_vars+=(\"AWS_REGION\" \"MLFLOW_AWS_SECRET_NAME\")\n        ;;\n    *azure-key-vault*)\n        required_vars+=(\"MLFLOW_AZURE_KEY_VAULT_URL\" \"MLFLOW_AZURE_SECRET_NAME\")\n        ;;\nesac\n\nfor var in \"${required_vars[@]}\"; do\n    if [ -z \"${!var}\" ]; then\n        echo \"ERROR: Required variable $var is not set\"\n        exit 1\n    fi\ndone\n\necho \"Configuration validation passed\"\n</code></pre>"},{"location":"troubleshooting/#next-steps","title":"Next Steps","text":"<ul> <li>CLI Reference - Command-line tools for diagnostics</li> <li>Configuration Reference - Complete configuration options</li> <li>Provider Documentation - Provider-specific troubleshooting</li> <li>FAQ - Frequently asked questions and answers</li> </ul>"},{"location":"concepts/architecture/","title":"Architecture","text":"<p>MLflow Secrets Auth implements a clean, extensible architecture that seamlessly integrates with MLflow's authentication system while maintaining security and performance best practices.</p>"},{"location":"concepts/architecture/#overview","title":"Overview","text":"<p>The plugin uses a factory pattern with provider-specific implementations to retrieve credentials from various secret management systems. The architecture emphasizes security, caching, and extensibility while maintaining compatibility with MLflow's existing authentication framework.</p>"},{"location":"concepts/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>graph TB\n    A[MLflow Client] --&gt;|HTTP Request| B[MLflow Request Handler]\n    B --&gt;|Auth Provider| C[SecretsAuthProviderFactory]\n    C --&gt;|Provider Selection| D{First Available Provider}\n\n    D --&gt;|Vault Enabled| E[VaultAuthProvider]\n    D --&gt;|AWS Enabled| F[AWSSecretsManagerAuthProvider]\n    D --&gt;|Azure Enabled| G[AzureKeyVaultAuthProvider]\n\n    E --&gt;|Fetch Secret| H[Cache Layer]\n    F --&gt;|Fetch Secret| H\n    G --&gt;|Fetch Secret| H\n\n    H --&gt;|Cache Hit| I[Return Cached Auth]\n    H --&gt;|Cache Miss| J[Provider Secret Fetch]\n\n    J --&gt;|Success| K[Parse &amp; Validate Secret]\n    K --&gt;|Valid| L[Create Auth Object]\n    L --&gt;|Cache| H\n    L --&gt;|Return| M[Inject Auth Header]\n\n    M --&gt;|Authenticated Request| N[MLflow Server]</code></pre>"},{"location":"concepts/architecture/#core-components","title":"Core Components","text":""},{"location":"concepts/architecture/#secretsauthproviderfactory","title":"SecretsAuthProviderFactory","text":"<p>The main factory class that implements MLflow's <code>RequestAuthProvider</code> interface and manages provider selection.</p> <p>Responsibilities: - Provider discovery and instantiation - Request routing to active provider - Fallback behavior when no provider is available - Integration with MLflow's authentication lifecycle</p> <p>Key Methods: - <code>get_request_auth(url)</code> - Main entry point for authentication - <code>_get_actual_provider()</code> - Lazy provider instantiation - <code>_is_enabled()</code> - Provider availability check</p>"},{"location":"concepts/architecture/#secretsbackedauthprovider-base-class","title":"SecretsBackedAuthProvider (Base Class)","text":"<p>Abstract base class that defines the common interface and shared functionality for all provider implementations.</p> <p>Core Features: - Caching with configurable TTL - Retry logic with exponential backoff and jitter - Host allowlisting validation - Credential parsing and validation - Error handling and logging</p> <p>Abstract Methods: <pre><code>def _fetch_secret(self) -&gt; str | None\ndef _get_cache_key(self) -&gt; str\ndef _get_auth_mode(self) -&gt; str\ndef _get_ttl(self) -&gt; int\n</code></pre></p>"},{"location":"concepts/architecture/#provider-implementations","title":"Provider Implementations","text":""},{"location":"concepts/architecture/#vaultauthprovider","title":"VaultAuthProvider","text":"<ul> <li>Authentication: Token or AppRole</li> <li>Secret Formats: KV v1 and KV v2 support</li> <li>Features: Auto-detection of KV version, graceful fallback</li> </ul>"},{"location":"concepts/architecture/#awssecretsmanagerauthprovider","title":"AWSSecretsManagerAuthProvider","text":"<ul> <li>Authentication: IAM credentials, roles, profiles</li> <li>Secret Formats: SecretString and SecretBinary</li> <li>Features: Multi-region support, version handling</li> </ul>"},{"location":"concepts/architecture/#azurekeyvaultauthprovider","title":"AzureKeyVaultAuthProvider","text":"<ul> <li>Authentication: DefaultAzureCredential chain</li> <li>Secret Formats: Key Vault secrets</li> <li>Features: Managed identity support, certificate auth</li> </ul>"},{"location":"concepts/architecture/#secret-resolution-flow","title":"Secret Resolution Flow","text":""},{"location":"concepts/architecture/#1-request-interception","title":"1. Request Interception","text":"<pre><code># MLflow makes HTTP request\nresponse = requests.get(\n    \"https://mlflow.company.com/api/2.0/mlflow/experiments/list\",\n    auth=auth_provider.get_request_auth(url)\n)\n</code></pre>"},{"location":"concepts/architecture/#2-provider-selection","title":"2. Provider Selection","text":"<pre><code>def _get_actual_provider(self) -&gt; SecretsBackedAuthProvider | None:\n    \"\"\"Select first available provider from priority list.\"\"\"\n    for name, provider_cls in self._PROVIDERS.items():\n        if is_provider_enabled(name):\n            try:\n                return provider_cls()\n            except Exception:\n                continue  # Try next provider\n    return None\n</code></pre>"},{"location":"concepts/architecture/#3-host-validation","title":"3. Host Validation","text":"<pre><code>def _is_host_allowed(self, hostname: str) -&gt; bool:\n    \"\"\"Validate hostname against allowlist patterns.\"\"\"\n    allowed_hosts = get_allowed_hosts()\n    if not allowed_hosts:\n        return True\n\n    return any(\n        fnmatch.fnmatch(hostname, pattern)\n        for pattern in allowed_hosts\n    )\n</code></pre>"},{"location":"concepts/architecture/#4-cache-check","title":"4. Cache Check","text":"<pre><code>def _fetch_secret_cached(self) -&gt; dict[str, str] | None:\n    \"\"\"Check cache first, fetch if needed.\"\"\"\n    cache_key = self._get_cache_key()\n    cached = self._cache.get(cache_key)\n\n    if cached and not cached.is_expired():\n        return cached.data\n\n    # Cache miss - fetch from provider\n    secret = self._fetch_secret()\n    if secret:\n        self._cache.set(cache_key, secret, self._get_ttl())\n\n    return secret\n</code></pre>"},{"location":"concepts/architecture/#5-secret-fetching","title":"5. Secret Fetching","text":"<p>Provider-specific implementation retrieves secret from the configured source:</p> <pre><code># Vault example\ndef _fetch_secret(self) -&gt; str | None:\n    client = self._get_vault_client()\n    response = client.secrets.kv.v2.read_secret_version(path=secret_path)\n    return json.dumps(response[\"data\"][\"data\"])\n</code></pre>"},{"location":"concepts/architecture/#6-authentication-object-creation","title":"6. Authentication Object Creation","text":"<pre><code>def _create_auth(self, secret_data: dict[str, str]) -&gt; requests.auth.AuthBase:\n    \"\"\"Create appropriate auth object based on mode.\"\"\"\n    auth_mode = self._get_auth_mode()\n\n    if auth_mode == \"bearer\":\n        token = secret_data.get(\"token\")\n        return BearerAuth(token)\n    elif auth_mode == \"basic\":\n        username = secret_data.get(\"username\")\n        password = secret_data.get(\"password\")\n        return HTTPBasicAuth(username, password)\n</code></pre>"},{"location":"concepts/architecture/#caching-architecture","title":"Caching Architecture","text":""},{"location":"concepts/architecture/#cache-implementation","title":"Cache Implementation","text":"<p>The caching layer provides in-memory storage with TTL expiration and automatic cache busting.</p> <p>Features: - Per-configuration caching (different configs = different cache entries) - Configurable TTL per provider - Automatic expiration based on timestamps - Cache busting on authentication failures (401/403) - Thread-safe operations</p>"},{"location":"concepts/architecture/#cache-key-generation","title":"Cache Key Generation","text":"<p>Cache keys are generated based on provider-specific configuration to ensure proper isolation:</p> <pre><code># Vault example\ndef _get_cache_key(self) -&gt; str:\n    vault_addr = get_env_var(\"VAULT_ADDR\", \"\")\n    secret_path = get_env_var(\"MLFLOW_VAULT_SECRET_PATH\", \"\")\n    return f\"{vault_addr}:{secret_path}\"\n</code></pre>"},{"location":"concepts/architecture/#cache-lifecycle","title":"Cache Lifecycle","text":"<pre><code>graph LR\n    A[Request] --&gt; B{Cache Hit?}\n    B --&gt;|Yes| C{Expired?}\n    B --&gt;|No| D[Fetch Secret]\n    C --&gt;|No| E[Return Cached]\n    C --&gt;|Yes| D\n    D --&gt; F{Success?}\n    F --&gt;|Yes| G[Update Cache]\n    F --&gt;|No| H[Return Error]\n    G --&gt; I[Return Secret]</code></pre>"},{"location":"concepts/architecture/#error-handling-and-resilience","title":"Error Handling and Resilience","text":""},{"location":"concepts/architecture/#retry-logic","title":"Retry Logic","text":"<p>The plugin implements sophisticated retry logic with exponential backoff and jitter:</p> <pre><code>def retry_with_jitter(func, max_retries=3, base_delay=1.0, max_delay=30.0):\n    \"\"\"Execute function with exponential backoff and jitter.\"\"\"\n    for attempt in range(max_retries + 1):\n        try:\n            return func()\n        except Exception as e:\n            if attempt == max_retries:\n                raise e\n\n            # Exponential backoff with jitter\n            delay = min(base_delay * (2 ** attempt), max_delay)\n            jitter = random.uniform(0, delay * 0.1)\n            time.sleep(delay + jitter)\n</code></pre>"},{"location":"concepts/architecture/#failure-modes","title":"Failure Modes","text":"<p>The architecture handles various failure scenarios gracefully:</p> <ol> <li>Provider Unavailable: Factory selects next available provider</li> <li>Network Failures: Retry with exponential backoff</li> <li>Authentication Failures: Cache busting and re-authentication</li> <li>Configuration Errors: Detailed error messages and fallback behavior</li> <li>Secret Not Found: Graceful degradation with logging</li> </ol>"},{"location":"concepts/architecture/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<p>For production resilience, the plugin implements circuit breaker behavior:</p> <pre><code>class ProviderCircuitBreaker:\n    def __init__(self, failure_threshold=5, timeout=60):\n        self.failure_count = 0\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.last_failure_time = None\n        self.state = \"CLOSED\"  # CLOSED, OPEN, HALF_OPEN\n</code></pre>"},{"location":"concepts/architecture/#security-architecture","title":"Security Architecture","text":""},{"location":"concepts/architecture/#host-allowlisting","title":"Host Allowlisting","text":"<p>Host validation prevents credential leakage to unauthorized servers:</p> <pre><code>def validate_host(self, url: str) -&gt; bool:\n    \"\"\"Validate URL host against allowlist.\"\"\"\n    parsed = urlparse(url)\n    hostname = parsed.hostname\n\n    if not hostname:\n        return False\n\n    allowed_hosts = get_allowed_hosts()\n    if not allowed_hosts:\n        return True  # No restrictions if not configured\n\n    return any(\n        fnmatch.fnmatch(hostname, pattern)\n        for pattern in allowed_hosts\n    )\n</code></pre>"},{"location":"concepts/architecture/#credential-redaction","title":"Credential Redaction","text":"<p>All logging output automatically redacts sensitive information:</p> <pre><code>def redact_sensitive_data(text: str) -&gt; str:\n    \"\"\"Redact common credential patterns from text.\"\"\"\n    patterns = [\n        r\"(Bearer\\s+)([A-Za-z0-9._\\-]+)\",\n        r\"(Basic\\s+)([A-Za-z0-9+/=]+)\",\n        r'(\"(?:token|password|secret|key)\"\\s*:\\s*\")([^\"]+)(\")',\n    ]\n\n    for pattern in patterns:\n        text = re.sub(pattern, lambda m: f\"{m.group(1)}{mask_secret(m.group(2))}{m.group(3) if len(m.groups()) &gt; 2 else ''}\", text)\n\n    return text\n</code></pre>"},{"location":"concepts/architecture/#memory-security","title":"Memory Security","text":"<ul> <li>No persistence of credentials to disk</li> <li>Secure memory handling for sensitive data</li> <li>Automatic cleanup of expired cache entries</li> <li>Zero-copy operations where possible</li> </ul>"},{"location":"concepts/architecture/#extensibility","title":"Extensibility","text":""},{"location":"concepts/architecture/#adding-new-providers","title":"Adding New Providers","text":"<p>The architecture supports easy addition of new secret management providers:</p> <pre><code>class CustomProvider(SecretsBackedAuthProvider):\n    def __init__(self):\n        super().__init__(\"custom\", default_ttl=300)\n\n    def _fetch_secret(self) -&gt; str | None:\n        # Implement custom secret fetching logic\n        pass\n\n    def _get_cache_key(self) -&gt; str:\n        # Generate provider-specific cache key\n        pass\n\n    def _get_auth_mode(self) -&gt; str:\n        # Return \"bearer\" or \"basic\"\n        pass\n\n    def _get_ttl(self) -&gt; int:\n        # Return cache TTL in seconds\n        pass\n</code></pre>"},{"location":"concepts/architecture/#configuration-system","title":"Configuration System","text":"<p>The configuration system uses environment variables for consistency and container-friendliness:</p> <pre><code># Provider enablement\ndef is_provider_enabled(provider_name: str) -&gt; bool:\n    # Check global list\n    global_enable = get_env_var(\"MLFLOW_SECRETS_AUTH_ENABLE\", \"\")\n    if provider_name.lower() in global_enable.lower().split(\",\"):\n        return True\n\n    # Check provider-specific flag\n    env_key = f\"MLFLOW_SECRETS_AUTH_ENABLE_{provider_name.upper().replace('-', '_')}\"\n    return get_env_bool(env_key, False)\n</code></pre>"},{"location":"concepts/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"concepts/architecture/#lazy-initialization","title":"Lazy Initialization","text":"<p>Providers are instantiated only when needed:</p> <pre><code>def _get_actual_provider(self) -&gt; SecretsBackedAuthProvider | None:\n    if self._actual_provider is not None:\n        return self._actual_provider\n\n    # Lazy instantiation\n    for name, provider_cls in self._PROVIDERS.items():\n        if is_provider_enabled(name):\n            try:\n                self._actual_provider = provider_cls()\n                return self._actual_provider\n            except Exception:\n                continue\n    return None\n</code></pre>"},{"location":"concepts/architecture/#connection-pooling","title":"Connection Pooling","text":"<p>Provider implementations reuse connections when possible:</p> <pre><code>class VaultAuthProvider:\n    def __init__(self):\n        self._vault_client = None  # Cached client instance\n\n    def _get_vault_client(self):\n        if self._vault_client is not None:\n            return self._vault_client\n\n        # Create and cache client\n        self._vault_client = hvac.Client(url=vault_addr)\n        return self._vault_client\n</code></pre>"},{"location":"concepts/architecture/#async-considerations","title":"Async Considerations","text":"<p>While the current implementation is synchronous, the architecture supports future async operations:</p> <pre><code># Future async support\nasync def _fetch_secret_async(self) -&gt; str | None:\n    async with self._get_async_client() as client:\n        response = await client.get_secret(self.secret_path)\n        return response.value\n</code></pre>"},{"location":"concepts/architecture/#integration-points","title":"Integration Points","text":""},{"location":"concepts/architecture/#mlflow-integration","title":"MLflow Integration","text":"<p>The plugin integrates seamlessly with MLflow's authentication system:</p> <pre><code># Entry point registration in pyproject.toml\n[tool.poetry.plugins.\"mlflow.request_auth_provider\"]\nmlflow_secrets_auth = \"mlflow_secrets_auth:SecretsAuthProviderFactory\"\n</code></pre>"},{"location":"concepts/architecture/#monitoring-integration","title":"Monitoring Integration","text":"<p>The architecture supports monitoring and observability:</p> <pre><code># Metrics collection\nclass MetricsCollector:\n    def record_cache_hit(self, provider: str):\n        self.cache_hits[provider] += 1\n\n    def record_secret_fetch_duration(self, provider: str, duration: float):\n        self.fetch_durations[provider].append(duration)\n</code></pre>"},{"location":"concepts/architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Security Concepts - Detailed security model and threat analysis</li> <li>Caching and Retries - Deep dive into caching and retry mechanisms</li> <li>Provider Documentation - Provider-specific implementation details</li> <li>Configuration Reference - Complete configuration options</li> </ul>"},{"location":"concepts/caching-and-retries/","title":"Caching and Retries","text":"<p>MLflow Secrets Auth implements sophisticated caching and retry mechanisms to optimize performance, ensure reliability, and handle transient failures gracefully.</p>"},{"location":"concepts/caching-and-retries/#caching-architecture","title":"Caching Architecture","text":""},{"location":"concepts/caching-and-retries/#overview","title":"Overview","text":"<p>The caching system provides in-memory storage of retrieved credentials with configurable TTL (Time To Live) expiration. Caching reduces latency, minimizes load on secret management systems, and improves user experience.</p>"},{"location":"concepts/caching-and-retries/#cache-implementation","title":"Cache Implementation","text":""},{"location":"concepts/caching-and-retries/#cache-structure","title":"Cache Structure","text":"<pre><code>class CacheEntry:\n    \"\"\"Represents a cached secret with expiration.\"\"\"\n\n    def __init__(self, data: dict[str, str], ttl: int):\n        self.data = data\n        self.created_at = time.time()\n        self.expiry = self.created_at + ttl\n\n    def is_expired(self) -&gt; bool:\n        \"\"\"Check if cache entry has expired.\"\"\"\n        return time.time() &gt; self.expiry\n\n    def remaining_ttl(self) -&gt; int:\n        \"\"\"Calculate remaining TTL in seconds.\"\"\"\n        return max(0, int(self.expiry - time.time()))\n\n\nclass SecretCache:\n    \"\"\"Thread-safe in-memory cache for secrets.\"\"\"\n\n    def __init__(self):\n        self._cache: dict[str, CacheEntry] = {}\n        self._lock = threading.RLock()\n\n    def get(self, key: str) -&gt; dict[str, str] | None:\n        \"\"\"Retrieve cached secret if not expired.\"\"\"\n        with self._lock:\n            entry = self._cache.get(key)\n            if entry and not entry.is_expired():\n                return entry.data\n            elif entry:\n                # Clean up expired entry\n                del self._cache[key]\n            return None\n\n    def set(self, key: str, data: dict[str, str], ttl: int) -&gt; None:\n        \"\"\"Store secret in cache with TTL.\"\"\"\n        with self._lock:\n            self._cache[key] = CacheEntry(data, ttl)\n\n    def delete(self, key: str) -&gt; None:\n        \"\"\"Remove specific cache entry.\"\"\"\n        with self._lock:\n            self._cache.pop(key, None)\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all cache entries.\"\"\"\n        with self._lock:\n            self._cache.clear()\n</code></pre>"},{"location":"concepts/caching-and-retries/#cache-key-generation","title":"Cache Key Generation","text":"<p>Cache keys are generated based on provider-specific configuration to ensure proper isolation:</p> <pre><code># Vault provider cache key\ndef _get_cache_key(self) -&gt; str:\n    vault_addr = get_env_var(\"VAULT_ADDR\", \"\")\n    secret_path = get_env_var(\"MLFLOW_VAULT_SECRET_PATH\", \"\")\n    return f\"vault:{vault_addr}:{secret_path}\"\n\n# AWS provider cache key  \ndef _get_cache_key(self) -&gt; str:\n    region = get_env_var(\"AWS_REGION\", \"\")\n    secret_name = get_env_var(\"MLFLOW_AWS_SECRET_NAME\", \"\")\n    return f\"aws:{region}:{secret_name}\"\n\n# Azure provider cache key\ndef _get_cache_key(self) -&gt; str:\n    vault_url = get_env_var(\"MLFLOW_AZURE_KEY_VAULT_URL\", \"\")\n    secret_name = get_env_var(\"MLFLOW_AZURE_SECRET_NAME\", \"\")\n    return f\"azure:{vault_url}:{secret_name}\"\n</code></pre>"},{"location":"concepts/caching-and-retries/#cache-lifecycle","title":"Cache Lifecycle","text":""},{"location":"concepts/caching-and-retries/#cache-hit-flow","title":"Cache Hit Flow","text":"<pre><code>graph TB\n    A[Request Auth] --&gt; B[Generate Cache Key]\n    B --&gt; C{Cache Hit?}\n    C --&gt;|Yes| D{Expired?}\n    C --&gt;|No| E[Cache Miss]\n    D --&gt;|No| F[Return Cached Auth]\n    D --&gt;|Yes| G[Remove Expired Entry]\n    G --&gt; E\n    E --&gt; H[Fetch from Provider]\n    H --&gt; I{Success?}\n    I --&gt;|Yes| J[Parse Secret]\n    J --&gt; K[Create Auth Object]\n    K --&gt; L[Store in Cache]\n    L --&gt; M[Return Auth]\n    I --&gt;|No| N[Return Error]</code></pre>"},{"location":"concepts/caching-and-retries/#cache-operations","title":"Cache Operations","text":"<pre><code>def _fetch_secret_cached(self) -&gt; dict[str, str] | None:\n    \"\"\"Fetch secret with caching support.\"\"\"\n    cache_key = self._get_cache_key()\n\n    # Check cache first\n    cached_secret = self._cache.get(cache_key)\n    if cached_secret is not None:\n        self.logger.debug(\"Cache hit for key: %s\", cache_key)\n        return cached_secret\n\n    # Cache miss - fetch from provider\n    self.logger.debug(\"Cache miss for key: %s\", cache_key)\n    secret_json = self._fetch_secret()\n\n    if secret_json:\n        try:\n            secret_data = json.loads(secret_json)\n            # Store in cache with configured TTL\n            self._cache.set(cache_key, secret_data, self._get_ttl())\n            return secret_data\n        except json.JSONDecodeError as e:\n            self.logger.error(\"Failed to parse secret JSON: %s\", e)\n\n    return None\n</code></pre>"},{"location":"concepts/caching-and-retries/#ttl-configuration","title":"TTL Configuration","text":""},{"location":"concepts/caching-and-retries/#per-provider-ttl-settings","title":"Per-Provider TTL Settings","text":"<p>Each provider supports independent TTL configuration:</p> <pre><code># Vault TTL (default: 300 seconds)\nMLFLOW_VAULT_TTL_SEC=300\n\n# AWS TTL (default: 300 seconds)  \nMLFLOW_AWS_TTL_SEC=600\n\n# Azure TTL (default: 300 seconds)\nMLFLOW_AZURE_TTL_SEC=900\n</code></pre>"},{"location":"concepts/caching-and-retries/#ttl-validation","title":"TTL Validation","text":"<p>TTL values are validated and clamped to reasonable ranges:</p> <pre><code>def validate_ttl(ttl: int, min_ttl: int = 60, max_ttl: int = 3600) -&gt; int:\n    \"\"\"Validate and clamp TTL to reasonable bounds.\"\"\"\n    if ttl &lt; min_ttl:\n        logger.warning(f\"TTL {ttl} too low, using minimum {min_ttl}\")\n        return min_ttl\n    if ttl &gt; max_ttl:\n        logger.warning(f\"TTL {ttl} too high, using maximum {max_ttl}\")\n        return max_ttl\n    return ttl\n</code></pre>"},{"location":"concepts/caching-and-retries/#environment-specific-ttl-recommendations","title":"Environment-Specific TTL Recommendations","text":"<pre><code># Development: Short TTL for rapid iteration\nMLFLOW_VAULT_TTL_SEC=60      # 1 minute\n\n# Staging: Medium TTL for testing\nMLFLOW_VAULT_TTL_SEC=300     # 5 minutes\n\n# Production: Longer TTL for performance\nMLFLOW_VAULT_TTL_SEC=900     # 15 minutes\n\n# High-security: Very short TTL\nMLFLOW_VAULT_TTL_SEC=30      # 30 seconds\n</code></pre>"},{"location":"concepts/caching-and-retries/#cache-busting","title":"Cache Busting","text":""},{"location":"concepts/caching-and-retries/#automatic-cache-busting","title":"Automatic Cache Busting","text":"<p>The cache automatically invalidates entries on authentication failures:</p> <pre><code>def _handle_auth_failure(self, response: requests.Response, url: str) -&gt; None:\n    \"\"\"Handle authentication failure by clearing cache.\"\"\"\n    if response.status_code in (401, 403):\n        cache_key = self._get_cache_key()\n        self._cache.delete(cache_key)\n\n        self.logger.info(\n            \"Cleared cache due to auth failure\",\n            extra={\n                \"status_code\": response.status_code,\n                \"url\": redact_sensitive_data(url),\n                \"cache_key\": cache_key\n            }\n        )\n</code></pre>"},{"location":"concepts/caching-and-retries/#manual-cache-operations","title":"Manual Cache Operations","text":"<p>Future CLI support for manual cache management:</p> <pre><code># Clear all cached secrets\nmlflow-secrets-auth cache clear\n\n# Clear specific provider cache\nmlflow-secrets-auth cache clear --provider vault\n\n# Show cache status\nmlflow-secrets-auth cache status\n</code></pre>"},{"location":"concepts/caching-and-retries/#cache-security","title":"Cache Security","text":""},{"location":"concepts/caching-and-retries/#memory-only-storage","title":"Memory-Only Storage","text":"<ul> <li>No Disk Persistence: Cache exists only in memory</li> <li>Process Isolation: Cache cleared on process termination</li> <li>Secure Cleanup: Automatic cleanup of expired entries</li> </ul>"},{"location":"concepts/caching-and-retries/#cache-isolation","title":"Cache Isolation","text":"<pre><code># Different configurations use different cache keys\n# Production Vault\ncache_key_prod = \"vault:https://vault.prod.com:secret/mlflow/prod\"\n\n# Staging Vault  \ncache_key_staging = \"vault:https://vault.staging.com:secret/mlflow/staging\"\n\n# These are isolated in separate cache entries\n</code></pre>"},{"location":"concepts/caching-and-retries/#thread-safety","title":"Thread Safety","text":"<pre><code>class ThreadSafeCache:\n    \"\"\"Thread-safe cache implementation.\"\"\"\n\n    def __init__(self):\n        self._cache = {}\n        self._lock = threading.RLock()  # Reentrant lock\n\n    def get(self, key: str):\n        with self._lock:\n            return self._cache.get(key)\n\n    def set(self, key: str, value, ttl: int):\n        with self._lock:\n            self._cache[key] = CacheEntry(value, ttl)\n</code></pre>"},{"location":"concepts/caching-and-retries/#retry-mechanisms","title":"Retry Mechanisms","text":""},{"location":"concepts/caching-and-retries/#retry-strategy","title":"Retry Strategy","text":"<p>The plugin implements exponential backoff with jitter to handle transient failures gracefully.</p>"},{"location":"concepts/caching-and-retries/#retry-implementation","title":"Retry Implementation","text":"<pre><code>def retry_with_jitter(\n    func: Callable[[], T], \n    max_retries: int = 3,\n    base_delay: float = 1.0,\n    max_delay: float = 30.0,\n    backoff_factor: float = 2.0,\n    jitter_factor: float = 0.1\n) -&gt; T:\n    \"\"\"Execute function with exponential backoff and jitter.\"\"\"\n\n    for attempt in range(max_retries + 1):\n        try:\n            return func()\n        except Exception as e:\n            if attempt == max_retries:\n                # Final attempt failed\n                raise e\n\n            # Calculate delay with exponential backoff\n            delay = min(base_delay * (backoff_factor ** attempt), max_delay)\n\n            # Add jitter to prevent thundering herd\n            jitter = random.uniform(0, delay * jitter_factor)\n            total_delay = delay + jitter\n\n            logger.debug(\n                f\"Attempt {attempt + 1} failed, retrying in {total_delay:.2f}s\",\n                extra={\"error\": str(e), \"attempt\": attempt + 1}\n            )\n\n            time.sleep(total_delay)\n\n    raise RuntimeError(\"Retry logic error\")  # Should never reach here\n</code></pre>"},{"location":"concepts/caching-and-retries/#retry-configuration","title":"Retry Configuration","text":"<pre><code># Default retry settings\nDEFAULT_RETRY_CONFIG = {\n    \"max_retries\": 3,\n    \"base_delay\": 1.0,      # 1 second\n    \"max_delay\": 30.0,      # 30 seconds maximum\n    \"backoff_factor\": 2.0,  # Double delay each attempt\n    \"jitter_factor\": 0.1    # 10% jitter\n}\n\n# Environment variable overrides\ndef get_retry_config() -&gt; dict:\n    return {\n        \"max_retries\": get_env_int(\"MLFLOW_SECRETS_MAX_RETRIES\", 3),\n        \"base_delay\": get_env_float(\"MLFLOW_SECRETS_BASE_DELAY\", 1.0),\n        \"max_delay\": get_env_float(\"MLFLOW_SECRETS_MAX_DELAY\", 30.0),\n    }\n</code></pre>"},{"location":"concepts/caching-and-retries/#retry-examples","title":"Retry Examples","text":"<p>Timing Examples: <pre><code>Attempt 1: Immediate\nAttempt 2: 1.0s + jitter (0.0-0.1s) = ~1.05s\nAttempt 3: 2.0s + jitter (0.0-0.2s) = ~2.15s  \nAttempt 4: 4.0s + jitter (0.0-0.4s) = ~4.25s\n</code></pre></p>"},{"location":"concepts/caching-and-retries/#retryable-conditions","title":"Retryable Conditions","text":""},{"location":"concepts/caching-and-retries/#network-errors","title":"Network Errors","text":"<pre><code>RETRYABLE_EXCEPTIONS = (\n    requests.exceptions.ConnectionError,\n    requests.exceptions.Timeout,\n    requests.exceptions.HTTPError,  # 5xx only\n    socket.timeout,\n    socket.gaierror,\n)\n\ndef is_retryable_error(exception: Exception) -&gt; bool:\n    \"\"\"Determine if error is worth retrying.\"\"\"\n    if isinstance(exception, requests.exceptions.HTTPError):\n        # Only retry server errors (5xx), not client errors (4xx)\n        return 500 &lt;= exception.response.status_code &lt; 600\n\n    return isinstance(exception, RETRYABLE_EXCEPTIONS)\n</code></pre>"},{"location":"concepts/caching-and-retries/#provider-specific-retry-logic","title":"Provider-Specific Retry Logic","text":"<p>Vault Retries: <pre><code>def _fetch_secret(self) -&gt; str | None:\n    \"\"\"Fetch secret with Vault-specific retry logic.\"\"\"\n\n    def _vault_fetch():\n        client = self._get_vault_client()\n        if not client or not client.is_authenticated():\n            raise VaultAuthenticationError(\"Vault not authenticated\")\n\n        # Try KV v2 first, then v1\n        try:\n            response = client.secrets.kv.v2.read_secret_version(path=path)\n            return json.dumps(response[\"data\"][\"data\"])\n        except hvac.exceptions.InvalidPath:\n            # Fallback to KV v1\n            response = client.secrets.kv.v1.read_secret(path=path)\n            return json.dumps(response[\"data\"])\n\n    return retry_with_jitter(_vault_fetch)\n</code></pre></p> <p>AWS Retries: <pre><code>def _fetch_secret(self) -&gt; str | None:\n    \"\"\"Fetch secret with AWS-specific retry logic.\"\"\"\n\n    def _aws_fetch():\n        client = self._get_secrets_client()\n        response = client.get_secret_value(SecretId=self.secret_name)\n\n        # Handle both SecretString and SecretBinary\n        if 'SecretString' in response:\n            return response['SecretString']\n        else:\n            # Convert binary to base64 string\n            import base64\n            binary_data = response['SecretBinary']\n            return base64.b64encode(binary_data).decode('utf-8')\n\n    return retry_with_jitter(_aws_fetch)\n</code></pre></p>"},{"location":"concepts/caching-and-retries/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<p>For production resilience, implement circuit breaker pattern:</p> <pre><code>class CircuitBreaker:\n    \"\"\"Circuit breaker for provider calls.\"\"\"\n\n    def __init__(self, failure_threshold: int = 5, timeout: int = 60):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.failure_count = 0\n        self.last_failure_time = None\n        self.state = \"CLOSED\"  # CLOSED, OPEN, HALF_OPEN\n\n    def call(self, func: Callable) -&gt; Any:\n        \"\"\"Execute function with circuit breaker protection.\"\"\"\n        if self.state == \"OPEN\":\n            if time.time() - self.last_failure_time &lt; self.timeout:\n                raise CircuitBreakerOpenError(\"Circuit breaker is open\")\n            else:\n                self.state = \"HALF_OPEN\"\n\n        try:\n            result = func()\n            # Success resets the circuit breaker\n            if self.state == \"HALF_OPEN\":\n                self.state = \"CLOSED\"\n                self.failure_count = 0\n            return result\n\n        except Exception as e:\n            self.failure_count += 1\n            self.last_failure_time = time.time()\n\n            if self.failure_count &gt;= self.failure_threshold:\n                self.state = \"OPEN\"\n\n            raise e\n</code></pre>"},{"location":"concepts/caching-and-retries/#performance-optimization","title":"Performance Optimization","text":""},{"location":"concepts/caching-and-retries/#cache-hit-optimization","title":"Cache Hit Optimization","text":""},{"location":"concepts/caching-and-retries/#metrics-collection","title":"Metrics Collection","text":"<pre><code>class CacheMetrics:\n    \"\"\"Collect cache performance metrics.\"\"\"\n\n    def __init__(self):\n        self.hits = 0\n        self.misses = 0\n        self.total_requests = 0\n\n    def record_hit(self):\n        self.hits += 1\n        self.total_requests += 1\n\n    def record_miss(self):\n        self.misses += 1\n        self.total_requests += 1\n\n    def hit_rate(self) -&gt; float:\n        if self.total_requests == 0:\n            return 0.0\n        return self.hits / self.total_requests\n\n    def stats(self) -&gt; dict:\n        return {\n            \"hits\": self.hits,\n            \"misses\": self.misses,\n            \"total_requests\": self.total_requests,\n            \"hit_rate\": self.hit_rate()\n        }\n</code></pre>"},{"location":"concepts/caching-and-retries/#cache-warming","title":"Cache Warming","text":"<p>For high-performance scenarios, implement cache warming:</p> <pre><code>def warm_cache(self) -&gt; None:\n    \"\"\"Pre-populate cache with secrets.\"\"\"\n    try:\n        # Fetch secret to populate cache\n        self._fetch_secret_cached()\n        logger.info(\"Cache warmed successfully\")\n    except Exception as e:\n        logger.warning(f\"Cache warming failed: {e}\")\n</code></pre>"},{"location":"concepts/caching-and-retries/#connection-pooling","title":"Connection Pooling","text":""},{"location":"concepts/caching-and-retries/#provider-connection-reuse","title":"Provider Connection Reuse","text":"<pre><code>class VaultAuthProvider:\n    \"\"\"Vault provider with connection pooling.\"\"\"\n\n    def __init__(self):\n        super().__init__(\"vault\", default_ttl=300)\n        self._vault_client = None\n        self._client_lock = threading.Lock()\n\n    def _get_vault_client(self):\n        \"\"\"Get or create Vault client with connection reuse.\"\"\"\n        if self._vault_client is not None:\n            # Verify client is still authenticated\n            try:\n                if self._vault_client.is_authenticated():\n                    return self._vault_client\n            except Exception:\n                pass  # Client no longer valid\n\n        with self._client_lock:\n            # Double-check pattern\n            if self._vault_client is None or not self._vault_client.is_authenticated():\n                self._vault_client = self._create_vault_client()\n\n        return self._vault_client\n</code></pre>"},{"location":"concepts/caching-and-retries/#async-considerations","title":"Async Considerations","text":"<p>While the current implementation is synchronous, the architecture supports future async operations:</p> <pre><code># Future async implementation\nclass AsyncSecretsBackedAuthProvider:\n    \"\"\"Async version of secrets auth provider.\"\"\"\n\n    async def get_request_auth_async(self, url: str) -&gt; requests.auth.AuthBase | None:\n        \"\"\"Async version of get_request_auth.\"\"\"\n        if not self._is_enabled():\n            return None\n\n        if not self._is_host_allowed(url):\n            return None\n\n        secret_data = await self._fetch_secret_cached_async()\n        if not secret_data:\n            return None\n\n        return self._create_auth(secret_data)\n\n    async def _fetch_secret_cached_async(self) -&gt; dict[str, str] | None:\n        \"\"\"Async version with cache support.\"\"\"\n        # Implementation would use async cache and HTTP clients\n        pass\n</code></pre>"},{"location":"concepts/caching-and-retries/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"concepts/caching-and-retries/#cache-configuration","title":"Cache Configuration","text":"<pre><code># High-performance environment\nMLFLOW_VAULT_TTL_SEC=1800      # 30 minutes\nMLFLOW_SECRETS_MAX_RETRIES=5   # More retries\n\n# High-security environment  \nMLFLOW_VAULT_TTL_SEC=60        # 1 minute\nMLFLOW_SECRETS_MAX_RETRIES=2   # Fewer retries\n\n# Development environment\nMLFLOW_VAULT_TTL_SEC=300       # 5 minutes\nMLFLOW_SECRETS_MAX_RETRIES=3   # Standard retries\n</code></pre>"},{"location":"concepts/caching-and-retries/#monitoring-configuration","title":"Monitoring Configuration","text":"<pre><code># Enable detailed logging for performance monitoring\nMLFLOW_SECRETS_LOG_LEVEL=DEBUG\n\n# Monitor cache performance\n# (Future feature: metrics endpoint)\n</code></pre>"},{"location":"concepts/caching-and-retries/#troubleshooting-performance","title":"Troubleshooting Performance","text":""},{"location":"concepts/caching-and-retries/#cache-issues","title":"Cache Issues","text":"<pre><code># Check cache status\nmlflow-secrets-auth info  # Shows cache hit rate\n\n# Clear cache if stale\nmlflow-secrets-auth cache clear\n\n# Test with cache disabled (future feature)\nMLFLOW_SECRETS_CACHE_DISABLED=true mlflow-secrets-auth doctor\n</code></pre>"},{"location":"concepts/caching-and-retries/#retry-issues","title":"Retry Issues","text":"<pre><code># Reduce retries for faster failures\nMLFLOW_SECRETS_MAX_RETRIES=1\n\n# Increase retries for resilience\nMLFLOW_SECRETS_MAX_RETRIES=5\n\n# Debug retry behavior\nMLFLOW_SECRETS_LOG_LEVEL=DEBUG mlflow-secrets-auth doctor\n</code></pre>"},{"location":"concepts/caching-and-retries/#network-performance","title":"Network Performance","text":"<pre><code># Test network connectivity\nmlflow-secrets-auth doctor --dry-run https://your-server.com\n\n# Monitor secret fetch latency\n# (Logged at DEBUG level)\n</code></pre>"},{"location":"concepts/caching-and-retries/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture - Overall system design and flow</li> <li>Security - Security model and threat mitigation</li> <li>Provider Documentation - Provider-specific performance considerations</li> <li>Troubleshooting - Performance troubleshooting guide</li> </ul>"},{"location":"concepts/security/","title":"Security","text":"<p>MLflow Secrets Auth implements a comprehensive security model designed to protect credentials and prevent unauthorized access while maintaining usability and performance.</p>"},{"location":"concepts/security/#threat-model","title":"Threat Model","text":""},{"location":"concepts/security/#assets","title":"Assets","text":"<p>Primary Assets: - Authentication credentials (tokens, passwords, API keys) - Secret management system access - MLflow server access - Application configuration</p> <p>Secondary Assets: - Network communications - Cache contents - Log data - System configuration</p>"},{"location":"concepts/security/#threats","title":"Threats","text":""},{"location":"concepts/security/#credential-exposure","title":"Credential Exposure","text":"<p>T1: Credential Leakage - Description: Credentials sent to unauthorized servers - Impact: Unauthorized access to MLflow servers - Mitigation: Host allowlisting, URL validation</p> <p>T2: Log Exposure - Description: Credentials visible in application logs - Impact: Credential compromise through log access - Mitigation: Automatic credential redaction</p> <p>T3: Memory Dumps - Description: Credentials visible in process memory dumps - Impact: Credential extraction from memory - Mitigation: Secure memory handling, limited credential lifetime</p>"},{"location":"concepts/security/#network-attacks","title":"Network Attacks","text":"<p>T4: Man-in-the-Middle - Description: Interception of credential transmission - Impact: Credential theft during network transit - Mitigation: TLS enforcement, certificate validation</p> <p>T5: DNS Poisoning - Description: Redirection to malicious servers - Impact: Credentials sent to attacker-controlled servers - Mitigation: Host allowlisting with exact hostnames</p>"},{"location":"concepts/security/#configuration-attacks","title":"Configuration Attacks","text":"<p>T6: Environment Variable Exposure - Description: Exposure of configuration through environment variables - Impact: Access to secret paths and authentication parameters - Mitigation: Principle of least privilege, secure configuration management</p> <p>T7: Cache Poisoning - Description: Injection of malicious credentials into cache - Impact: Use of compromised credentials - Mitigation: Cache integrity validation, TTL limits</p>"},{"location":"concepts/security/#security-controls","title":"Security Controls","text":""},{"location":"concepts/security/#host-allowlisting","title":"Host Allowlisting","text":"<p>Host allowlisting is the primary defense against credential leakage to unauthorized servers.</p>"},{"location":"concepts/security/#implementation","title":"Implementation","text":"<pre><code>def _is_host_allowed(self, hostname: str) -&gt; bool:\n    \"\"\"Validate hostname against allowlist patterns.\"\"\"\n    allowed_hosts = get_allowed_hosts()\n    if not allowed_hosts:\n        return True  # No restrictions if not configured\n\n    return any(\n        fnmatch.fnmatch(hostname, pattern)\n        for pattern in allowed_hosts\n    )\n</code></pre>"},{"location":"concepts/security/#configuration-patterns","title":"Configuration Patterns","text":"<p>Exact Hostnames: <pre><code>MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com,mlflow-staging.company.com\"\n</code></pre></p> <p>Wildcard Patterns: <pre><code># Subdomain wildcards\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"*.company.com\"\n\n# Prefix wildcards  \nMLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow-*\"\n\n# Complex patterns\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"*.prod.company.com,*.staging.company.com,localhost\"\n</code></pre></p>"},{"location":"concepts/security/#security-considerations","title":"Security Considerations","text":"<ul> <li>Default Behavior: If not configured, allows all hosts (development-friendly but insecure)</li> <li>Wildcard Risks: Overly broad patterns can allow unintended hosts</li> <li>Pattern Validation: Patterns are validated using shell-style globbing</li> <li>Case Sensitivity: Hostname matching is case-insensitive</li> </ul>"},{"location":"concepts/security/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always Enable in Production:    <pre><code>MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com\"\n</code></pre></p> </li> <li> <p>Use Specific Patterns:    <pre><code># Good: Specific subdomain\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"*.mlflow.company.com\"\n\n# Avoid: Too broad\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"*.com\"\n</code></pre></p> </li> <li> <p>Environment-Specific Configuration:    <pre><code># Development\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"localhost,127.0.0.1,*.local\"\n\n# Staging\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"*.staging.company.com\"\n\n# Production\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com\"\n</code></pre></p> </li> </ol>"},{"location":"concepts/security/#credential-redaction","title":"Credential Redaction","text":"<p>All sensitive data is automatically redacted from logs and error messages to prevent accidental exposure.</p>"},{"location":"concepts/security/#redaction-patterns","title":"Redaction Patterns","text":"<p>The system recognizes and redacts common credential patterns:</p> <pre><code>_REDACT_PATTERNS = [\n    # Bearer tokens: \"Bearer &lt;token&gt;\"\n    re.compile(r\"(Bearer\\s+)([A-Za-z0-9._\\-]+)\"),\n\n    # Basic auth: \"Basic &lt;b64&gt;\"\n    re.compile(r\"(Basic\\s+)([A-Za-z0-9+/=]+)\"),\n\n    # JWT tokens\n    re.compile(r\"(eyJ[A-Za-z0-9._\\-]+\\.[A-Za-z0-9._\\-]+\\.[A-Za-z0-9._\\-]+)\"),\n\n    # JSON fields: \"token\" / \"password\" / \"secret\" / \"key\"\n    re.compile(r'(\"(?:token|password|secret|key)\"\\s*:\\s*\")([^\"]+)(\")'),\n\n    # URL credentials: https://user:pass@host\n    re.compile(r\"(https?://[^:]+:)([^@]+)(@)\"),\n]\n</code></pre>"},{"location":"concepts/security/#masking-strategy","title":"Masking Strategy","text":"<p>Sensitive values are masked while preserving context:</p> <pre><code>def mask_secret(value: str, mask_char: str = \"*\", show_chars: int = 4) -&gt; str:\n    \"\"\"Mask secret while showing prefix/suffix for debugging.\"\"\"\n    if len(value) &lt;= show_chars * 2:\n        return mask_char * max(3, len(value))\n\n    return f\"{value[:show_chars]}{mask_char * 8}{value[-show_chars:]}\"\n\n# Example output: \"abcd********1234\"\n</code></pre>"},{"location":"concepts/security/#log-output-examples","title":"Log Output Examples","text":"<p>Before Redaction: <pre><code>Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\nSecret data: {\"token\": \"abc123def456\", \"password\": \"secret123\"}\n</code></pre></p> <p>After Redaction: <pre><code>Authorization: Bearer eyJh********cCI6\nSecret data: {\"token\": \"abc1********def4\", \"password\": \"secr********123\"}\n</code></pre></p>"},{"location":"concepts/security/#secure-caching","title":"Secure Caching","text":"<p>The caching layer implements security measures to protect cached credentials.</p>"},{"location":"concepts/security/#cache-security-features","title":"Cache Security Features","text":"<p>In-Memory Only: - No persistence to disk or external storage - Automatic cleanup on process termination - Memory-only storage prevents credential recovery</p> <p>TTL Enforcement: <pre><code>class CacheEntry:\n    def __init__(self, data: dict, ttl: int):\n        self.data = data\n        self.expiry = time.time() + ttl\n\n    def is_expired(self) -&gt; bool:\n        return time.time() &gt; self.expiry\n</code></pre></p> <p>Cache Isolation: - Per-configuration cache keys prevent cross-contamination - Different providers maintain separate cache spaces - Cache keys include provider-specific identifiers</p> <p>Automatic Cache Busting: <pre><code>def _handle_auth_failure(self, response: requests.Response):\n    \"\"\"Clear cache on authentication failure.\"\"\"\n    if response.status_code in (401, 403):\n        cache_key = self._get_cache_key()\n        self._cache.delete(cache_key)\n        logger.info(\"Cache cleared due to authentication failure\")\n</code></pre></p>"},{"location":"concepts/security/#cache-security-best-practices","title":"Cache Security Best Practices","text":"<ol> <li> <p>Appropriate TTL Values:    <pre><code># Short TTL for high-security environments\nMLFLOW_VAULT_TTL_SEC=300  # 5 minutes\n\n# Longer TTL for development\nMLFLOW_VAULT_TTL_SEC=3600  # 1 hour\n</code></pre></p> </li> <li> <p>Regular Cache Rotation:    <pre><code># Automatic rotation based on TTL\n# Manual rotation via cache busting on failures\n</code></pre></p> </li> <li> <p>Memory Protection:</p> </li> <li>Use memory-mapped regions when available</li> <li>Implement secure memory wiping (platform-dependent)</li> <li>Limit cache size to prevent memory exhaustion</li> </ol>"},{"location":"concepts/security/#network-security","title":"Network Security","text":""},{"location":"concepts/security/#tls-enforcement","title":"TLS Enforcement","text":"<p>All communications with secret management systems use TLS by default:</p> <pre><code># Vault\nVAULT_ADDR=\"https://vault.company.com\"  # HTTPS required\n\n# AWS\n# TLS enforced by boto3 by default\n\n# Azure  \n# TLS enforced by Azure SDK by default\n</code></pre>"},{"location":"concepts/security/#certificate-validation","title":"Certificate Validation","text":"<p>Certificate validation is enabled by default with options for testing:</p> <pre><code># Production: Always validate certificates\nVAULT_SKIP_VERIFY=false\n\n# Development: May skip validation (NOT recommended)\nVAULT_SKIP_VERIFY=true\n</code></pre>"},{"location":"concepts/security/#network-timeouts","title":"Network Timeouts","text":"<p>Reasonable timeouts prevent hanging connections:</p> <pre><code># Default timeouts\nNETWORK_TIMEOUT = 30  # seconds\nCONNECT_TIMEOUT = 10  # seconds\nREAD_TIMEOUT = 20     # seconds\n</code></pre>"},{"location":"concepts/security/#authentication-security","title":"Authentication Security","text":""},{"location":"concepts/security/#provider-specific-security","title":"Provider-Specific Security","text":"<p>HashiCorp Vault: - Token-based authentication with expiration - AppRole authentication for automation - Policy-based access control - Audit logging support</p> <pre><code># Vault policy example\npath \"secret/data/mlflow/*\" {\n  capabilities = [\"read\"]\n}\n</code></pre> <p>AWS Secrets Manager: - IAM-based access control - Cross-account access via roles - Resource-based policies - CloudTrail audit logging</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Action\": [\"secretsmanager:GetSecretValue\"],\n    \"Resource\": \"arn:aws:secretsmanager:region:account:secret:mlflow/*\"\n  }]\n}\n</code></pre> <p>Azure Key Vault: - Azure AD authentication - Managed identity support - Role-based access control (RBAC) - Activity logging support</p> <pre><code># Key Vault access policy\naz keyvault set-policy \\\n  --name vault-name \\\n  --object-id user-id \\\n  --secret-permissions get\n</code></pre>"},{"location":"concepts/security/#credential-rotation","title":"Credential Rotation","text":"<p>The plugin supports credential rotation through cache invalidation:</p> <ol> <li>Automatic Detection: Authentication failures trigger cache clearing</li> <li>Manual Rotation: CLI commands can clear cache</li> <li>TTL-Based Rotation: Regular cache expiration forces re-fetch</li> </ol> <pre><code># Manual cache clearing (future feature)\nmlflow-secrets-auth cache clear\n\n# TTL-based rotation\nMLFLOW_VAULT_TTL_SEC=300  # Rotate every 5 minutes\n</code></pre>"},{"location":"concepts/security/#principle-of-least-privilege","title":"Principle of Least Privilege","text":""},{"location":"concepts/security/#iam-permissions","title":"IAM Permissions","text":"<p>Vault Example: <pre><code># Minimal Vault policy\npath \"secret/data/mlflow/auth\" {\n  capabilities = [\"read\"]\n}\n</code></pre></p> <p>AWS Example: <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Action\": [\"secretsmanager:GetSecretValue\"],\n    \"Resource\": [\"arn:aws:secretsmanager:us-east-1:123456789012:secret:mlflow/auth-*\"],\n    \"Condition\": {\n      \"StringEquals\": {\n        \"secretsmanager:ResourceTag/Environment\": \"production\"\n      }\n    }\n  }]\n}\n</code></pre></p> <p>Azure Example: <pre><code># Custom role with minimal permissions\naz role definition create --role-definition '{\n  \"Name\": \"MLflow Secrets Reader\",\n  \"Description\": \"Read MLflow secrets only\",\n  \"Actions\": [],\n  \"DataActions\": [\n    \"Microsoft.KeyVault/vaults/secrets/getSecret/action\"\n  ],\n  \"AssignableScopes\": [\"/subscriptions/{subscription-id}\"]\n}'\n</code></pre></p>"},{"location":"concepts/security/#network-restrictions","title":"Network Restrictions","text":"<ol> <li>VPC/VNet Restrictions: Limit access to secret managers from specific networks</li> <li>IP Allowlisting: Configure secret managers to allow specific IP ranges</li> <li>Private Endpoints: Use private connectivity when available</li> </ol>"},{"location":"concepts/security/#security-monitoring","title":"Security Monitoring","text":""},{"location":"concepts/security/#audit-logging","title":"Audit Logging","text":"<p>Enable audit logging on secret management systems:</p> <p>Vault: <pre><code>vault audit enable file file_path=/vault/logs/audit.log\n</code></pre></p> <p>AWS: <pre><code># CloudTrail automatically logs Secrets Manager access\n</code></pre></p> <p>Azure: <pre><code># Activity logs automatically capture Key Vault access\n</code></pre></p>"},{"location":"concepts/security/#application-logging","title":"Application Logging","text":"<p>The plugin provides security-relevant logging:</p> <pre><code># Security events logged:\n# - Authentication attempts\n# - Host allowlist violations  \n# - Cache operations\n# - Configuration changes\n# - Error conditions\n\nlogger.warning(\"Host not allowed: %s\", hostname)\nlogger.info(\"Secret fetched successfully\", extra={\"provider\": \"vault\"})\nlogger.error(\"Authentication failed\", extra={\"provider\": \"aws\", \"error_code\": 403})\n</code></pre>"},{"location":"concepts/security/#monitoring-recommendations","title":"Monitoring Recommendations","text":"<ol> <li>Failed Authentication Attempts: Monitor for repeated failures</li> <li>Unusual Access Patterns: Alert on access from unexpected sources</li> <li>Configuration Changes: Track environment variable modifications</li> <li>Performance Anomalies: Monitor secret fetch latency</li> </ol>"},{"location":"concepts/security/#security-testing","title":"Security Testing","text":""},{"location":"concepts/security/#security-validation","title":"Security Validation","text":"<pre><code># Test host allowlisting\nMLFLOW_SECRETS_ALLOWED_HOSTS=\"trusted.com\" \\\nmlflow-secrets-auth doctor --dry-run https://untrusted.com\n\n# Test credential redaction\nMLFLOW_SECRETS_LOG_LEVEL=DEBUG mlflow-secrets-auth doctor\n\n# Test authentication failure handling\n# (Requires invalid credentials)\n</code></pre>"},{"location":"concepts/security/#penetration-testing-considerations","title":"Penetration Testing Considerations","text":"<ol> <li>Network Segmentation: Test network-level restrictions</li> <li>Credential Validation: Verify credential requirements</li> <li>Host Validation: Test allowlist bypass attempts</li> <li>Cache Security: Verify cache isolation and cleanup</li> </ol>"},{"location":"concepts/security/#security-compliance","title":"Security Compliance","text":""},{"location":"concepts/security/#standards-alignment","title":"Standards Alignment","text":"<p>The plugin design aligns with common security standards:</p> <ul> <li>NIST Cybersecurity Framework: Identify, Protect, Detect, Respond, Recover</li> <li>OWASP Top 10: Addresses authentication and sensitive data exposure</li> <li>SOC 2 Type II: Supports security and availability controls</li> <li>ISO 27001: Implements information security management controls</li> </ul>"},{"location":"concepts/security/#compliance-features","title":"Compliance Features","text":"<ol> <li>Data Classification: Treats all credentials as sensitive data</li> <li>Access Controls: Implements role-based access through secret managers</li> <li>Audit Trails: Provides comprehensive logging for compliance reporting</li> <li>Encryption: Uses TLS for data in transit, relies on secret managers for data at rest</li> </ol>"},{"location":"concepts/security/#security-best-practices","title":"Security Best Practices","text":""},{"location":"concepts/security/#deployment-security","title":"Deployment Security","text":"<ol> <li> <p>Environment Isolation:    <pre><code># Separate credentials per environment\n# Development\nMLFLOW_VAULT_SECRET_PATH=\"secret/dev/mlflow\"\n\n# Production  \nMLFLOW_VAULT_SECRET_PATH=\"secret/prod/mlflow\"\n</code></pre></p> </li> <li> <p>Credential Rotation:    <pre><code># Regular rotation schedule\n# Monitor expiration dates\n# Automate rotation where possible\n</code></pre></p> </li> <li> <p>Network Security:    <pre><code># Use private networks\n# Implement network segmentation\n# Enable TLS everywhere\n</code></pre></p> </li> <li> <p>Monitoring and Alerting:    <pre><code># Monitor authentication failures\n# Alert on unusual access patterns\n# Track configuration changes\n</code></pre></p> </li> </ol>"},{"location":"concepts/security/#development-security","title":"Development Security","text":"<ol> <li>Secure Defaults: Plugin defaults to secure configurations</li> <li>Developer Training: Educate developers on security implications</li> <li>Code Review: Include security review in development process</li> <li>Testing: Include security testing in CI/CD pipelines</li> </ol>"},{"location":"concepts/security/#operational-security","title":"Operational Security","text":"<ol> <li>Regular Updates: Keep plugin and dependencies updated</li> <li>Vulnerability Scanning: Scan for known vulnerabilities</li> <li>Incident Response: Have procedures for credential compromise</li> <li>Backup and Recovery: Maintain secure backup procedures</li> </ol>"},{"location":"concepts/security/#next-steps","title":"Next Steps","text":"<ul> <li>Caching and Retries - Performance and reliability mechanisms</li> <li>Architecture - Overall system design and components</li> <li>Provider Documentation - Provider-specific security considerations</li> <li>Troubleshooting - Security-related troubleshooting</li> </ul>"},{"location":"providers/aws/","title":"AWS Secrets Manager Provider","text":"<p>The AWS Secrets Manager provider enables MLflow Secrets Auth to retrieve credentials from Amazon Web Services Secrets Manager using IAM authentication. It supports multiple AWS authentication methods and handles both SecretString and SecretBinary secret types.</p>"},{"location":"providers/aws/#overview","title":"Overview","text":"<p>AWS Secrets Manager is a fully managed service that helps protect secrets needed to access applications, services, and IT resources. The MLflow Secrets Auth AWS provider integrates with AWS IAM for authentication and supports various AWS deployment patterns.</p>"},{"location":"providers/aws/#features","title":"Features","text":"<ul> <li>Multiple Authentication Methods: IAM users, roles, instance profiles, and AssumeRole</li> <li>Secret Type Support: SecretString and SecretBinary handling</li> <li>Version Management: Support for specific secret versions and staging labels</li> <li>Multi-Region Support: Cross-region secret access</li> <li>AWS Integration: Native integration with AWS services and deployment patterns</li> <li>Automatic Retries: Built-in retry logic with AWS SDK retry configurations</li> </ul>"},{"location":"providers/aws/#requirements","title":"Requirements","text":"<ul> <li>AWS Account: Valid AWS account with Secrets Manager access</li> <li>IAM Permissions: Appropriate IAM permissions for secret access</li> <li>Network Access: Connectivity to AWS Secrets Manager endpoints</li> <li>Python Package: <code>boto3&gt;=1.40.11</code> (installed with <code>pip install mlflow-secrets-auth[aws]</code>)</li> <li>AWS Credentials: Valid AWS credentials via any supported method</li> </ul>"},{"location":"providers/aws/#installation","title":"Installation","text":""},{"location":"providers/aws/#basic-installation","title":"Basic Installation","text":"<pre><code>pip install mlflow-secrets-auth[aws]\n</code></pre>"},{"location":"providers/aws/#verify-installation","title":"Verify Installation","text":"<pre><code>python -c \"import boto3; print('\u2713 AWS support available')\"\n</code></pre>"},{"location":"providers/aws/#authentication-methods","title":"Authentication Methods","text":""},{"location":"providers/aws/#iam-user-credentials","title":"IAM User Credentials","text":"<p>Use long-term IAM user credentials with access keys.</p>"},{"location":"providers/aws/#configuration","title":"Configuration","text":"<pre><code>export AWS_REGION=\"us-east-1\"\nexport AWS_ACCESS_KEY_ID=\"AKIAXXXXXXXXXXXXXXXX\"\nexport AWS_SECRET_ACCESS_KEY=\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\nexport MLFLOW_AWS_SECRET_NAME=\"mlflow/auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"aws-secrets-manager\"\n</code></pre>"},{"location":"providers/aws/#iam-user-setup","title":"IAM User Setup","text":"<ol> <li> <p>Create IAM User:    <pre><code>aws iam create-user --user-name mlflow-secrets-auth\n</code></pre></p> </li> <li> <p>Attach Policy:    <pre><code>aws iam attach-user-policy \\\n  --user-name mlflow-secrets-auth \\\n  --policy-arn arn:aws:iam::123456789012:policy/MLflowSecretsManagerRead\n</code></pre></p> </li> <li> <p>Create Access Keys:    <pre><code>aws iam create-access-key --user-name mlflow-secrets-auth\n</code></pre></p> </li> </ol>"},{"location":"providers/aws/#iam-role-recommended","title":"IAM Role (Recommended)","text":"<p>Use IAM roles for enhanced security and temporary credentials.</p>"},{"location":"providers/aws/#ec2-instance-profile","title":"EC2 Instance Profile","text":"<p>For applications running on EC2 instances:</p> <pre><code>export AWS_REGION=\"us-east-1\"\nexport MLFLOW_AWS_SECRET_NAME=\"mlflow/auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"aws-secrets-manager\"\n# AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY not needed\n</code></pre>"},{"location":"providers/aws/#ecs-task-role","title":"ECS Task Role","text":"<p>For applications running in ECS:</p> <pre><code>{\n  \"family\": \"mlflow-app\",\n  \"taskRoleArn\": \"arn:aws:iam::123456789012:role/MLflowTaskRole\",\n  \"containerDefinitions\": [{\n    \"name\": \"mlflow-app\",\n    \"environment\": [\n      {\"name\": \"AWS_REGION\", \"value\": \"us-east-1\"},\n      {\"name\": \"MLFLOW_AWS_SECRET_NAME\", \"value\": \"mlflow/auth\"},\n      {\"name\": \"MLFLOW_SECRETS_AUTH_ENABLE\", \"value\": \"aws-secrets-manager\"}\n    ]\n  }]\n}\n</code></pre>"},{"location":"providers/aws/#lambda-function-role","title":"Lambda Function Role","text":"<p>For applications running in AWS Lambda:</p> <pre><code># Environment variables set in Lambda configuration\nAWS_REGION=us-east-1\nMLFLOW_AWS_SECRET_NAME=mlflow/auth\nMLFLOW_SECRETS_AUTH_ENABLE=aws-secrets-manager\n</code></pre>"},{"location":"providers/aws/#assumerole","title":"AssumeRole","text":"<p>Use AssumeRole for cross-account access or enhanced security.</p>"},{"location":"providers/aws/#configuration_1","title":"Configuration","text":"<pre><code>export AWS_REGION=\"us-east-1\"\nexport AWS_ROLE_ARN=\"arn:aws:iam::123456789012:role/MLflowSecretsRole\"\nexport AWS_ROLE_SESSION_NAME=\"mlflow-secrets-session\"\nexport MLFLOW_AWS_SECRET_NAME=\"mlflow/auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"aws-secrets-manager\"\n</code></pre>"},{"location":"providers/aws/#cross-account-access","title":"Cross-Account Access","text":"<pre><code># Cross-account role assumption\nexport AWS_ROLE_ARN=\"arn:aws:iam::ANOTHER-ACCOUNT:role/MLflowSecretsRole\"\nexport AWS_EXTERNAL_ID=\"unique-external-id\"  # If required\n</code></pre>"},{"location":"providers/aws/#aws-profiles","title":"AWS Profiles","text":"<p>Use AWS CLI profiles for local development.</p>"},{"location":"providers/aws/#configuration_2","title":"Configuration","text":"<pre><code>export AWS_REGION=\"us-east-1\"\nexport AWS_PROFILE=\"mlflow-profile\"\nexport MLFLOW_AWS_SECRET_NAME=\"mlflow/auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"aws-secrets-manager\"\n</code></pre>"},{"location":"providers/aws/#profile-setup","title":"Profile Setup","text":"<pre><code># Configure AWS profile\naws configure --profile mlflow-profile\n</code></pre> <p>Profile File (<code>~/.aws/credentials</code>): <pre><code>[mlflow-profile]\naws_access_key_id = AKIAXXXXXXXXXXXXXXXX\naws_secret_access_key = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nregion = us-east-1\n</code></pre></p>"},{"location":"providers/aws/#iam-permissions","title":"IAM Permissions","text":""},{"location":"providers/aws/#basic-secret-access-policy","title":"Basic Secret Access Policy","text":"<p>Minimal policy for reading secrets:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"secretsmanager:GetSecretValue\"\n      ],\n      \"Resource\": [\n        \"arn:aws:secretsmanager:us-east-1:123456789012:secret:mlflow/*\"\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"providers/aws/#enhanced-security-policy","title":"Enhanced Security Policy","text":"<p>Policy with additional security controls:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"secretsmanager:GetSecretValue\"\n      ],\n      \"Resource\": [\n        \"arn:aws:secretsmanager:us-east-1:123456789012:secret:mlflow/auth-*\"\n      ],\n      \"Condition\": {\n        \"StringEquals\": {\n          \"secretsmanager:ResourceTag/Environment\": \"production\",\n          \"secretsmanager:ResourceTag/Application\": \"mlflow\"\n        },\n        \"IpAddress\": {\n          \"aws:SourceIp\": [\"10.0.0.0/16\", \"192.168.1.0/24\"]\n        }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"providers/aws/#cross-account-access-policy","title":"Cross-Account Access Policy","text":"<p>For cross-account secret access:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"sts:AssumeRole\"\n      ],\n      \"Resource\": [\n        \"arn:aws:iam::TARGET-ACCOUNT:role/MLflowSecretsRole\"\n      ]\n    }\n  ]\n}\n</code></pre> <p>Target Account Role Trust Policy: <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::SOURCE-ACCOUNT:role/SourceRole\"\n      },\n      \"Action\": \"sts:AssumeRole\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"sts:ExternalId\": \"unique-external-id\"\n        }\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"providers/aws/#secret-configuration","title":"Secret Configuration","text":""},{"location":"providers/aws/#secret-creation","title":"Secret Creation","text":""},{"location":"providers/aws/#using-aws-cli","title":"Using AWS CLI","text":"<pre><code># Create secret with SecretString\naws secretsmanager create-secret \\\n  --name \"mlflow/auth\" \\\n  --description \"MLflow authentication credentials\" \\\n  --secret-string '{\"token\":\"your-mlflow-token\"}' \\\n  --tags '[{\"Key\":\"Environment\",\"Value\":\"production\"},{\"Key\":\"Application\",\"Value\":\"mlflow\"}]'\n</code></pre>"},{"location":"providers/aws/#using-aws-console","title":"Using AWS Console","text":"<ol> <li>Navigate to AWS Secrets Manager</li> <li>Choose \"Store a new secret\"</li> <li>Select \"Other type of secret\"</li> <li>Enter key-value pairs or JSON</li> <li>Set secret name: <code>mlflow/auth</code></li> <li>Configure rotation (optional)</li> <li>Add tags for organization</li> </ol>"},{"location":"providers/aws/#secret-naming","title":"Secret Naming","text":""},{"location":"providers/aws/#hierarchical-naming","title":"Hierarchical Naming","text":"<pre><code># Environment-based hierarchy\nmlflow/production/auth\nmlflow/staging/auth  \nmlflow/development/auth\n\n# Application-based hierarchy\napps/mlflow/production/auth\napps/mlflow/staging/auth\n\n# Team-based hierarchy\nteams/data-science/mlflow/auth\nteams/ml-engineering/mlflow/auth\n</code></pre>"},{"location":"providers/aws/#arn-based-reference","title":"ARN-Based Reference","text":"<pre><code># Full ARN reference\nexport MLFLOW_AWS_SECRET_NAME=\"arn:aws:secretsmanager:us-east-1:123456789012:secret:mlflow/auth-AbCdEf\"\n\n# Cross-region reference\nexport MLFLOW_AWS_SECRET_NAME=\"arn:aws:secretsmanager:eu-west-1:123456789012:secret:mlflow/auth-XyZ123\"\n</code></pre>"},{"location":"providers/aws/#secret-format","title":"Secret Format","text":""},{"location":"providers/aws/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<p>Store the authentication token in a <code>token</code> field:</p> <pre><code># Create secret with bearer token\naws secretsmanager create-secret \\\n  --name \"mlflow/auth\" \\\n  --secret-string '{\"token\":\"your-bearer-token\"}'\n</code></pre> <p>JSON Structure: <pre><code>{\n  \"token\": \"your-bearer-token\"\n}\n</code></pre></p>"},{"location":"providers/aws/#basic-authentication","title":"Basic Authentication","text":"<p>Store username and password for Basic authentication:</p> <pre><code># Create secret with basic auth\naws secretsmanager create-secret \\\n  --name \"mlflow/auth\" \\\n  --secret-string '{\"username\":\"mlflow-user\",\"password\":\"secure-password\"}'\n</code></pre> <p>JSON Structure: <pre><code>{\n  \"username\": \"mlflow-user\",\n  \"password\": \"secure-password\"\n}\n</code></pre></p>"},{"location":"providers/aws/#binary-secrets","title":"Binary Secrets","text":"<p>AWS Secrets Manager supports binary data:</p> <pre><code># Store binary secret (base64 encoded)\naws secretsmanager create-secret \\\n  --name \"mlflow/auth\" \\\n  --secret-binary fileb://secret-file.bin\n</code></pre> <p>The provider automatically handles base64 encoding/decoding for binary secrets.</p>"},{"location":"providers/aws/#configuration-reference","title":"Configuration Reference","text":""},{"location":"providers/aws/#required-environment-variables","title":"Required Environment Variables","text":"Variable Description Example <code>AWS_REGION</code> AWS region for Secrets Manager <code>us-east-1</code> <code>MLFLOW_AWS_SECRET_NAME</code> Secret name or ARN <code>mlflow/auth</code>"},{"location":"providers/aws/#authentication-variables","title":"Authentication Variables","text":"Variable Description Example <code>AWS_ACCESS_KEY_ID</code> IAM user access key <code>AKIAXXXXXXXXXXXXXXXX</code> <code>AWS_SECRET_ACCESS_KEY</code> IAM user secret key <code>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</code> <code>AWS_SESSION_TOKEN</code> Temporary session token <code>IQoJb3JpZ...</code> <code>AWS_PROFILE</code> AWS CLI profile name <code>mlflow-profile</code> <code>AWS_ROLE_ARN</code> Role ARN for AssumeRole <code>arn:aws:iam::123456789012:role/MLflowRole</code> <code>AWS_ROLE_SESSION_NAME</code> AssumeRole session name <code>mlflow-session</code> <code>AWS_EXTERNAL_ID</code> External ID for AssumeRole <code>unique-external-id</code>"},{"location":"providers/aws/#optional-configuration","title":"Optional Configuration","text":"Variable Default Description Example <code>MLFLOW_AWS_AUTH_MODE</code> <code>bearer</code> Authentication mode <code>bearer</code>, <code>basic</code> <code>MLFLOW_AWS_TTL_SEC</code> <code>300</code> Cache TTL in seconds <code>600</code> <code>MLFLOW_AWS_SECRET_VERSION</code> <code>AWSCURRENT</code> Secret version <code>AWSCURRENT</code>, <code>AWSPENDING</code> <code>MLFLOW_AWS_MAX_RETRIES</code> <code>3</code> Maximum retry attempts <code>5</code> <code>MLFLOW_AWS_RETRY_MODE</code> <code>adaptive</code> Retry mode <code>legacy</code>, <code>standard</code>, <code>adaptive</code>"},{"location":"providers/aws/#examples","title":"Examples","text":""},{"location":"providers/aws/#development-environment","title":"Development Environment","text":"<pre><code>#!/bin/bash\n# Development setup with AWS Secrets Manager\n\n# AWS configuration\nexport AWS_REGION=\"us-east-1\"\nexport AWS_PROFILE=\"mlflow-dev\"\n\n# MLflow Secrets Auth configuration\nexport MLFLOW_AWS_SECRET_NAME=\"mlflow/development/auth\"\nexport MLFLOW_AWS_AUTH_MODE=\"bearer\"\nexport MLFLOW_AWS_TTL_SEC=\"60\"  # Short TTL for development\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"aws-secrets-manager\"\n\n# Security configuration\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"localhost,127.0.0.1,*.local\"\nexport MLFLOW_SECRETS_LOG_LEVEL=\"DEBUG\"\n\n# Create development secret\naws secretsmanager create-secret \\\n  --name \"mlflow/development/auth\" \\\n  --secret-string '{\"token\":\"dev-token-123\"}' \\\n  --profile mlflow-dev\n\n# Test configuration\nmlflow-secrets-auth doctor --dry-run http://localhost:5000\n</code></pre>"},{"location":"providers/aws/#production-environment","title":"Production Environment","text":"<pre><code>#!/bin/bash\n# Production setup with IAM role\n\n# AWS configuration (using IAM role - no access keys needed)\nexport AWS_REGION=\"us-east-1\"\n\n# MLflow Secrets Auth configuration\nexport MLFLOW_AWS_SECRET_NAME=\"mlflow/production/auth\"\nexport MLFLOW_AWS_AUTH_MODE=\"bearer\"\nexport MLFLOW_AWS_TTL_SEC=\"900\"  # 15 minutes for production\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"aws-secrets-manager\"\n\n# Security configuration\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com\"\nexport MLFLOW_SECRETS_LOG_LEVEL=\"INFO\"\n\n# Validate configuration\nmlflow-secrets-auth doctor\n</code></pre>"},{"location":"providers/aws/#multi-region-setup","title":"Multi-Region Setup","text":"<pre><code>#!/bin/bash\n# Multi-region configuration\n\nPRIMARY_REGION=\"us-east-1\"\nBACKUP_REGION=\"us-west-2\"\n\n# Try primary region first\nexport AWS_REGION=\"$PRIMARY_REGION\"\nexport MLFLOW_AWS_SECRET_NAME=\"mlflow/auth\"\n\nif mlflow-secrets-auth doctor &gt; /dev/null 2&gt;&amp;1; then\n    echo \"Using primary region: $PRIMARY_REGION\"\nelse\n    echo \"Primary region failed, switching to backup: $BACKUP_REGION\"\n    export AWS_REGION=\"$BACKUP_REGION\"\n    mlflow-secrets-auth doctor\nfi\n</code></pre>"},{"location":"providers/aws/#cross-account-access_1","title":"Cross-Account Access","text":"<pre><code>#!/bin/bash\n# Cross-account secret access\n\n# Source account credentials (initial authentication)\nexport AWS_REGION=\"us-east-1\"\nexport AWS_ACCESS_KEY_ID=\"$SOURCE_ACCESS_KEY\"\nexport AWS_SECRET_ACCESS_KEY=\"$SOURCE_SECRET_KEY\"\n\n# Target account role (for secret access)\nexport AWS_ROLE_ARN=\"arn:aws:iam::TARGET-ACCOUNT:role/MLflowSecretsRole\"\nexport AWS_ROLE_SESSION_NAME=\"mlflow-cross-account-$(date +%s)\"\nexport AWS_EXTERNAL_ID=\"$EXTERNAL_ID\"\n\n# Secret configuration\nexport MLFLOW_AWS_SECRET_NAME=\"mlflow/shared/auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"aws-secrets-manager\"\n\n# Test cross-account access\nmlflow-secrets-auth doctor\n</code></pre>"},{"location":"providers/aws/#version-management","title":"Version Management","text":""},{"location":"providers/aws/#secret-versions","title":"Secret Versions","text":"<p>AWS Secrets Manager maintains version history:</p> <pre><code># Use current version (default)\nexport MLFLOW_AWS_SECRET_VERSION=\"AWSCURRENT\"\n\n# Use pending version (during rotation)\nexport MLFLOW_AWS_SECRET_VERSION=\"AWSPENDING\"\n\n# Use specific version ID\nexport MLFLOW_AWS_SECRET_VERSION=\"01234567-89ab-cdef-0123-456789abcdef\"\n</code></pre>"},{"location":"providers/aws/#secret-rotation","title":"Secret Rotation","text":"<p>Configure automatic rotation:</p> <pre><code># Create secret with rotation\naws secretsmanager create-secret \\\n  --name \"mlflow/auth\" \\\n  --secret-string '{\"token\":\"initial-token\"}' \\\n  --replica-regions Region=us-west-2 \\\n  --force-overwrite-replica-secret\n\n# Configure rotation\naws secretsmanager rotate-secret \\\n  --secret-id \"mlflow/auth\" \\\n  --rotation-lambda-arn \"arn:aws:lambda:us-east-1:123456789012:function:mlflow-token-rotator\" \\\n  --rotation-rules AutomaticallyAfterDays=30\n</code></pre>"},{"location":"providers/aws/#troubleshooting","title":"Troubleshooting","text":""},{"location":"providers/aws/#common-issues","title":"Common Issues","text":""},{"location":"providers/aws/#authentication-failures","title":"Authentication Failures","text":"<p>Problem: <code>AWS credentials not found</code></p> <p>Solutions:</p> <ol> <li> <p>Check AWS Configuration:    <pre><code>aws sts get-caller-identity\n</code></pre></p> </li> <li> <p>Verify IAM Permissions:    <pre><code>aws iam simulate-principal-policy \\\n  --policy-source-arn \"arn:aws:iam::123456789012:user/mlflow-user\" \\\n  --action-names \"secretsmanager:GetSecretValue\" \\\n  --resource-arns \"arn:aws:secretsmanager:us-east-1:123456789012:secret:mlflow/auth-*\"\n</code></pre></p> </li> <li> <p>Test Secret Access:    <pre><code>aws secretsmanager get-secret-value --secret-id \"mlflow/auth\"\n</code></pre></p> </li> </ol>"},{"location":"providers/aws/#secret-not-found","title":"Secret Not Found","text":"<p>Problem: <code>Secret not found</code></p> <p>Solutions:</p> <ol> <li> <p>List Available Secrets:    <pre><code>aws secretsmanager list-secrets --query 'SecretList[?contains(Name, `mlflow`)]'\n</code></pre></p> </li> <li> <p>Check Secret ARN:    <pre><code>aws secretsmanager describe-secret --secret-id \"mlflow/auth\"\n</code></pre></p> </li> <li> <p>Verify Region:    <pre><code>aws secretsmanager list-secrets --region us-west-2\n</code></pre></p> </li> </ol>"},{"location":"providers/aws/#network-connectivity","title":"Network Connectivity","text":"<p>Problem: <code>Connection timeout</code></p> <p>Solutions:</p> <ol> <li> <p>Test AWS Connectivity:    <pre><code>aws secretsmanager list-secrets --max-items 1\n</code></pre></p> </li> <li> <p>Check VPC Endpoints:    <pre><code>aws ec2 describe-vpc-endpoints --filters Name=service-name,Values=com.amazonaws.region.secretsmanager\n</code></pre></p> </li> <li> <p>Verify DNS Resolution:    <pre><code>nslookup secretsmanager.us-east-1.amazonaws.com\n</code></pre></p> </li> </ol>"},{"location":"providers/aws/#debug-mode","title":"Debug Mode","text":"<p>Enable debug logging for detailed troubleshooting:</p> <pre><code>export MLFLOW_SECRETS_LOG_LEVEL=\"DEBUG\"\nmlflow-secrets-auth doctor\n</code></pre> <p>Debug Output Includes: - AWS credential resolution - Secret Manager client configuration - API request/response details - Error details and retry attempts</p>"},{"location":"providers/aws/#cli-diagnostics","title":"CLI Diagnostics","text":"<p>Use the CLI for comprehensive diagnostics:</p> <pre><code># Basic configuration check\nmlflow-secrets-auth info\n\n# Full diagnostic with AWS connectivity\nmlflow-secrets-auth doctor\n\n# Test against MLflow server\nmlflow-secrets-auth doctor --dry-run https://mlflow.company.com\n</code></pre>"},{"location":"providers/aws/#security-best-practices","title":"Security Best Practices","text":""},{"location":"providers/aws/#iam-security","title":"IAM Security","text":"<ol> <li>Principle of Least Privilege: Grant minimal required permissions</li> <li>Use IAM Roles: Prefer roles over long-term access keys</li> <li>Regular Rotation: Rotate access keys and secrets regularly</li> <li>Condition-Based Policies: Use conditions to restrict access</li> </ol>"},{"location":"providers/aws/#network-security","title":"Network Security","text":"<ol> <li>VPC Endpoints: Use VPC endpoints for private connectivity</li> <li>Security Groups: Restrict outbound access to AWS services</li> <li>PrivateLink: Use AWS PrivateLink for enhanced security</li> <li>Network ACLs: Implement network-level controls</li> </ol>"},{"location":"providers/aws/#secret-security","title":"Secret Security","text":"<ol> <li>Encryption in Transit: HTTPS/TLS enforced by default</li> <li>Encryption at Rest: AWS KMS encryption for stored secrets</li> <li>Access Logging: Enable CloudTrail logging</li> <li>Secret Rotation: Implement automatic rotation</li> </ol>"},{"location":"providers/aws/#monitoring-and-auditing","title":"Monitoring and Auditing","text":"<ol> <li> <p>CloudTrail Logging:    <pre><code>{\n  \"eventSource\": \"secretsmanager.amazonaws.com\",\n  \"eventName\": \"GetSecretValue\",\n  \"sourceIPAddress\": \"10.0.1.100\",\n  \"userIdentity\": {\n    \"type\": \"AssumedRole\",\n    \"principalId\": \"AROAEXAMPLE:mlflow-session\"\n  }\n}\n</code></pre></p> </li> <li> <p>CloudWatch Metrics: Monitor secret access patterns</p> </li> <li>AWS Config: Track configuration compliance</li> <li>Security Hub: Centralized security findings</li> </ol>"},{"location":"providers/aws/#performance-optimization","title":"Performance Optimization","text":""},{"location":"providers/aws/#connection-reuse","title":"Connection Reuse","text":"<p>The provider automatically reuses AWS client connections:</p> <pre><code># Connection pooling handled by boto3\n# Sessions and clients are cached per provider instance\n</code></pre>"},{"location":"providers/aws/#caching-strategy","title":"Caching Strategy","text":"<p>Configure appropriate TTL based on your rotation frequency:</p> <pre><code># High-frequency rotation: shorter TTL\nMLFLOW_AWS_TTL_SEC=300   # 5 minutes\n\n# Standard rotation: medium TTL\nMLFLOW_AWS_TTL_SEC=900   # 15 minutes\n\n# Infrequent rotation: longer TTL\nMLFLOW_AWS_TTL_SEC=1800  # 30 minutes\n</code></pre>"},{"location":"providers/aws/#regional-optimization","title":"Regional Optimization","text":"<ol> <li>Same Region: Deploy in same region as Secrets Manager</li> <li>VPC Endpoints: Use VPC endpoints to avoid internet routing</li> <li>Regional Replication: Use secret replication for DR</li> </ol>"},{"location":"providers/aws/#integration-examples","title":"Integration Examples","text":""},{"location":"providers/aws/#docker-deployment","title":"Docker Deployment","text":"<pre><code>FROM python:3.11-slim\n\n# Install MLflow Secrets Auth with AWS support\nRUN pip install mlflow-secrets-auth[aws]\n\n# Copy application\nCOPY . /app\nWORKDIR /app\n\n# Environment variables will be provided at runtime\nENV AWS_REGION=\"\"\nENV MLFLOW_AWS_SECRET_NAME=\"\"\nENV MLFLOW_SECRETS_AUTH_ENABLE=\"aws-secrets-manager\"\n\n# Use IAM role for authentication (no access keys in image)\nCMD [\"python\", \"app.py\"]\n</code></pre>"},{"location":"providers/aws/#ecs-task-definition","title":"ECS Task Definition","text":"<pre><code>{\n  \"family\": \"mlflow-app\",\n  \"taskRoleArn\": \"arn:aws:iam::123456789012:role/MLflowTaskRole\",\n  \"executionRoleArn\": \"arn:aws:iam::123456789012:role/MLflowExecutionRole\",\n  \"containerDefinitions\": [\n    {\n      \"name\": \"mlflow-app\",\n      \"image\": \"mlflow-app:latest\",\n      \"environment\": [\n        {\"name\": \"AWS_REGION\", \"value\": \"us-east-1\"},\n        {\"name\": \"MLFLOW_AWS_SECRET_NAME\", \"value\": \"mlflow/production/auth\"},\n        {\"name\": \"MLFLOW_SECRETS_AUTH_ENABLE\", \"value\": \"aws-secrets-manager\"},\n        {\"name\": \"MLFLOW_SECRETS_ALLOWED_HOSTS\", \"value\": \"mlflow.company.com\"}\n      ],\n      \"logConfiguration\": {\n        \"logDriver\": \"awslogs\",\n        \"options\": {\n          \"awslogs-group\": \"/ecs/mlflow-app\",\n          \"awslogs-region\": \"us-east-1\",\n          \"awslogs-stream-prefix\": \"ecs\"\n        }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"providers/aws/#lambda-function","title":"Lambda Function","text":"<pre><code>import os\nimport mlflow\n\ndef lambda_handler(event, context):\n    # Environment variables configured in Lambda\n    # AWS_REGION=us-east-1\n    # MLFLOW_AWS_SECRET_NAME=mlflow/auth\n    # MLFLOW_SECRETS_AUTH_ENABLE=aws-secrets-manager\n\n    mlflow.set_tracking_uri(\"https://mlflow.company.com\")\n\n    with mlflow.start_run():\n        mlflow.log_param(\"lambda_function\", context.function_name)\n        mlflow.log_metric(\"invocation_count\", 1)\n\n    return {\"statusCode\": 200, \"body\": \"Success\"}\n</code></pre>"},{"location":"providers/aws/#terraform-configuration","title":"Terraform Configuration","text":"<pre><code># Create secret\nresource \"aws_secretsmanager_secret\" \"mlflow_auth\" {\n  name        = \"mlflow/production/auth\"\n  description = \"MLflow authentication credentials\"\n\n  tags = {\n    Environment = \"production\"\n    Application = \"mlflow\"\n  }\n}\n\nresource \"aws_secretsmanager_secret_version\" \"mlflow_auth\" {\n  secret_id = aws_secretsmanager_secret.mlflow_auth.id\n  secret_string = jsonencode({\n    token = var.mlflow_token\n  })\n}\n\n# IAM role for ECS task\nresource \"aws_iam_role\" \"mlflow_task_role\" {\n  name = \"MLflowTaskRole\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = \"sts:AssumeRole\"\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"ecs-tasks.amazonaws.com\"\n        }\n      }\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"mlflow_secrets_access\" {\n  name = \"MLflowSecretsAccess\"\n  role = aws_iam_role.mlflow_task_role.id\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\"secretsmanager:GetSecretValue\"]\n        Resource = [aws_secretsmanager_secret.mlflow_auth.arn]\n      }\n    ]\n  })\n}\n</code></pre>"},{"location":"providers/aws/#next-steps","title":"Next Steps","text":"<ul> <li>Azure Key Vault Provider - Azure-specific configuration</li> <li>HashiCorp Vault Provider - Vault-specific configuration</li> <li>Configuration Reference - Complete environment variable reference</li> <li>Troubleshooting Guide - General troubleshooting information</li> </ul>"},{"location":"providers/azure/","title":"Azure Key Vault Provider","text":"<p>The Azure Key Vault provider enables MLflow Secrets Auth to retrieve credentials from Microsoft Azure Key Vault using Azure Active Directory authentication. It supports multiple Azure authentication methods and integrates seamlessly with Azure cloud services.</p>"},{"location":"providers/azure/#overview","title":"Overview","text":"<p>Azure Key Vault is a cloud service for securely storing and accessing secrets, keys, and certificates. The MLflow Secrets Auth Azure provider integrates with Azure Active Directory (Azure AD) for authentication and supports various Azure deployment patterns.</p>"},{"location":"providers/azure/#features","title":"Features","text":"<ul> <li>Multiple Authentication Methods: Service principals, managed identities, and certificate-based authentication</li> <li>Azure AD Integration: Native integration with Azure Active Directory</li> <li>Managed Identity Support: Seamless authentication for Azure-hosted applications</li> <li>Certificate Authentication: Support for certificate-based authentication</li> <li>Multi-Cloud Support: Works with Azure Government and other Azure clouds</li> <li>Version Management: Support for specific secret versions</li> </ul>"},{"location":"providers/azure/#requirements","title":"Requirements","text":"<ul> <li>Azure Subscription: Valid Azure subscription with Key Vault access</li> <li>Azure AD Permissions: Appropriate Azure AD permissions for authentication</li> <li>Key Vault Access: Access policies or RBAC permissions for secret access</li> <li>Network Access: Connectivity to Azure Key Vault endpoints</li> <li>Python Packages: <code>azure-identity&gt;=1.24.0</code>, <code>azure-keyvault-secrets&gt;=4.10.0</code> (installed with <code>pip install mlflow-secrets-auth[azure]</code>)</li> </ul>"},{"location":"providers/azure/#installation","title":"Installation","text":""},{"location":"providers/azure/#basic-installation","title":"Basic Installation","text":"<pre><code>pip install mlflow-secrets-auth[azure]\n</code></pre>"},{"location":"providers/azure/#verify-installation","title":"Verify Installation","text":"<pre><code>python -c \"import azure.identity, azure.keyvault.secrets; print('\u2713 Azure support available')\"\n</code></pre>"},{"location":"providers/azure/#authentication-methods","title":"Authentication Methods","text":""},{"location":"providers/azure/#service-principal-with-secret","title":"Service Principal with Secret","text":"<p>Use Azure AD service principal with client secret for authentication.</p>"},{"location":"providers/azure/#configuration","title":"Configuration","text":"<pre><code>export AZURE_TENANT_ID=\"12345678-1234-1234-1234-123456789012\"\nexport AZURE_CLIENT_ID=\"87654321-4321-4321-4321-210987654321\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret-value\"\nexport MLFLOW_AZURE_KEY_VAULT_URL=\"https://your-vault.vault.azure.net/\"\nexport MLFLOW_AZURE_SECRET_NAME=\"mlflow-auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"azure-key-vault\"\n</code></pre>"},{"location":"providers/azure/#service-principal-setup","title":"Service Principal Setup","text":"<ol> <li> <p>Create Service Principal:    <pre><code>az ad sp create-for-rbac \\\n  --name \"mlflow-secrets-auth\" \\\n  --role \"Key Vault Secrets User\" \\\n  --scopes \"/subscriptions/{subscription-id}/resourceGroups/{rg-name}/providers/Microsoft.KeyVault/vaults/{vault-name}\"\n</code></pre></p> </li> <li> <p>Note Credentials:    <pre><code>{\n  \"appId\": \"87654321-4321-4321-4321-210987654321\",\n  \"displayName\": \"mlflow-secrets-auth\",\n  \"password\": \"your-client-secret-value\",\n  \"tenant\": \"12345678-1234-1234-1234-123456789012\"\n}\n</code></pre></p> </li> </ol>"},{"location":"providers/azure/#service-principal-with-certificate","title":"Service Principal with Certificate","text":"<p>Use certificate-based authentication for enhanced security.</p>"},{"location":"providers/azure/#configuration_1","title":"Configuration","text":"<pre><code>export AZURE_TENANT_ID=\"12345678-1234-1234-1234-123456789012\"\nexport AZURE_CLIENT_ID=\"87654321-4321-4321-4321-210987654321\"\nexport AZURE_CLIENT_CERTIFICATE_PATH=\"/path/to/certificate.pem\"\nexport MLFLOW_AZURE_KEY_VAULT_URL=\"https://your-vault.vault.azure.net/\"\nexport MLFLOW_AZURE_SECRET_NAME=\"mlflow-auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"azure-key-vault\"\n</code></pre>"},{"location":"providers/azure/#certificate-setup","title":"Certificate Setup","text":"<ol> <li> <p>Generate Certificate:    <pre><code>openssl req -new -x509 -key private.key -out certificate.crt -days 365\ncat private.key certificate.crt &gt; certificate.pem\n</code></pre></p> </li> <li> <p>Upload to Service Principal:    <pre><code>az ad sp credential reset \\\n  --id \"87654321-4321-4321-4321-210987654321\" \\\n  --cert @certificate.crt\n</code></pre></p> </li> </ol>"},{"location":"providers/azure/#managed-identity-recommended-for-azure-services","title":"Managed Identity (Recommended for Azure Services)","text":"<p>Use Azure Managed Identity for applications running on Azure services.</p>"},{"location":"providers/azure/#system-assigned-managed-identity","title":"System-Assigned Managed Identity","text":"<pre><code>export MLFLOW_AZURE_KEY_VAULT_URL=\"https://your-vault.vault.azure.net/\"\nexport MLFLOW_AZURE_SECRET_NAME=\"mlflow-auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"azure-key-vault\"\n# No Azure AD credentials needed - automatically detected\n</code></pre>"},{"location":"providers/azure/#user-assigned-managed-identity","title":"User-Assigned Managed Identity","text":"<pre><code>export AZURE_CLIENT_ID=\"user-assigned-identity-client-id\"\nexport MLFLOW_AZURE_KEY_VAULT_URL=\"https://your-vault.vault.azure.net/\"\nexport MLFLOW_AZURE_SECRET_NAME=\"mlflow-auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"azure-key-vault\"\n</code></pre>"},{"location":"providers/azure/#managed-identity-setup","title":"Managed Identity Setup","text":"<ol> <li> <p>Enable System-Assigned Identity:    <pre><code>az vm identity assign --name \"my-vm\" --resource-group \"my-rg\"\n</code></pre></p> </li> <li> <p>Create User-Assigned Identity:    <pre><code>az identity create \\\n  --name \"mlflow-identity\" \\\n  --resource-group \"my-rg\"\n</code></pre></p> </li> <li> <p>Assign to VM:    <pre><code>az vm identity assign \\\n  --name \"my-vm\" \\\n  --resource-group \"my-rg\" \\\n  --identities \"/subscriptions/{subscription-id}/resourcegroups/{rg-name}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/mlflow-identity\"\n</code></pre></p> </li> </ol>"},{"location":"providers/azure/#access-control","title":"Access Control","text":""},{"location":"providers/azure/#access-policies-classic","title":"Access Policies (Classic)","text":"<p>Traditional access policy model for Key Vault access.</p>"},{"location":"providers/azure/#assign-access-policy","title":"Assign Access Policy","text":"<pre><code># Service principal access\naz keyvault set-policy \\\n  --name \"your-vault\" \\\n  --spn \"87654321-4321-4321-4321-210987654321\" \\\n  --secret-permissions get\n\n# Managed identity access\naz keyvault set-policy \\\n  --name \"your-vault\" \\\n  --object-id \"managed-identity-object-id\" \\\n  --secret-permissions get\n</code></pre>"},{"location":"providers/azure/#access-policy-json","title":"Access Policy JSON","text":"<pre><code>{\n  \"tenantId\": \"12345678-1234-1234-1234-123456789012\",\n  \"objectId\": \"87654321-4321-4321-4321-210987654321\",\n  \"permissions\": {\n    \"secrets\": [\"get\"]\n  }\n}\n</code></pre>"},{"location":"providers/azure/#rbac-recommended","title":"RBAC (Recommended)","text":"<p>Role-Based Access Control for more granular permissions.</p>"},{"location":"providers/azure/#enable-rbac","title":"Enable RBAC","text":"<pre><code>az keyvault update \\\n  --name \"your-vault\" \\\n  --resource-group \"my-rg\" \\\n  --enable-rbac-authorization true\n</code></pre>"},{"location":"providers/azure/#assign-rbac-role","title":"Assign RBAC Role","text":"<pre><code># Service principal\naz role assignment create \\\n  --role \"Key Vault Secrets User\" \\\n  --assignee \"87654321-4321-4321-4321-210987654321\" \\\n  --scope \"/subscriptions/{subscription-id}/resourceGroups/{rg-name}/providers/Microsoft.KeyVault/vaults/{vault-name}\"\n\n# Managed identity\naz role assignment create \\\n  --role \"Key Vault Secrets User\" \\\n  --assignee-object-id \"managed-identity-object-id\" \\\n  --assignee-principal-type ServicePrincipal \\\n  --scope \"/subscriptions/{subscription-id}/resourceGroups/{rg-name}/providers/Microsoft.KeyVault/vaults/{vault-name}\"\n</code></pre>"},{"location":"providers/azure/#custom-rbac-role","title":"Custom RBAC Role","text":"<pre><code>{\n  \"Name\": \"MLflow Secrets Reader\",\n  \"Description\": \"Read MLflow secrets from Key Vault\",\n  \"Actions\": [],\n  \"DataActions\": [\n    \"Microsoft.KeyVault/vaults/secrets/getSecret/action\"\n  ],\n  \"NotActions\": [],\n  \"NotDataActions\": [],\n  \"AssignableScopes\": [\n    \"/subscriptions/{subscription-id}\"\n  ]\n}\n</code></pre>"},{"location":"providers/azure/#secret-configuration","title":"Secret Configuration","text":""},{"location":"providers/azure/#secret-creation","title":"Secret Creation","text":""},{"location":"providers/azure/#using-azure-cli","title":"Using Azure CLI","text":"<pre><code># Create secret with value\naz keyvault secret set \\\n  --vault-name \"your-vault\" \\\n  --name \"mlflow-auth\" \\\n  --value '{\"token\":\"your-mlflow-token\"}' \\\n  --tags Environment=production Application=mlflow\n</code></pre>"},{"location":"providers/azure/#using-azure-portal","title":"Using Azure Portal","text":"<ol> <li>Navigate to your Key Vault in Azure Portal</li> <li>Select \"Secrets\" from the left menu</li> <li>Click \"Generate/Import\"</li> <li>Choose \"Manual\" upload type</li> <li>Enter secret name: <code>mlflow-auth</code></li> <li>Enter secret value (JSON format)</li> <li>Set expiration date (optional)</li> <li>Add tags for organization</li> </ol>"},{"location":"providers/azure/#secret-naming-conventions","title":"Secret Naming Conventions","text":""},{"location":"providers/azure/#hierarchical-naming","title":"Hierarchical Naming","text":"<pre><code># Environment-based\nmlflow-production-auth\nmlflow-staging-auth\nmlflow-development-auth\n\n# Application-based\napps-mlflow-production-auth\napps-mlflow-staging-auth\n\n# Team-based\nteam-data-science-mlflow-auth\nteam-ml-engineering-mlflow-auth\n</code></pre>"},{"location":"providers/azure/#resource-specific-naming","title":"Resource-Specific Naming","text":"<pre><code># Resource group specific\nexport MLFLOW_AZURE_SECRET_NAME=\"mlflow-${RESOURCE_GROUP}-auth\"\n\n# Environment specific\nexport MLFLOW_AZURE_SECRET_NAME=\"mlflow-${ENVIRONMENT}-auth\"\n</code></pre>"},{"location":"providers/azure/#secret-format","title":"Secret Format","text":""},{"location":"providers/azure/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<p>Store the authentication token in a <code>token</code> field:</p> <pre><code># Create secret with bearer token\naz keyvault secret set \\\n  --vault-name \"your-vault\" \\\n  --name \"mlflow-auth\" \\\n  --value '{\"token\":\"your-bearer-token\"}'\n</code></pre> <p>JSON Structure: <pre><code>{\n  \"token\": \"your-bearer-token\"\n}\n</code></pre></p>"},{"location":"providers/azure/#basic-authentication","title":"Basic Authentication","text":"<p>Store username and password for Basic authentication:</p> <pre><code># Create secret with basic auth\naz keyvault secret set \\\n  --vault-name \"your-vault\" \\\n  --name \"mlflow-auth\" \\\n  --value '{\"username\":\"mlflow-user\",\"password\":\"secure-password\"}'\n</code></pre> <p>JSON Structure: <pre><code>{\n  \"username\": \"mlflow-user\",\n  \"password\": \"secure-password\"\n}\n</code></pre></p>"},{"location":"providers/azure/#complex-secrets","title":"Complex Secrets","text":"<p>Store additional metadata:</p> <pre><code># Create secret with metadata\naz keyvault secret set \\\n  --vault-name \"your-vault\" \\\n  --name \"mlflow-auth\" \\\n  --value '{\"token\":\"bearer-token\",\"description\":\"MLflow production auth\",\"environment\":\"production\"}' \\\n  --tags created_by=admin environment=production\n</code></pre> <p>JSON Structure: <pre><code>{\n  \"token\": \"bearer-token\",\n  \"description\": \"MLflow production auth\", \n  \"environment\": \"production\"\n}\n</code></pre></p>"},{"location":"providers/azure/#configuration-reference","title":"Configuration Reference","text":""},{"location":"providers/azure/#required-environment-variables","title":"Required Environment Variables","text":"Variable Description Example <code>MLFLOW_AZURE_KEY_VAULT_URL</code> Key Vault URL <code>https://your-vault.vault.azure.net/</code> <code>MLFLOW_AZURE_SECRET_NAME</code> Secret name <code>mlflow-auth</code>"},{"location":"providers/azure/#authentication-variables","title":"Authentication Variables","text":""},{"location":"providers/azure/#service-principal-with-secret_1","title":"Service Principal with Secret","text":"Variable Description Example <code>AZURE_TENANT_ID</code> Azure AD tenant ID <code>12345678-1234-1234-1234-123456789012</code> <code>AZURE_CLIENT_ID</code> Service principal client ID <code>87654321-4321-4321-4321-210987654321</code> <code>AZURE_CLIENT_SECRET</code> Service principal secret <code>your-client-secret</code>"},{"location":"providers/azure/#service-principal-with-certificate_1","title":"Service Principal with Certificate","text":"Variable Description Example <code>AZURE_TENANT_ID</code> Azure AD tenant ID <code>12345678-1234-1234-1234-123456789012</code> <code>AZURE_CLIENT_ID</code> Service principal client ID <code>87654321-4321-4321-4321-210987654321</code> <code>AZURE_CLIENT_CERTIFICATE_PATH</code> Certificate file path <code>/path/to/certificate.pem</code>"},{"location":"providers/azure/#managed-identity","title":"Managed Identity","text":"Variable Description Example <code>AZURE_CLIENT_ID</code> User-assigned identity client ID (optional) <code>user-assigned-identity-client-id</code>"},{"location":"providers/azure/#optional-configuration","title":"Optional Configuration","text":"Variable Default Description Example <code>MLFLOW_AZURE_AUTH_MODE</code> <code>bearer</code> Authentication mode <code>bearer</code>, <code>basic</code> <code>MLFLOW_AZURE_TTL_SEC</code> <code>300</code> Cache TTL in seconds <code>600</code> <code>MLFLOW_AZURE_SECRET_VERSION</code> <code>latest</code> Secret version <code>latest</code>, version ID <code>AZURE_CLOUD_ENVIRONMENT</code> <code>AzurePublicCloud</code> Azure cloud environment <code>AzurePublicCloud</code>, <code>AzureUSGovernment</code>"},{"location":"providers/azure/#examples","title":"Examples","text":""},{"location":"providers/azure/#development-environment","title":"Development Environment","text":"<pre><code>#!/bin/bash\n# Development setup with Azure Key Vault\n\n# Azure AD configuration (service principal)\nexport AZURE_TENANT_ID=\"12345678-1234-1234-1234-123456789012\"\nexport AZURE_CLIENT_ID=\"87654321-4321-4321-4321-210987654321\"\nexport AZURE_CLIENT_SECRET=\"${DEV_AZURE_CLIENT_SECRET}\"\n\n# Azure Key Vault configuration\nexport MLFLOW_AZURE_KEY_VAULT_URL=\"https://dev-vault.vault.azure.net/\"\nexport MLFLOW_AZURE_SECRET_NAME=\"mlflow-development-auth\"\nexport MLFLOW_AZURE_AUTH_MODE=\"bearer\"\nexport MLFLOW_AZURE_TTL_SEC=\"60\"  # Short TTL for development\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"azure-key-vault\"\n\n# Security configuration\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"localhost,127.0.0.1,*.local\"\nexport MLFLOW_SECRETS_LOG_LEVEL=\"DEBUG\"\n\n# Create development secret\naz keyvault secret set \\\n  --vault-name \"dev-vault\" \\\n  --name \"mlflow-development-auth\" \\\n  --value '{\"token\":\"dev-token-123\"}'\n\n# Test configuration\nmlflow-secrets-auth doctor --dry-run http://localhost:5000\n</code></pre>"},{"location":"providers/azure/#production-environment-with-managed-identity","title":"Production Environment with Managed Identity","text":"<pre><code>#!/bin/bash\n# Production setup with managed identity\n\n# Azure Key Vault configuration (no Azure AD credentials needed)\nexport MLFLOW_AZURE_KEY_VAULT_URL=\"https://prod-vault.vault.azure.net/\"\nexport MLFLOW_AZURE_SECRET_NAME=\"mlflow-production-auth\"\nexport MLFLOW_AZURE_AUTH_MODE=\"bearer\"\nexport MLFLOW_AZURE_TTL_SEC=\"900\"  # 15 minutes for production\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"azure-key-vault\"\n\n# Security configuration\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com\"\nexport MLFLOW_SECRETS_LOG_LEVEL=\"INFO\"\n\n# Validate configuration\nmlflow-secrets-auth doctor\n</code></pre>"},{"location":"providers/azure/#multi-environment-setup","title":"Multi-Environment Setup","text":"<pre><code>#!/bin/bash\n# Environment-specific configuration\n\nENVIRONMENT=${ENVIRONMENT:-development}\n\ncase $ENVIRONMENT in\n  development)\n    export AZURE_TENANT_ID=\"${DEV_AZURE_TENANT_ID}\"\n    export AZURE_CLIENT_ID=\"${DEV_AZURE_CLIENT_ID}\"\n    export AZURE_CLIENT_SECRET=\"${DEV_AZURE_CLIENT_SECRET}\"\n    export MLFLOW_AZURE_KEY_VAULT_URL=\"https://dev-vault.vault.azure.net/\"\n    export MLFLOW_AZURE_SECRET_NAME=\"mlflow-dev-auth\"\n    export MLFLOW_AZURE_TTL_SEC=\"60\"\n    export MLFLOW_SECRETS_ALLOWED_HOSTS=\"localhost,*.local\"\n    ;;\n\n  staging)\n    export AZURE_TENANT_ID=\"${STAGING_AZURE_TENANT_ID}\"\n    export AZURE_CLIENT_ID=\"${STAGING_AZURE_CLIENT_ID}\"\n    export AZURE_CLIENT_SECRET=\"${STAGING_AZURE_CLIENT_SECRET}\"\n    export MLFLOW_AZURE_KEY_VAULT_URL=\"https://staging-vault.vault.azure.net/\"\n    export MLFLOW_AZURE_SECRET_NAME=\"mlflow-staging-auth\"\n    export MLFLOW_AZURE_TTL_SEC=\"300\"\n    export MLFLOW_SECRETS_ALLOWED_HOSTS=\"*.staging.company.com\"\n    ;;\n\n  production)\n    # Using managed identity - no credentials needed\n    export MLFLOW_AZURE_KEY_VAULT_URL=\"https://prod-vault.vault.azure.net/\"\n    export MLFLOW_AZURE_SECRET_NAME=\"mlflow-production-auth\"\n    export MLFLOW_AZURE_TTL_SEC=\"900\"\n    export MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com\"\n    ;;\nesac\n\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"azure-key-vault\"\nmlflow-secrets-auth doctor\n</code></pre>"},{"location":"providers/azure/#certificate-based-authentication","title":"Certificate-Based Authentication","text":"<pre><code>#!/bin/bash\n# Certificate-based authentication setup\n\n# Azure AD configuration with certificate\nexport AZURE_TENANT_ID=\"12345678-1234-1234-1234-123456789012\"\nexport AZURE_CLIENT_ID=\"87654321-4321-4321-4321-210987654321\"\nexport AZURE_CLIENT_CERTIFICATE_PATH=\"/etc/ssl/certs/mlflow-auth.pem\"\n\n# Azure Key Vault configuration\nexport MLFLOW_AZURE_KEY_VAULT_URL=\"https://secure-vault.vault.azure.net/\"\nexport MLFLOW_AZURE_SECRET_NAME=\"mlflow-secure-auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"azure-key-vault\"\n\n# Validate certificate authentication\nmlflow-secrets-auth doctor\n</code></pre>"},{"location":"providers/azure/#version-management","title":"Version Management","text":""},{"location":"providers/azure/#secret-versions","title":"Secret Versions","text":"<p>Azure Key Vault maintains version history:</p> <pre><code># Use latest version (default)\nexport MLFLOW_AZURE_SECRET_VERSION=\"latest\"\n\n# Use specific version\nexport MLFLOW_AZURE_SECRET_VERSION=\"d1234567890abcdef1234567890abcdef\"\n</code></pre>"},{"location":"providers/azure/#version-operations","title":"Version Operations","text":"<pre><code># List secret versions\naz keyvault secret list-versions --vault-name \"your-vault\" --name \"mlflow-auth\"\n\n# Get specific version\naz keyvault secret show \\\n  --vault-name \"your-vault\" \\\n  --name \"mlflow-auth\" \\\n  --version \"d1234567890abcdef1234567890abcdef\"\n\n# Update secret (creates new version)\naz keyvault secret set \\\n  --vault-name \"your-vault\" \\\n  --name \"mlflow-auth\" \\\n  --value '{\"token\":\"updated-token\"}'\n</code></pre>"},{"location":"providers/azure/#azure-cloud-environments","title":"Azure Cloud Environments","text":""},{"location":"providers/azure/#government-cloud","title":"Government Cloud","text":"<pre><code># Azure US Government\nexport AZURE_CLOUD_ENVIRONMENT=\"AzureUSGovernment\"\nexport MLFLOW_AZURE_KEY_VAULT_URL=\"https://your-vault.vault.usgovcloudapi.net/\"\n</code></pre>"},{"location":"providers/azure/#china-cloud","title":"China Cloud","text":"<pre><code># Azure China\nexport AZURE_CLOUD_ENVIRONMENT=\"AzureChinaCloud\"\nexport MLFLOW_AZURE_KEY_VAULT_URL=\"https://your-vault.vault.azure.cn/\"\n</code></pre>"},{"location":"providers/azure/#troubleshooting","title":"Troubleshooting","text":""},{"location":"providers/azure/#common-issues","title":"Common Issues","text":""},{"location":"providers/azure/#authentication-failures","title":"Authentication Failures","text":"<p>Problem: <code>Azure authentication failed</code></p> <p>Solutions:</p> <ol> <li> <p>Check Service Principal:    <pre><code>az login --service-principal \\\n  --username \"$AZURE_CLIENT_ID\" \\\n  --password \"$AZURE_CLIENT_SECRET\" \\\n  --tenant \"$AZURE_TENANT_ID\"\n</code></pre></p> </li> <li> <p>Verify Managed Identity:    <pre><code># From Azure VM\ncurl -H \"Metadata:true\" \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&amp;resource=https://vault.azure.net/\"\n</code></pre></p> </li> <li> <p>Test Key Vault Access:    <pre><code>az keyvault secret show \\\n  --vault-name \"your-vault\" \\\n  --name \"mlflow-auth\"\n</code></pre></p> </li> </ol>"},{"location":"providers/azure/#permission-errors","title":"Permission Errors","text":"<p>Problem: <code>Access denied to Key Vault</code></p> <p>Solutions:</p> <ol> <li> <p>Check Access Policies:    <pre><code>az keyvault show --name \"your-vault\" --query \"properties.accessPolicies\"\n</code></pre></p> </li> <li> <p>Verify RBAC Assignments:    <pre><code>az role assignment list \\\n  --assignee \"$AZURE_CLIENT_ID\" \\\n  --scope \"/subscriptions/{subscription-id}/resourceGroups/{rg-name}/providers/Microsoft.KeyVault/vaults/{vault-name}\"\n</code></pre></p> </li> <li> <p>Test Permissions:    <pre><code>az keyvault secret list --vault-name \"your-vault\"\n</code></pre></p> </li> </ol>"},{"location":"providers/azure/#network-connectivity","title":"Network Connectivity","text":"<p>Problem: <code>Connection timeout to Key Vault</code></p> <p>Solutions:</p> <ol> <li> <p>Test Connectivity:    <pre><code>curl \"https://your-vault.vault.azure.net/\"\n</code></pre></p> </li> <li> <p>Check Private Endpoints:    <pre><code>az network private-endpoint list --resource-group \"my-rg\"\n</code></pre></p> </li> <li> <p>Verify DNS Resolution:    <pre><code>nslookup your-vault.vault.azure.net\n</code></pre></p> </li> </ol>"},{"location":"providers/azure/#debug-mode","title":"Debug Mode","text":"<p>Enable debug logging for detailed troubleshooting:</p> <pre><code>export MLFLOW_SECRETS_LOG_LEVEL=\"DEBUG\"\nmlflow-secrets-auth doctor\n</code></pre> <p>Debug Output Includes: - Azure credential resolution chain - Key Vault client configuration - Authentication method selection - API request/response details</p>"},{"location":"providers/azure/#cli-diagnostics","title":"CLI Diagnostics","text":"<p>Use the CLI for comprehensive diagnostics:</p> <pre><code># Basic configuration check\nmlflow-secrets-auth info\n\n# Full diagnostic with Azure connectivity\nmlflow-secrets-auth doctor\n\n# Test against MLflow server\nmlflow-secrets-auth doctor --dry-run https://mlflow.company.com\n</code></pre>"},{"location":"providers/azure/#security-best-practices","title":"Security Best Practices","text":""},{"location":"providers/azure/#identity-security","title":"Identity Security","text":"<ol> <li>Use Managed Identities: Prefer managed identities over service principals</li> <li>Principle of Least Privilege: Grant minimal required permissions</li> <li>Certificate Authentication: Use certificates instead of secrets when possible</li> <li>Regular Rotation: Rotate service principal secrets regularly</li> </ol>"},{"location":"providers/azure/#network-security","title":"Network Security","text":"<ol> <li>Private Endpoints: Use private endpoints for enhanced security</li> <li>Virtual Network Integration: Deploy Key Vault within VNet</li> <li>Firewall Rules: Configure Key Vault firewall rules</li> <li>Network Security Groups: Implement network-level controls</li> </ol>"},{"location":"providers/azure/#key-vault-security","title":"Key Vault Security","text":"<ol> <li>Soft Delete: Enable soft delete for accidental deletion protection</li> <li>Purge Protection: Enable purge protection for critical vaults</li> <li>Access Logging: Enable diagnostic logging</li> <li>RBAC: Use RBAC instead of access policies for new deployments</li> </ol>"},{"location":"providers/azure/#monitoring-and-auditing","title":"Monitoring and Auditing","text":"<ol> <li> <p>Diagnostic Logs:    <pre><code>az monitor diagnostic-settings create \\\n  --name \"keyvault-logs\" \\\n  --resource \"/subscriptions/{sub}/resourceGroups/{rg}/providers/Microsoft.KeyVault/vaults/{vault}\" \\\n  --logs '[{\"category\":\"AuditEvent\",\"enabled\":true}]' \\\n  --workspace \"/subscriptions/{sub}/resourceGroups/{rg}/providers/Microsoft.OperationalInsights/workspaces/{workspace}\"\n</code></pre></p> </li> <li> <p>Azure Monitor: Set up alerts for unusual access patterns</p> </li> <li>Security Center: Monitor Key Vault recommendations</li> <li>Sentinel: Integrate with Azure Sentinel for security analytics</li> </ol>"},{"location":"providers/azure/#integration-examples","title":"Integration Examples","text":""},{"location":"providers/azure/#azure-container-instances","title":"Azure Container Instances","text":"<pre><code>apiVersion: 2019-12-01\nlocation: eastus\nname: mlflow-app\nproperties:\n  containers:\n  - name: mlflow-app\n    properties:\n      image: mlflow-app:latest\n      environmentVariables:\n      - name: MLFLOW_AZURE_KEY_VAULT_URL\n        value: https://prod-vault.vault.azure.net/\n      - name: MLFLOW_AZURE_SECRET_NAME\n        value: mlflow-production-auth\n      - name: MLFLOW_SECRETS_AUTH_ENABLE\n        value: azure-key-vault\n      - name: MLFLOW_SECRETS_ALLOWED_HOSTS\n        value: mlflow.company.com\n  identity:\n    type: UserAssigned\n    userAssignedIdentities:\n      /subscriptions/{sub}/resourceGroups/{rg}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/mlflow-identity: {}\n</code></pre>"},{"location":"providers/azure/#azure-app-service","title":"Azure App Service","text":"<pre><code>#!/bin/bash\n# Configure App Service with managed identity\n\n# Enable system-assigned managed identity\naz webapp identity assign \\\n  --name \"mlflow-app\" \\\n  --resource-group \"my-rg\"\n\n# Configure environment variables\naz webapp config appsettings set \\\n  --name \"mlflow-app\" \\\n  --resource-group \"my-rg\" \\\n  --settings \\\n    MLFLOW_AZURE_KEY_VAULT_URL=\"https://prod-vault.vault.azure.net/\" \\\n    MLFLOW_AZURE_SECRET_NAME=\"mlflow-production-auth\" \\\n    MLFLOW_SECRETS_AUTH_ENABLE=\"azure-key-vault\" \\\n    MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com\"\n</code></pre>"},{"location":"providers/azure/#azure-functions","title":"Azure Functions","text":"<pre><code>{\n  \"version\": \"2.0\",\n  \"functionApp\": {\n    \"id\": \"/subscriptions/{sub}/resourceGroups/{rg}/providers/Microsoft.Web/sites/mlflow-functions\"\n  },\n  \"managedServiceIdentity\": {\n    \"type\": \"SystemAssigned\"\n  },\n  \"applicationSettings\": {\n    \"MLFLOW_AZURE_KEY_VAULT_URL\": \"https://prod-vault.vault.azure.net/\",\n    \"MLFLOW_AZURE_SECRET_NAME\": \"mlflow-production-auth\",\n    \"MLFLOW_SECRETS_AUTH_ENABLE\": \"azure-key-vault\",\n    \"MLFLOW_SECRETS_ALLOWED_HOSTS\": \"mlflow.company.com\"\n  }\n}\n</code></pre>"},{"location":"providers/azure/#azure-kubernetes-service-aks","title":"Azure Kubernetes Service (AKS)","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: mlflow-app\n  labels:\n    aadpodidbinding: mlflow-identity\nspec:\n  containers:\n  - name: mlflow-app\n    image: mlflow-app:latest\n    env:\n    - name: MLFLOW_AZURE_KEY_VAULT_URL\n      value: \"https://prod-vault.vault.azure.net/\"\n    - name: MLFLOW_AZURE_SECRET_NAME\n      value: \"mlflow-production-auth\"\n    - name: MLFLOW_SECRETS_AUTH_ENABLE\n      value: \"azure-key-vault\"\n    - name: MLFLOW_SECRETS_ALLOWED_HOSTS\n      value: \"mlflow.company.com\"\n---\napiVersion: \"aadpodidentity.k8s.io/v1\"\nkind: AzureIdentityBinding\nmetadata:\n  name: mlflow-identity-binding\nspec:\n  AzureIdentity: mlflow-identity\n  Selector: mlflow-identity\n</code></pre>"},{"location":"providers/azure/#terraform-configuration","title":"Terraform Configuration","text":"<pre><code># Create Key Vault\nresource \"azurerm_key_vault\" \"mlflow\" {\n  name                = \"mlflow-vault\"\n  location            = azurerm_resource_group.main.location\n  resource_group_name = azurerm_resource_group.main.name\n  tenant_id          = data.azurerm_client_config.current.tenant_id\n  sku_name           = \"standard\"\n\n  enable_rbac_authorization = true\n\n  tags = {\n    Environment = \"production\"\n    Application = \"mlflow\"\n  }\n}\n\n# Create secret\nresource \"azurerm_key_vault_secret\" \"mlflow_auth\" {\n  name         = \"mlflow-production-auth\"\n  value        = jsonencode({\n    token = var.mlflow_token\n  })\n  key_vault_id = azurerm_key_vault.mlflow.id\n\n  tags = {\n    Environment = \"production\"\n    Application = \"mlflow\"\n  }\n}\n\n# Create managed identity\nresource \"azurerm_user_assigned_identity\" \"mlflow\" {\n  name                = \"mlflow-identity\"\n  location            = azurerm_resource_group.main.location\n  resource_group_name = azurerm_resource_group.main.name\n}\n\n# Assign RBAC role\nresource \"azurerm_role_assignment\" \"mlflow_keyvault\" {\n  scope                = azurerm_key_vault.mlflow.id\n  role_definition_name = \"Key Vault Secrets User\"\n  principal_id         = azurerm_user_assigned_identity.mlflow.principal_id\n}\n</code></pre>"},{"location":"providers/azure/#next-steps","title":"Next Steps","text":"<ul> <li>HashiCorp Vault Provider - Vault-specific configuration</li> <li>AWS Secrets Manager Provider - AWS-specific configuration</li> <li>Configuration Reference - Complete environment variable reference</li> <li>Troubleshooting Guide - General troubleshooting information</li> </ul>"},{"location":"providers/vault/","title":"HashiCorp Vault Provider","text":"<p>The Vault provider enables MLflow Secrets Auth to retrieve credentials from HashiCorp Vault using either token-based or AppRole authentication methods. It supports both KV v1 and KV v2 secret engines with automatic detection and fallback.</p>"},{"location":"providers/vault/#overview","title":"Overview","text":"<p>HashiCorp Vault is a secrets management solution that provides secure storage, dynamic secrets, and data encryption. The MLflow Secrets Auth Vault provider integrates seamlessly with Vault's authentication and authorization model.</p>"},{"location":"providers/vault/#features","title":"Features","text":"<ul> <li>Multiple Authentication Methods: Token and AppRole support</li> <li>KV Engine Support: Automatic detection of KV v1 and KV v2 engines</li> <li>Graceful Fallback: Falls back from KV v2 to KV v1 automatically</li> <li>Path Flexibility: Supports various secret path formats</li> <li>Enterprise Features: Namespace support for Vault Enterprise</li> <li>Connection Reuse: Efficient client connection management</li> </ul>"},{"location":"providers/vault/#requirements","title":"Requirements","text":"<ul> <li>Vault Server: HashiCorp Vault 1.0+ (KV v2 requires 1.0+)</li> <li>Network Access: HTTPS connectivity to Vault server</li> <li>Authentication: Valid Vault token or AppRole credentials</li> <li>Permissions: Read access to the specified secret path</li> <li>Python Package: <code>hvac&gt;=2.3.0</code> (installed with <code>pip install mlflow-secrets-auth[vault]</code>)</li> </ul>"},{"location":"providers/vault/#installation","title":"Installation","text":""},{"location":"providers/vault/#basic-installation","title":"Basic Installation","text":"<pre><code>pip install mlflow-secrets-auth[vault]\n</code></pre>"},{"location":"providers/vault/#verify-installation","title":"Verify Installation","text":"<pre><code>python -c \"import hvac; print('\u2713 Vault support available')\"\n</code></pre>"},{"location":"providers/vault/#authentication-methods","title":"Authentication Methods","text":""},{"location":"providers/vault/#token-authentication","title":"Token Authentication","text":"<p>Token authentication is the simplest method for getting started with Vault.</p>"},{"location":"providers/vault/#configuration","title":"Configuration","text":"<pre><code>export VAULT_ADDR=\"https://vault.company.com\"\nexport VAULT_TOKEN=\"hvs.XXXXXXXXXXXXXXXX\"\nexport MLFLOW_VAULT_SECRET_PATH=\"secret/mlflow/auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"vault\"\n</code></pre>"},{"location":"providers/vault/#token-requirements","title":"Token Requirements","text":"<ul> <li>Valid Token: Must be unexpired and have necessary permissions</li> <li>Read Permissions: Access to the secret path</li> <li>Policy Assignment: Token must be associated with appropriate policies</li> </ul>"},{"location":"providers/vault/#example-vault-policy","title":"Example Vault Policy","text":"<pre><code># Policy: mlflow-secrets-auth\npath \"secret/data/mlflow/*\" {\n  capabilities = [\"read\"]\n}\n\npath \"secret/metadata/mlflow/*\" {\n  capabilities = [\"read\"]\n}\n</code></pre>"},{"location":"providers/vault/#approle-authentication","title":"AppRole Authentication","text":"<p>AppRole authentication is recommended for automated systems and production deployments.</p>"},{"location":"providers/vault/#configuration_1","title":"Configuration","text":"<pre><code>export VAULT_ADDR=\"https://vault.company.com\"\nexport VAULT_ROLE_ID=\"role-id-value\"\nexport VAULT_SECRET_ID=\"secret-id-value\"\nexport MLFLOW_VAULT_SECRET_PATH=\"secret/mlflow/auth\"\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"vault\"\n</code></pre>"},{"location":"providers/vault/#approle-setup","title":"AppRole Setup","text":"<ol> <li> <p>Create AppRole:    <pre><code>vault auth enable approle\n\nvault write auth/approle/role/mlflow-secrets-auth \\\n  token_policies=\"mlflow-secrets-auth\" \\\n  token_ttl=1h \\\n  token_max_ttl=4h\n</code></pre></p> </li> <li> <p>Get Role ID:    <pre><code>vault read auth/approle/role/mlflow-secrets-auth/role-id\n</code></pre></p> </li> <li> <p>Generate Secret ID:    <pre><code>vault write -f auth/approle/role/mlflow-secrets-auth/secret-id\n</code></pre></p> </li> </ol>"},{"location":"providers/vault/#approle-best-practices","title":"AppRole Best Practices","text":"<ul> <li>Separate Roles: Use different AppRoles per environment</li> <li>TTL Management: Configure appropriate token TTLs</li> <li>Secret ID Rotation: Regularly rotate Secret IDs</li> <li>Response Wrapping: Use response wrapping for Secret ID distribution</li> </ul>"},{"location":"providers/vault/#secret-path-configuration","title":"Secret Path Configuration","text":""},{"location":"providers/vault/#kv-v2-paths-recommended","title":"KV v2 Paths (Recommended)","text":"<p>KV v2 is the default and recommended secret engine for new Vault installations.</p>"},{"location":"providers/vault/#standard-kv-v2-path","title":"Standard KV v2 Path","text":"<pre><code># Secret stored at: secret/data/mlflow/auth\nexport MLFLOW_VAULT_SECRET_PATH=\"secret/mlflow/auth\"\n</code></pre>"},{"location":"providers/vault/#explicit-kv-v2-path","title":"Explicit KV v2 Path","text":"<pre><code># Explicit KV v2 path\nexport MLFLOW_VAULT_SECRET_PATH=\"secret/data/mlflow/auth\"\n</code></pre>"},{"location":"providers/vault/#custom-mount-path","title":"Custom Mount Path","text":"<pre><code># Custom mount point\nexport MLFLOW_VAULT_SECRET_PATH=\"kv-v2/mlflow/auth\"\n</code></pre>"},{"location":"providers/vault/#kv-v1-paths-legacy","title":"KV v1 Paths (Legacy)","text":"<p>KV v1 is supported for backward compatibility with older Vault installations.</p>"},{"location":"providers/vault/#kv-v1-configuration","title":"KV v1 Configuration","text":"<pre><code># KV v1 path (legacy)\nexport MLFLOW_VAULT_SECRET_PATH=\"secret/mlflow/auth\"\n</code></pre>"},{"location":"providers/vault/#path-resolution-logic","title":"Path Resolution Logic","text":"<p>The provider automatically detects and handles different path formats:</p> <ol> <li>Try KV v2: Attempt to read using KV v2 API</li> <li>Fallback to KV v1: If KV v2 fails, try KV v1 API</li> <li>Path Normalization: Automatically adjust paths for each API version</li> </ol> <pre><code># Internal path resolution\nif secret_path.startswith(\"secret/data/\"):\n    # Explicit KV v2 path\n    kv2_path = secret_path\nelse:\n    # Convert to KV v2 format\n    kv2_path = secret_path.replace(\"secret/\", \"secret/data/\", 1)\n\n# Try KV v2 first\ntry:\n    response = client.secrets.kv.v2.read_secret_version(path=kv2_relative_path)\nexcept:\n    # Fallback to KV v1\n    response = client.secrets.kv.v1.read_secret(path=kv1_relative_path)\n</code></pre>"},{"location":"providers/vault/#secret-format","title":"Secret Format","text":""},{"location":"providers/vault/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<p>Store the authentication token in a <code>token</code> field:</p> <pre><code># Store secret in Vault\nvault kv put secret/mlflow/auth token=\"your-mlflow-bearer-token\"\n</code></pre> <p>JSON Structure: <pre><code>{\n  \"token\": \"your-mlflow-bearer-token\"\n}\n</code></pre></p>"},{"location":"providers/vault/#basic-authentication","title":"Basic Authentication","text":"<p>Store username and password for Basic authentication:</p> <pre><code># Store secret in Vault\nvault kv put secret/mlflow/auth \\\n  username=\"mlflow-user\" \\\n  password=\"secure-password\"\n</code></pre> <p>JSON Structure: <pre><code>{\n  \"username\": \"mlflow-user\", \n  \"password\": \"secure-password\"\n}\n</code></pre></p>"},{"location":"providers/vault/#custom-fields","title":"Custom Fields","text":"<p>Include additional metadata if needed:</p> <pre><code># Store secret with metadata\nvault kv put secret/mlflow/auth \\\n  token=\"bearer-token\" \\\n  description=\"MLflow production auth\" \\\n  created_by=\"admin\" \\\n  environment=\"production\"\n</code></pre> <p>JSON Structure: <pre><code>{\n  \"token\": \"bearer-token\",\n  \"description\": \"MLflow production auth\",\n  \"created_by\": \"admin\",\n  \"environment\": \"production\"\n}\n</code></pre></p>"},{"location":"providers/vault/#configuration-reference","title":"Configuration Reference","text":""},{"location":"providers/vault/#required-environment-variables","title":"Required Environment Variables","text":"Variable Description Example <code>VAULT_ADDR</code> Vault server URL <code>https://vault.company.com</code> <code>MLFLOW_VAULT_SECRET_PATH</code> Path to secret in Vault <code>secret/mlflow/auth</code>"},{"location":"providers/vault/#authentication-variables","title":"Authentication Variables","text":""},{"location":"providers/vault/#token-authentication_1","title":"Token Authentication","text":"Variable Description Example <code>VAULT_TOKEN</code> Vault authentication token <code>hvs.XXXXXXXXXXXXXXXX</code>"},{"location":"providers/vault/#approle-authentication_1","title":"AppRole Authentication","text":"Variable Description Example <code>VAULT_ROLE_ID</code> AppRole role identifier <code>role-id-value</code> <code>VAULT_SECRET_ID</code> AppRole secret identifier <code>secret-id-value</code>"},{"location":"providers/vault/#optional-configuration","title":"Optional Configuration","text":"Variable Default Description Example <code>MLFLOW_VAULT_AUTH_MODE</code> <code>bearer</code> Authentication mode <code>bearer</code>, <code>basic</code> <code>MLFLOW_VAULT_TTL_SEC</code> <code>300</code> Cache TTL in seconds <code>600</code> <code>VAULT_NAMESPACE</code> None Vault namespace (Enterprise) <code>production</code> <code>VAULT_SKIP_VERIFY</code> <code>false</code> Skip TLS verification <code>true</code> (not recommended)"},{"location":"providers/vault/#examples","title":"Examples","text":""},{"location":"providers/vault/#development-environment","title":"Development Environment","text":"<pre><code>#!/bin/bash\n# Development setup with Vault\n\n# Vault configuration\nexport VAULT_ADDR=\"http://localhost:8200\"\nexport VAULT_TOKEN=\"dev-only-token\"\n\n# MLflow Secrets Auth configuration  \nexport MLFLOW_VAULT_SECRET_PATH=\"secret/dev/mlflow\"\nexport MLFLOW_VAULT_AUTH_MODE=\"bearer\"\nexport MLFLOW_VAULT_TTL_SEC=\"60\"  # Short TTL for development\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"vault\"\n\n# Security configuration (permissive for development)\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"localhost,127.0.0.1,*.local\"\nexport MLFLOW_SECRETS_LOG_LEVEL=\"DEBUG\"\n\n# Store development secret\nvault kv put secret/dev/mlflow token=\"dev-token-123\"\n\n# Test configuration\nmlflow-secrets-auth doctor --dry-run http://localhost:5000\n</code></pre>"},{"location":"providers/vault/#production-environment","title":"Production Environment","text":"<pre><code>#!/bin/bash  \n# Production setup with AppRole\n\n# Vault configuration\nexport VAULT_ADDR=\"https://vault.company.com\"\nexport VAULT_ROLE_ID=\"${VAULT_ROLE_ID}\"  # From secure storage\nexport VAULT_SECRET_ID=\"${VAULT_SECRET_ID}\"  # From secure storage\n\n# MLflow Secrets Auth configuration\nexport MLFLOW_VAULT_SECRET_PATH=\"secret/prod/mlflow/auth\"\nexport MLFLOW_VAULT_AUTH_MODE=\"bearer\"\nexport MLFLOW_VAULT_TTL_SEC=\"900\"  # 15 minutes for production\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"vault\"\n\n# Security configuration\nexport MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com\"\nexport MLFLOW_SECRETS_LOG_LEVEL=\"INFO\"\n\n# Validate configuration\nmlflow-secrets-auth doctor\n</code></pre>"},{"location":"providers/vault/#multi-environment-setup","title":"Multi-Environment Setup","text":"<pre><code>#!/bin/bash\n# Environment-specific configuration\n\nENVIRONMENT=${ENVIRONMENT:-development}\n\ncase $ENVIRONMENT in\n  development)\n    export VAULT_ADDR=\"http://localhost:8200\"\n    export VAULT_TOKEN=\"dev-token\"\n    export MLFLOW_VAULT_SECRET_PATH=\"secret/dev/mlflow\"\n    export MLFLOW_VAULT_TTL_SEC=\"60\"\n    export MLFLOW_SECRETS_ALLOWED_HOSTS=\"localhost,*.local\"\n    ;;\n\n  staging)\n    export VAULT_ADDR=\"https://vault-staging.company.com\"\n    export VAULT_ROLE_ID=\"${STAGING_VAULT_ROLE_ID}\"\n    export VAULT_SECRET_ID=\"${STAGING_VAULT_SECRET_ID}\"\n    export MLFLOW_VAULT_SECRET_PATH=\"secret/staging/mlflow/auth\"\n    export MLFLOW_VAULT_TTL_SEC=\"300\"\n    export MLFLOW_SECRETS_ALLOWED_HOSTS=\"*.staging.company.com\"\n    ;;\n\n  production)\n    export VAULT_ADDR=\"https://vault.company.com\"\n    export VAULT_ROLE_ID=\"${PROD_VAULT_ROLE_ID}\"\n    export VAULT_SECRET_ID=\"${PROD_VAULT_SECRET_ID}\"\n    export MLFLOW_VAULT_SECRET_PATH=\"secret/prod/mlflow/auth\"\n    export MLFLOW_VAULT_TTL_SEC=\"900\"\n    export MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.company.com\"\n    ;;\nesac\n\nexport MLFLOW_SECRETS_AUTH_ENABLE=\"vault\"\nmlflow-secrets-auth doctor\n</code></pre>"},{"location":"providers/vault/#vault-enterprise-features","title":"Vault Enterprise Features","text":""},{"location":"providers/vault/#namespace-support","title":"Namespace Support","text":"<p>Vault Enterprise supports namespaces for multi-tenancy:</p> <pre><code># Configure namespace\nexport VAULT_NAMESPACE=\"production\"\nexport VAULT_ADDR=\"https://vault.company.com\"\nexport VAULT_TOKEN=\"hvs.XXXXXXXXXXXXXXXX\"\nexport MLFLOW_VAULT_SECRET_PATH=\"secret/mlflow/auth\"\n</code></pre>"},{"location":"providers/vault/#performance-standby","title":"Performance Standby","text":"<p>When using Vault Enterprise with Performance Standby:</p> <pre><code># Primary cluster\nexport VAULT_ADDR=\"https://vault-primary.company.com\"\n\n# Performance standby (read-only operations)\nexport VAULT_ADDR=\"https://vault-standby.company.com\"\n</code></pre>"},{"location":"providers/vault/#troubleshooting","title":"Troubleshooting","text":""},{"location":"providers/vault/#common-issues","title":"Common Issues","text":""},{"location":"providers/vault/#authentication-failures","title":"Authentication Failures","text":"<p>Problem: <code>Vault authentication failed</code></p> <p>Solutions: 1. Check Token Validity:    <pre><code>vault token lookup $VAULT_TOKEN\n</code></pre></p> <ol> <li> <p>Verify AppRole Credentials:    <pre><code>vault write auth/approle/login \\\n  role_id=\"$VAULT_ROLE_ID\" \\\n  secret_id=\"$VAULT_SECRET_ID\"\n</code></pre></p> </li> <li> <p>Check Token Permissions:    <pre><code>vault token capabilities $VAULT_TOKEN secret/data/mlflow/auth\n</code></pre></p> </li> </ol>"},{"location":"providers/vault/#path-not-found","title":"Path Not Found","text":"<p>Problem: <code>Secret not found at path</code></p> <p>Solutions: 1. Verify Secret Exists:    <pre><code>vault kv get secret/mlflow/auth\n</code></pre></p> <ol> <li> <p>Check Path Format:    <pre><code># KV v2\nvault kv get -mount=secret mlflow/auth\n\n# KV v1\nvault read secret/mlflow/auth\n</code></pre></p> </li> <li> <p>List Available Paths:    <pre><code>vault kv list secret/\n</code></pre></p> </li> </ol>"},{"location":"providers/vault/#network-connectivity","title":"Network Connectivity","text":"<p>Problem: <code>Connection timeout to vault.company.com</code></p> <p>Solutions: 1. Test Network Connectivity:    <pre><code>curl -k https://vault.company.com/v1/sys/health\n</code></pre></p> <ol> <li> <p>Check DNS Resolution:    <pre><code>nslookup vault.company.com\n</code></pre></p> </li> <li> <p>Verify TLS Configuration:    <pre><code>openssl s_client -connect vault.company.com:443\n</code></pre></p> </li> </ol>"},{"location":"providers/vault/#debug-mode","title":"Debug Mode","text":"<p>Enable debug logging for detailed troubleshooting:</p> <pre><code>export MLFLOW_SECRETS_LOG_LEVEL=\"DEBUG\"\nmlflow-secrets-auth doctor\n</code></pre> <p>Debug Output Includes: - Vault client configuration - Authentication method selection - KV engine detection attempts - Path resolution logic - Secret parsing details</p>"},{"location":"providers/vault/#cli-diagnostics","title":"CLI Diagnostics","text":"<p>Use the CLI for comprehensive diagnostics:</p> <pre><code># Basic configuration check\nmlflow-secrets-auth info\n\n# Full diagnostic with Vault connectivity\nmlflow-secrets-auth doctor\n\n# Test against MLflow server\nmlflow-secrets-auth doctor --dry-run https://mlflow.company.com\n</code></pre>"},{"location":"providers/vault/#security-considerations","title":"Security Considerations","text":""},{"location":"providers/vault/#token-security","title":"Token Security","text":"<ol> <li>Token Rotation: Regularly rotate Vault tokens</li> <li>TTL Management: Use appropriate token TTLs</li> <li>Least Privilege: Grant minimal required permissions</li> <li>Secure Storage: Store tokens securely (environment variables, secret managers)</li> </ol>"},{"location":"providers/vault/#network-security","title":"Network Security","text":"<ol> <li>TLS Encryption: Always use HTTPS for Vault communication</li> <li>Certificate Validation: Avoid <code>VAULT_SKIP_VERIFY=true</code> in production</li> <li>Network Segmentation: Restrict network access to Vault</li> <li>Firewall Rules: Implement appropriate firewall restrictions</li> </ol>"},{"location":"providers/vault/#audit-and-monitoring","title":"Audit and Monitoring","text":"<ol> <li> <p>Enable Audit Logging:    <pre><code>vault audit enable file file_path=/vault/logs/audit.log\n</code></pre></p> </li> <li> <p>Monitor Access Patterns: Review Vault audit logs regularly</p> </li> <li>Alert on Failures: Set up alerts for authentication failures</li> <li>Track Secret Access: Monitor secret read operations</li> </ol>"},{"location":"providers/vault/#performance-optimization","title":"Performance Optimization","text":""},{"location":"providers/vault/#connection-reuse","title":"Connection Reuse","text":"<p>The provider automatically reuses Vault client connections:</p> <pre><code># Connection pooling is handled automatically\n# Clients are cached and reused across requests\n</code></pre>"},{"location":"providers/vault/#caching-strategy","title":"Caching Strategy","text":"<p>Configure appropriate TTL for your use case:</p> <pre><code># High-frequency access: longer TTL\nMLFLOW_VAULT_TTL_SEC=1800  # 30 minutes\n\n# Security-sensitive: shorter TTL  \nMLFLOW_VAULT_TTL_SEC=300   # 5 minutes\n\n# Development: very short TTL\nMLFLOW_VAULT_TTL_SEC=60    # 1 minute\n</code></pre>"},{"location":"providers/vault/#vault-performance","title":"Vault Performance","text":"<ol> <li>Use Vault Performance Standby: For read-heavy workloads</li> <li>Optimize Vault Policies: Use specific paths instead of wildcards</li> <li>Monitor Vault Metrics: Track response times and error rates</li> <li>Scale Vault Cluster: Add nodes for high availability and performance</li> </ol>"},{"location":"providers/vault/#migration-and-upgrades","title":"Migration and Upgrades","text":""},{"location":"providers/vault/#kv-v1-to-kv-v2-migration","title":"KV v1 to KV v2 Migration","text":"<p>When migrating from KV v1 to KV v2:</p> <ol> <li> <p>Enable KV v2:    <pre><code>vault secrets enable -path=secret kv-v2\n</code></pre></p> </li> <li> <p>Migrate Secrets:    <pre><code># Read from KV v1\nvault read secret/mlflow/auth\n\n# Write to KV v2\nvault kv put secret/mlflow/auth token=\"value\"\n</code></pre></p> </li> <li> <p>Update Configuration: No changes needed - provider auto-detects</p> </li> </ol>"},{"location":"providers/vault/#vault-version-compatibility","title":"Vault Version Compatibility","text":"Vault Version KV v1 KV v2 Notes 0.10+ \u2705 \u274c KV v1 only 1.0+ \u2705 \u2705 Both supported 1.1+ \u2705 \u2705 Recommended"},{"location":"providers/vault/#integration-examples","title":"Integration Examples","text":""},{"location":"providers/vault/#docker-deployment","title":"Docker Deployment","text":"<pre><code>FROM python:3.11-slim\n\n# Install MLflow Secrets Auth with Vault support\nRUN pip install mlflow-secrets-auth[vault]\n\n# Copy application\nCOPY . /app\nWORKDIR /app\n\n# Environment variables will be provided at runtime\nENV VAULT_ADDR=\"\"\nENV VAULT_TOKEN=\"\"\nENV MLFLOW_VAULT_SECRET_PATH=\"\"\nENV MLFLOW_SECRETS_AUTH_ENABLE=\"vault\"\n\nCMD [\"python\", \"app.py\"]\n</code></pre>"},{"location":"providers/vault/#kubernetes-deployment","title":"Kubernetes Deployment","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mlflow-app\nspec:\n  template:\n    spec:\n      containers:\n      - name: mlflow-app\n        image: mlflow-app:latest\n        env:\n        - name: VAULT_ADDR\n          value: \"https://vault.company.com\"\n        - name: VAULT_ROLE_ID\n          valueFrom:\n            secretKeyRef:\n              name: vault-auth\n              key: role-id\n        - name: VAULT_SECRET_ID\n          valueFrom:\n            secretKeyRef:\n              name: vault-auth\n              key: secret-id\n        - name: MLFLOW_VAULT_SECRET_PATH\n          value: \"secret/mlflow/auth\"\n        - name: MLFLOW_SECRETS_AUTH_ENABLE\n          value: \"vault\"\n</code></pre>"},{"location":"providers/vault/#cicd-pipeline","title":"CI/CD Pipeline","text":"<pre><code># GitHub Actions example\nname: MLflow Pipeline\non: [push]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n\n    - name: Setup Vault Auth\n      env:\n        VAULT_ADDR: ${{ secrets.VAULT_ADDR }}\n        VAULT_ROLE_ID: ${{ secrets.VAULT_ROLE_ID }}\n        VAULT_SECRET_ID: ${{ secrets.VAULT_SECRET_ID }}\n        MLFLOW_VAULT_SECRET_PATH: \"secret/ci/mlflow/auth\"\n        MLFLOW_SECRETS_AUTH_ENABLE: \"vault\"\n      run: |\n        pip install mlflow-secrets-auth[vault]\n        mlflow-secrets-auth doctor\n        python test_mlflow_integration.py\n</code></pre>"},{"location":"providers/vault/#next-steps","title":"Next Steps","text":"<ul> <li>AWS Secrets Manager Provider - AWS-specific configuration</li> <li>Azure Key Vault Provider - Azure-specific configuration  </li> <li>Configuration Reference - Complete environment variable reference</li> <li>Troubleshooting Guide - General troubleshooting information</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>mlflow_secrets_auth<ul> <li>base</li> <li>cache</li> <li>cli</li> <li>config</li> <li>providers<ul> <li>aws_secrets_manager</li> <li>azure_key_vault</li> <li>vault</li> </ul> </li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/mlflow_secrets_auth/__init__/","title":"mlflow_secrets_auth","text":""},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth","title":"<code>mlflow_secrets_auth</code>","text":"<p>MLflow Secrets-Backed RequestAuthProvider.</p> Public API <ul> <li>SecretsAuthProviderFactory: Factory provider that delegates to the first   enabled backend among Vault, AWS Secrets Manager, and Azure Key Vault.</li> <li>version: Package version string (best-effort).</li> </ul> <p>This module also exposes a best-effort <code>__version__</code> so the CLI <code>info</code> command can display a version even in editable installs where distribution metadata may be unavailable.</p>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.SecretsAuthProviderFactory","title":"<code>SecretsAuthProviderFactory()</code>","text":"<p>               Bases: <code>SecretsBackedAuthProvider</code></p> <p>Factory that selects and delegates to an enabled provider.</p> Priority order <p>1) HashiCorp Vault 2) AWS Secrets Manager 3) Azure Key Vault</p> <p>If no provider is enabled or instantiation fails, this factory behaves as \"disabled\" (e.g., returns defaults/None) while preserving MLflow semantics.</p> <p>Attributes:</p> Name Type Description <code>_actual_provider</code> <code>SecretsBackedAuthProvider | None</code> <p>The lazily-instantiated concrete provider, if any.</p> <p>Initialize the factory with a default TTL.</p> Source code in <code>src/mlflow_secrets_auth/__init__.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the factory with a default TTL.\"\"\"\n    super().__init__(\"mlflow_secrets_auth\", default_ttl=300)\n    self._actual_provider: SecretsBackedAuthProvider | None = None\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.base","title":"<code>base</code>","text":"<p>Base classes and abstractions for MLflow secrets-backed authentication providers.</p> This module defines <ul> <li>Lightweight <code>requests.auth.AuthBase</code> implementations for Bearer, Basic, and custom-header auth.</li> <li><code>SecretsBackedAuthProvider</code>, an abstract base for MLflow <code>RequestAuthProvider</code>s that obtain   credentials from secret managers and cache them with a TTL.</li> </ul> Design notes <ul> <li>Providers implement <code>_fetch_secret</code>, <code>_get_cache_key</code>, <code>_get_auth_mode</code>, and <code>_get_ttl</code>.</li> <li>Caching is delegated to <code>cached_fetch</code> and TTL validation to <code>validate_ttl</code>.</li> <li>Secrets are parsed centrally via <code>parse_secret_json</code> and must resolve to either:<ul> <li>{\"token\": \"\"}  OR <li>{\"username\": \"...\", \"password\": \"...\"}</li> <li>Header name can be configured; \"Authorization\" is normalized to the canonical header.</li> <p>All logging goes through <code>safe_log</code> to avoid leaking sensitive values.</p>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.base.BasicAuth","title":"<code>BasicAuth(username, password, header_name='Authorization')</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>HTTP Basic authentication for <code>requests</code>.</p> <p>If a non-standard header is configured, the base64 credentials are put into that header.</p> <p>Attributes:</p> Name Type Description <code>username</code> <p>Basic auth username.</p> <code>password</code> <p>Basic auth password.</p> <code>header_name</code> <p>Target header (defaults to \"Authorization\").</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def __init__(self, username: str, password: str, header_name: str = \"Authorization\") -&gt; None:\n    self.username = username\n    self.password = password\n    self.header_name = header_name\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.base.BasicAuth.__call__","title":"<code>__call__(r)</code>","text":"<p>Attach the basic auth header to the outgoing request.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def __call__(self, r: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n    \"\"\"Attach the basic auth header to the outgoing request.\"\"\"\n    creds = f\"{self.username}:{self.password}\".encode()\n    r.headers[self.header_name] = f\"Basic {base64.b64encode(creds).decode()}\"\n    return r\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.base.BearerAuth","title":"<code>BearerAuth(token, header_name='Authorization')</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Bearer token authentication for <code>requests</code>.</p> <p>The token is injected as: <code>&lt;header_name&gt;: Bearer &lt;token&gt;</code></p> <p>Attributes:</p> Name Type Description <code>token</code> <p>Opaque bearer token.</p> <code>header_name</code> <p>Target header (defaults to \"Authorization\").</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def __init__(self, token: str, header_name: str = \"Authorization\") -&gt; None:\n    self.token = token\n    self.header_name = header_name\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.base.BearerAuth.__call__","title":"<code>__call__(r)</code>","text":"<p>Attach the bearer token header to the outgoing request.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def __call__(self, r: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n    \"\"\"Attach the bearer token header to the outgoing request.\"\"\"\n    r.headers[self.header_name] = f\"Bearer {self.token}\"\n    return r\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.base.CustomHeaderAuth","title":"<code>CustomHeaderAuth(token, header_name)</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Custom header authentication for <code>requests</code> (token placed as-is).</p> <p>Attributes:</p> Name Type Description <code>token</code> <p>Opaque token to inject.</p> <code>header_name</code> <p>Target header.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def __init__(self, token: str, header_name: str) -&gt; None:\n    self.token = token\n    self.header_name = header_name\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.base.CustomHeaderAuth.__call__","title":"<code>__call__(r)</code>","text":"<p>Attach the opaque token to the configured header.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def __call__(self, r: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n    \"\"\"Attach the opaque token to the configured header.\"\"\"\n    r.headers[self.header_name] = self.token\n    return r\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.base.SecretData","title":"<code>SecretData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Structured representation of parsed secret material.</p>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.base.SecretsBackedAuthProvider","title":"<code>SecretsBackedAuthProvider(provider_name, default_ttl=300)</code>","text":"<p>               Bases: <code>RequestAuthProvider</code>, <code>ABC</code></p> <p>Abstract base class for secrets-backed MLflow auth providers.</p> <p>Subclasses implement secret retrieval for a specific backend (e.g., Vault, AWS, Azure) and supply configuration inputs (cache key, auth mode, TTL).</p> This class handles <ul> <li>Provider enablement checks.</li> <li>Host allowlisting for <code>get_request_auth</code>.</li> <li>Cache + TTL validation.</li> <li>Secret parsing and Auth object construction.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>Stable identifier used for logging and configuration.</p> required <code>default_ttl</code> <code>int</code> <p>Fallback TTL in seconds if configured TTL is invalid.</p> <code>300</code> <p>Attributes:</p> Name Type Description <code>provider_name</code> <p>Provider identifier.</p> <code>default_ttl</code> <p>Default TTL for cache.</p> <code>logger</code> <p>Namespaced logger instance.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def __init__(self, provider_name: str, default_ttl: int = 300) -&gt; None:\n    self.provider_name = provider_name\n    self.default_ttl = default_ttl\n    self.logger = setup_logger(f\"mlflow_secrets_auth.{provider_name}\")\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.base.SecretsBackedAuthProvider.get_auth","title":"<code>get_auth()</code>","text":"<p>Return a <code>requests</code> Auth object (no URL filtering).</p> <p>This method is used by MLflow when a per-request URL is not available.</p> <p>Returns:</p> Type Description <code>AuthBase | None</code> <p>A <code>requests.auth.AuthBase</code> instance or None when disabled/unavailable.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def get_auth(self) -&gt; requests.auth.AuthBase | None:\n    \"\"\"Return a `requests` Auth object (no URL filtering).\n\n    This method is used by MLflow when a per-request URL is not available.\n\n    Returns:\n        A `requests.auth.AuthBase` instance or None when disabled/unavailable.\n\n    \"\"\"\n    if not self._is_enabled():\n        safe_log(self.logger, logging.DEBUG, f\"{self.provider_name} provider not enabled\")\n        return None\n\n    try:\n        secret_data = self._fetch_secret_cached()\n        return None if not secret_data else self._create_auth(secret_data)\n    except Exception as e:  # pragma: no cover \u2014 defensive guard\n        safe_log(self.logger, logging.ERROR, f\"Unexpected error in {self.provider_name}: {e}\")\n        return None\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.base.SecretsBackedAuthProvider.get_name","title":"<code>get_name()</code>","text":"<p>Return the provider name (instance method in recent MLflow versions).</p> <p>Returns:</p> Type Description <code>str</code> <p>Provider name for MLflow plugin discovery.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"Return the provider name (instance method in recent MLflow versions).\n\n    Returns:\n        Provider name for MLflow plugin discovery.\n\n    \"\"\"\n    return self.provider_name\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.base.SecretsBackedAuthProvider.get_request_auth","title":"<code>get_request_auth(url)</code>","text":"<p>Return a <code>requests</code> Auth object for a given MLflow request URL.</p> <p>Applies host allowlisting to avoid credential leakage.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Full request URL for an MLflow call.</p> required <p>Returns:</p> Type Description <code>AuthBase | None</code> <p>A <code>requests.auth.AuthBase</code> instance or None if not allowed/available.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def get_request_auth(self, url: str) -&gt; requests.auth.AuthBase | None:\n    \"\"\"Return a `requests` Auth object for a given MLflow request URL.\n\n    Applies host allowlisting to avoid credential leakage.\n\n    Args:\n        url: Full request URL for an MLflow call.\n\n    Returns:\n        A `requests.auth.AuthBase` instance or None if not allowed/available.\n\n    \"\"\"\n    if not self._is_enabled():\n        safe_log(self.logger, logging.DEBUG, f\"{self.provider_name} provider not enabled\")\n        return None\n\n    allowed_hosts = get_allowed_hosts()\n    if not is_host_allowed(url, allowed_hosts):\n        hostname = urlparse(url).hostname or \"&lt;unknown&gt;\"\n        safe_log(\n            self.logger,\n            logging.INFO,\n            f\"Host {hostname} not in allowed hosts list; skipping auth\",\n        )\n        return None\n\n    try:\n        secret_data = self._fetch_secret_cached()\n        if not secret_data:\n            safe_log(self.logger, logging.WARNING, f\"Failed to fetch secret from {self.provider_name}\")\n            return None\n        return self._create_auth(secret_data)\n    except ValueError as e:\n        # Configuration or parsing error \u2014 not fatal to the request.\n        safe_log(self.logger, logging.WARNING, f\"{self.provider_name} config error: {e}\")\n        return None\n    except Exception as e:  # pragma: no cover \u2014 defensive\n        safe_log(self.logger, logging.ERROR, f\"Unexpected error in {self.provider_name}: {e}\")\n        return None\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cache","title":"<code>cache</code>","text":"<p>TTL cache implementation for secrets.</p> <p>Provides a lightweight, thread-safe cache with monotonic-clock\u2013based TTLs and a simple decorator (<code>cached_fetch</code>) to memoize zero-argument callables.</p> Design goals <ul> <li>Monotonic time to avoid issues when the wall clock changes.</li> <li>Thread safety via <code>RLock</code>.</li> <li>No caching of failures: exceptions from the wrapped callable return <code>None</code>   and are not stored.</li> <li>Global cache instance for convenience, with helpers to clear and inspect size.</li> </ul>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cache.TTLCache","title":"<code>TTLCache()</code>","text":"<p>Thread-safe TTL cache (monotonic-clock based).</p> Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._cache: dict[str, tuple[Any, float]] = {}\n    self._lock = threading.RLock()\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cache.TTLCache.clear","title":"<code>clear()</code>","text":"<p>Clear all cached items.</p> Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all cached items.\"\"\"\n    with self._lock:\n        self._cache.clear()\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cache.TTLCache.delete","title":"<code>delete(key)</code>","text":"<p>Remove a key from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Cache key to remove.</p> required Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Remove a key from the cache.\n\n    Args:\n        key: Cache key to remove.\n\n    \"\"\"\n    with self._lock:\n        self._cache.pop(key, None)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cache.TTLCache.get","title":"<code>get(key)</code>","text":"<p>Get a value from the cache if present and not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Cache key.</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>The cached value if present and valid, otherwise None.</p> Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def get(self, key: str) -&gt; Any | None:\n    \"\"\"Get a value from the cache if present and not expired.\n\n    Args:\n        key: Cache key.\n\n    Returns:\n        The cached value if present and valid, otherwise None.\n\n    \"\"\"\n    with self._lock:\n        entry = self._cache.get(key)\n        if entry is None:\n            return None\n        value, expiry = entry\n        if self._now() &gt; expiry:\n            self._cache.pop(key, None)\n            return None\n        return value\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cache.TTLCache.invalidate_prefix","title":"<code>invalidate_prefix(prefix)</code>","text":"<p>Remove all keys starting with a prefix.</p> <p>Useful for provider-wide invalidation using e.g. <code>f\"{provider_name}:\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix to match.</p> required Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def invalidate_prefix(self, prefix: str) -&gt; None:\n    \"\"\"Remove all keys starting with a prefix.\n\n    Useful for provider-wide invalidation using e.g. ``f\"{provider_name}:\"``.\n\n    Args:\n        prefix: Prefix to match.\n\n    \"\"\"\n    with self._lock:\n        to_delete = [k for k in self._cache if k.startswith(prefix)]\n        for k in to_delete:\n            self._cache.pop(k, None)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cache.TTLCache.set","title":"<code>set(key, value, ttl_seconds)</code>","text":"<p>Set a value in the cache with a TTL.</p> <p>Non-positive TTLs are treated as \"no caching\" (the key is removed).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Cache key.</p> required <code>value</code> <code>Any</code> <p>Value to store.</p> required <code>ttl_seconds</code> <code>float</code> <p>Time-to-live in seconds.</p> required Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def set(self, key: str, value: Any, ttl_seconds: float) -&gt; None:\n    \"\"\"Set a value in the cache with a TTL.\n\n    Non-positive TTLs are treated as \"no caching\" (the key is removed).\n\n    Args:\n        key: Cache key.\n        value: Value to store.\n        ttl_seconds: Time-to-live in seconds.\n\n    \"\"\"\n    with self._lock:\n        if ttl_seconds &lt;= 0:\n            self._cache.pop(key, None)\n            return\n        self._cache[key] = (value, self._now() + float(ttl_seconds))\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cache.TTLCache.size","title":"<code>size()</code>","text":"<p>Return the current cache size, pruning expired entries first.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of live (non-expired) entries.</p> Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def size(self) -&gt; int:\n    \"\"\"Return the current cache size, pruning expired entries first.\n\n    Returns:\n        Number of live (non-expired) entries.\n\n    \"\"\"\n    with self._lock:\n        now = self._now()\n        to_delete = [k for k, (_, exp) in self._cache.items() if now &gt; exp]\n        for k in to_delete:\n            self._cache.pop(k, None)\n        return len(self._cache)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cache.cached_fetch","title":"<code>cached_fetch(cache_key, ttl_seconds)</code>","text":"<p>Decorator to cache a zero-argument function's result with a TTL.</p> <p>Exceptions raised by the wrapped function are swallowed and result in <code>None</code>, which is not cached. Successful non-None results are cached.</p> <p>Parameters:</p> Name Type Description Default <code>cache_key</code> <code>str</code> <p>Unique cache key for the function result.</p> required <code>ttl_seconds</code> <code>int</code> <p>Time-to-live for the cached value.</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[[], T]], Callable[[], T | None]]</code> <p>A decorator that wraps a <code>Callable[[], T]</code> and returns <code>Callable[[], Optional[T]]</code>.</p> Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def cached_fetch(cache_key: str, ttl_seconds: int) -&gt; Callable[[Callable[[], T]], Callable[[], T | None]]:\n    \"\"\"Decorator to cache a zero-argument function's result with a TTL.\n\n    Exceptions raised by the wrapped function are swallowed and result in `None`,\n    which is not cached. Successful non-None results are cached.\n\n    Args:\n        cache_key: Unique cache key for the function result.\n        ttl_seconds: Time-to-live for the cached value.\n\n    Returns:\n        A decorator that wraps a `Callable[[], T]` and returns `Callable[[], Optional[T]]`.\n\n    \"\"\"\n\n    def decorator(fetch_func: Callable[[], T]) -&gt; Callable[[], T | None]:\n        def wrapper() -&gt; T | None:\n            cached_value = _global_cache.get(cache_key)\n            if cached_value is not None:\n                # Typing note: caller-provided T is preserved by construction.\n                return cached_value  # type: ignore[return-value]\n\n            try:\n                value = fetch_func()\n            except Exception:\n                # Do not cache failures; return None to the caller.\n                return None\n\n            if value is not None:\n                _global_cache.set(cache_key, value, ttl_seconds)\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cache.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear the global cache instance.</p> Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def clear_cache() -&gt; None:\n    \"\"\"Clear the global cache instance.\"\"\"\n    _global_cache.clear()\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cache.delete_cache_key","title":"<code>delete_cache_key(key)</code>","text":"<p>Remove a single cache entry by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Cache key to remove.</p> required Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def delete_cache_key(key: str) -&gt; None:\n    \"\"\"Remove a single cache entry by key.\n\n    Args:\n        key: Cache key to remove.\n\n    \"\"\"\n    _global_cache.delete(key)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cache.get_cache_size","title":"<code>get_cache_size()</code>","text":"<p>Get the current size of the global cache (after pruning).</p> Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def get_cache_size() -&gt; int:\n    \"\"\"Get the current size of the global cache (after pruning).\"\"\"\n    return _global_cache.size()\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cli","title":"<code>cli</code>","text":"<p>Command-line interface (CLI) for MLflow Secrets Auth.</p> Subcommands <ul> <li>info   \u2013 Show version, enabled providers, and configuration snapshot.</li> <li>doctor \u2013 Run diagnostics against the configured provider.</li> </ul>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cli.doctor_command","title":"<code>doctor_command(args)</code>","text":"<p>Run diagnostics against the configured provider.</p> Steps <p>1) Resolve enabled provider. 2) Validate provider configuration (auth mode, TTL, header). 3) Fetch secret and construct an auth object. 4) Optional dry-run: issue a HEAD request to the given URL's origin.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Parsed CLI args (supports <code>--dry-run</code> URL).</p> required <p>Returns:</p> Type Description <code>int</code> <p>Process exit code (0 on success, non-zero on error).</p> Source code in <code>src/mlflow_secrets_auth/cli.py</code> <pre><code>def doctor_command(args: argparse.Namespace) -&gt; int:\n    \"\"\"Run diagnostics against the configured provider.\n\n    Steps:\n      1) Resolve enabled provider.\n      2) Validate provider configuration (auth mode, TTL, header).\n      3) Fetch secret and construct an auth object.\n      4) Optional dry-run: issue a HEAD request to the given URL's origin.\n\n    Args:\n        args: Parsed CLI args (supports `--dry-run` URL).\n\n    Returns:\n        Process exit code (0 on success, non-zero on error).\n\n    \"\"\"\n    setup_logger(\"mlflow_secrets_auth.cli\")\n\n    _print_header(\"MLflow Secrets Auth \u2013 Doctor\")\n\n    provider_name, provider = get_enabled_provider()\n    if provider_name is None or provider is None:\n        return 1\n\n    # Config snapshot\n    try:\n        _ = provider._get_auth_mode()\n        _ = get_auth_header_name()\n        _ = provider._get_ttl()\n        _ = get_cache_size()\n        allowed_hosts = get_allowed_hosts()\n    except Exception:  # pragma: no cover\n        return 1\n\n    # Test secret fetch + auth construction\n    try:\n        secret_data = provider._fetch_secret_cached()\n        if not secret_data:\n            return 1\n\n        try:\n            provider._create_auth(secret_data)\n        except Exception:\n            return 1\n    except Exception:  # pragma: no cover\n        return 1\n\n    # Optional dry-run against a URL\n    if args.dry_run:\n        parsed = urlparse(args.dry_run)\n        if not parsed.scheme or not parsed.netloc:\n            return 1\n\n        if allowed_hosts and parsed.hostname not in allowed_hosts:\n            return 1\n\n        try:\n            auth = provider.get_request_auth(args.dry_run)\n            if auth is None:\n                return 1\n\n            origin = f\"{parsed.scheme}://{parsed.netloc}/\"\n            with contextlib.suppress(requests.exceptions.RequestException):\n                requests.head(origin, auth=auth, timeout=10, allow_redirects=True)\n        except Exception:  # pragma: no cover\n            return 1\n\n    return 0\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cli.get_enabled_provider","title":"<code>get_enabled_provider()</code>","text":"<p>Return the first enabled provider as (name, instance), or (None, None).</p> <p>Returns:</p> Type Description <code>ProviderTuple</code> <p>Tuple of provider name and instance, or (None, None) if none enabled.</p> Source code in <code>src/mlflow_secrets_auth/cli.py</code> <pre><code>def get_enabled_provider() -&gt; ProviderTuple:\n    \"\"\"Return the first enabled provider as (name, instance), or (None, None).\n\n    Returns:\n        Tuple of provider name and instance, or (None, None) if none enabled.\n\n    \"\"\"\n    for name, cls in PROVIDERS.items():\n        if is_provider_enabled(name):\n            try:\n                return name, cls()  # type: ignore[call-arg]  # compatible ctor\n            except Exception:  # pragma: no cover \u2014 defensive\n                return name, None\n    return None, None\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cli.info_command","title":"<code>info_command(_)</code>","text":"<p>Show plugin version and configuration snapshot.</p> <p>Returns:</p> Type Description <code>int</code> <p>Process exit code (0 on success, non-zero on error).</p> Source code in <code>src/mlflow_secrets_auth/cli.py</code> <pre><code>def info_command(_: argparse.Namespace) -&gt; int:\n    \"\"\"Show plugin version and configuration snapshot.\n\n    Returns:\n        Process exit code (0 on success, non-zero on error).\n\n    \"\"\"\n    setup_logger(\"mlflow_secrets_auth.cli\")\n\n    _print_header(\"MLflow Secrets Auth \u2013 Info\")\n\n    # Version\n    try:\n        importlib.metadata.version(\"mlflow-secrets-auth\")\n    except importlib.metadata.PackageNotFoundError:\n        # Fallback for editable installs if distribution metadata is absent\n        try:\n            pass  # type: ignore\n        except Exception:\n            pass\n\n    # Providers\n    [name for name in PROVIDERS if is_provider_enabled(name)]\n\n    # Config snapshot\n    get_allowed_hosts()\n    return 0\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.cli.main","title":"<code>main()</code>","text":"<p>Main CLI entry point.</p> <p>Returns:</p> Type Description <code>int</code> <p>Process exit code (0 on success, non-zero on error).</p> Source code in <code>src/mlflow_secrets_auth/cli.py</code> <pre><code>def main() -&gt; int:\n    \"\"\"Main CLI entry point.\n\n    Returns:\n        Process exit code (0 on success, non-zero on error).\n\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"MLflow Secrets Auth CLI\")\n    subparsers = parser.add_subparsers(dest=\"command\", help=\"Available commands\")\n\n    # doctor\n    doctor_parser = subparsers.add_parser(\"doctor\", help=\"Run diagnostics\")\n    doctor_parser.add_argument(\n        \"--dry-run\",\n        metavar=\"URL\",\n        help=\"Test auth against specified MLflow tracking URL\",\n    )\n\n    # info\n    subparsers.add_parser(\"info\", help=\"Show plugin information and configuration\")\n\n    args = parser.parse_args()\n\n    if args.command == \"doctor\":\n        return doctor_command(args)\n    if args.command == \"info\":\n        return info_command(args)\n\n    parser.print_help()\n    return 1\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.config","title":"<code>config</code>","text":"<p>Configuration utilities for MLflow secrets auth providers.</p> <p>This module centralizes environment-driven configuration and safe redaction helpers.</p> Key env vars <ul> <li>MLFLOW_SECRETS_ALLOWED_HOSTS: Comma-separated host allowlist.</li> <li>MLFLOW_AUTH_HEADER_NAME: Custom header for auth (defaults to \"Authorization\").</li> <li>MLFLOW_SECRETS_LOG_LEVEL: Logging level (defaults to \"INFO\").</li> <li>MLFLOW_SECRETS_AUTH_ENABLE: Comma-separated list of enabled providers.</li> <li>MLFLOW_SECRETS_AUTH_ENABLE_: Per-provider boolean toggle (e.g., AWS_SECRETS_MANAGER)."},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.config.get_allowed_hosts","title":"<code>get_allowed_hosts()</code>","text":"<p>Return the host allowlist from MLFLOW_SECRETS_ALLOWED_HOSTS.</p> <p>Supports both exact hostnames and wildcard patterns using shell-style globbing.</p> <p>Examples:</p> <p>MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.example.com,.corp.example.com\" MLFLOW_SECRETS_ALLOWED_HOSTS=\"api.prod.com,.staging.com,localhost\"</p> Wildcard patterns <ul> <li>\"*.corp.example.com\" matches any subdomain of corp.example.com</li> <li>\"mlflow.*.com\" matches mlflow with any middle component</li> <li>\"api-*\" matches hostnames starting with \"api-\"</li> </ul> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>A list of hostname patterns, or None if not configured.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def get_allowed_hosts() -&gt; list[str] | None:\n    \"\"\"Return the host allowlist from MLFLOW_SECRETS_ALLOWED_HOSTS.\n\n    Supports both exact hostnames and wildcard patterns using shell-style globbing.\n\n    Examples:\n        MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.example.com,*.corp.example.com\"\n        MLFLOW_SECRETS_ALLOWED_HOSTS=\"api.prod.com,*.staging.com,localhost\"\n\n    Wildcard patterns:\n        - \"*.corp.example.com\" matches any subdomain of corp.example.com\n        - \"mlflow.*.com\" matches mlflow with any middle component\n        - \"api-*\" matches hostnames starting with \"api-\"\n\n    Returns:\n        A list of hostname patterns, or None if not configured.\n\n    \"\"\"\n    hosts_str = get_env_var(\"MLFLOW_SECRETS_ALLOWED_HOSTS\")\n    if not hosts_str:\n        return None\n    hosts = [h.strip() for h in hosts_str.split(\",\") if h.strip()]\n    return hosts or None\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.config.get_auth_header_name","title":"<code>get_auth_header_name()</code>","text":"<p>Return the configured auth header name.</p> <p>Defaults to \"Authorization\" when MLFLOW_AUTH_HEADER_NAME is unset.</p> <p>Returns:</p> Type Description <code>str</code> <p>Header name as a string.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def get_auth_header_name() -&gt; str:\n    \"\"\"Return the configured auth header name.\n\n    Defaults to \"Authorization\" when MLFLOW_AUTH_HEADER_NAME is unset.\n\n    Returns:\n        Header name as a string.\n\n    \"\"\"\n    return get_env_var(\"MLFLOW_AUTH_HEADER_NAME\", \"Authorization\") or \"Authorization\"\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.config.get_env_bool","title":"<code>get_env_bool(name, default=False)</code>","text":"<p>Return an environment variable parsed as a boolean.</p> <p>Recognized truthy values (case-insensitive): {\"1\", \"true\", \"yes\", \"on\"}.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Environment variable name.</p> required <code>default</code> <code>bool</code> <p>Fallback when the variable is unset.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>Parsed boolean value.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def get_env_bool(name: str, default: bool = False) -&gt; bool:\n    \"\"\"Return an environment variable parsed as a boolean.\n\n    Recognized truthy values (case-insensitive): {\"1\", \"true\", \"yes\", \"on\"}.\n\n    Args:\n        name: Environment variable name.\n        default: Fallback when the variable is unset.\n\n    Returns:\n        Parsed boolean value.\n\n    \"\"\"\n    value = get_env_var(name)\n    if value is None:\n        return default\n    return value.strip().lower() in {\"1\", \"true\", \"yes\", \"on\"}\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.config.get_env_int","title":"<code>get_env_int(name, default)</code>","text":"<p>Return an environment variable parsed as int.</p> <p>On parsing error or if unset, returns <code>default</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Environment variable name.</p> required <code>default</code> <code>int</code> <p>Fallback value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Parsed integer or <code>default</code>.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def get_env_int(name: str, default: int) -&gt; int:\n    \"\"\"Return an environment variable parsed as int.\n\n    On parsing error or if unset, returns `default`.\n\n    Args:\n        name: Environment variable name.\n        default: Fallback value.\n\n    Returns:\n        Parsed integer or `default`.\n\n    \"\"\"\n    value = get_env_var(name)\n    if value is None:\n        return default\n    try:\n        return int(value.strip())\n    except (TypeError, ValueError):\n        return default\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.config.get_env_var","title":"<code>get_env_var(name, default=None)</code>","text":"<p>Return an environment variable or a default.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Environment variable name.</p> required <code>default</code> <code>str | None</code> <p>Value to return if not set.</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>The environment value as a string, or <code>default</code> when unset.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def get_env_var(name: str, default: str | None = None) -&gt; str | None:\n    \"\"\"Return an environment variable or a default.\n\n    Args:\n        name: Environment variable name.\n        default: Value to return if not set.\n\n    Returns:\n        The environment value as a string, or `default` when unset.\n\n    \"\"\"\n    return os.environ.get(name, default)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.config.get_log_level","title":"<code>get_log_level()</code>","text":"<p>Return the configured log level for secrets auth.</p> <p>Defaults to \"INFO\" and uppercases the value for consistency.</p> <p>Returns:</p> Type Description <code>str</code> <p>Uppercased logging level string (e.g., \"INFO\", \"DEBUG\").</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def get_log_level() -&gt; str:\n    \"\"\"Return the configured log level for secrets auth.\n\n    Defaults to \"INFO\" and uppercases the value for consistency.\n\n    Returns:\n        Uppercased logging level string (e.g., \"INFO\", \"DEBUG\").\n\n    \"\"\"\n    return (get_env_var(\"MLFLOW_SECRETS_LOG_LEVEL\", \"INFO\") or \"INFO\").upper()\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.config.is_provider_enabled","title":"<code>is_provider_enabled(provider_name)</code>","text":"<p>Return whether a specific provider is enabled.</p> Two mechanisms <p>1) Global list: MLFLOW_SECRETS_AUTH_ENABLE=\"vault,aws-secrets-manager,azure-key-vault\" 2) Per-provider boolean: MLFLOW_SECRETS_AUTH_ENABLE_=true    e.g. MLFLOW_SECRETS_AUTH_ENABLE_AWS_SECRETS_MANAGER=true <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>Provider slug (case-insensitive), e.g. \"vault\".</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if enabled via either mechanism, False otherwise.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def is_provider_enabled(provider_name: str) -&gt; bool:\n    \"\"\"Return whether a specific provider is enabled.\n\n    Two mechanisms:\n      1) Global list: MLFLOW_SECRETS_AUTH_ENABLE=\"vault,aws-secrets-manager,azure-key-vault\"\n      2) Per-provider boolean: MLFLOW_SECRETS_AUTH_ENABLE_&lt;PROVIDER&gt;=true\n         e.g. MLFLOW_SECRETS_AUTH_ENABLE_AWS_SECRETS_MANAGER=true\n\n    Args:\n        provider_name: Provider slug (case-insensitive), e.g. \"vault\".\n\n    Returns:\n        True if enabled via either mechanism, False otherwise.\n\n    \"\"\"\n    # Global list\n    global_enable = get_env_var(\"MLFLOW_SECRETS_AUTH_ENABLE\", \"\") or \"\"\n    enabled = {p.strip().lower() for p in global_enable.split(\",\") if p.strip()}\n    if provider_name.strip().lower() in enabled:\n        return True\n\n    # Provider-specific toggle\n    env_key = f\"MLFLOW_SECRETS_AUTH_ENABLE_{provider_name.upper().replace('-', '_')}\"\n    return get_env_bool(env_key, False)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.config.mask_secret","title":"<code>mask_secret(value, mask_char='*', show_chars=4)</code>","text":"<p>Mask a secret value for safe logging.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mask_secret(\"abcd1234\")\n'abcd********1234'\n&gt;&gt;&gt; mask_secret(\"ab\")\n'***'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Secret value to mask.</p> required <code>mask_char</code> <code>str</code> <p>Masking character (default '*').</p> <code>'*'</code> <code>show_chars</code> <code>int</code> <p>Number of leading and trailing chars to keep (default 4).</p> <code>4</code> <p>Returns:</p> Type Description <code>str</code> <p>Masked representation with the center portion obfuscated.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def mask_secret(value: str, mask_char: str = \"*\", show_chars: int = 4) -&gt; str:\n    \"\"\"Mask a secret value for safe logging.\n\n    Examples:\n        &gt;&gt;&gt; mask_secret(\"abcd1234\")\n        'abcd********1234'\n        &gt;&gt;&gt; mask_secret(\"ab\")\n        '***'\n\n    Args:\n        value: Secret value to mask.\n        mask_char: Masking character (default '*').\n        show_chars: Number of leading and trailing chars to keep (default 4).\n\n    Returns:\n        Masked representation with the center portion obfuscated.\n\n    \"\"\"\n    if not value:\n        return mask_char * 8\n\n    # Guard against non-positive show_chars\n    show = max(0, int(show_chars))\n\n    if len(value) &lt;= show:\n        return mask_char * max(3, len(value))\n    if len(value) &lt;= show * 2:\n        # Keep a small preview while masking the middle\n        keep = min(2, len(value))\n        return f\"{value[:keep]}{mask_char * 4}{value[-keep:]}\"\n    return f\"{value[:show]}{mask_char * 8}{value[-show:]}\"\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.config.redact_sensitive_data","title":"<code>redact_sensitive_data(text)</code>","text":"<p>Redact common credential patterns from text.</p> <p>Safely handles patterns with different group counts. Intended for logs and messages.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Input string possibly containing sensitive material.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Redacted string with secrets masked.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def redact_sensitive_data(text: str) -&gt; str:\n    \"\"\"Redact common credential patterns from text.\n\n    Safely handles patterns with different group counts. Intended for logs and messages.\n\n    Args:\n        text: Input string possibly containing sensitive material.\n\n    Returns:\n        Redacted string with secrets masked.\n\n    \"\"\"\n    if not text:\n        return text\n\n    def _sub(m: re.Match[str]) -&gt; str:\n        groups = m.groups()\n        # One-group pattern: mask entire match\n        if len(groups) == 1:\n            return mask_secret(groups[0])\n        # Two/three-group patterns: mask the middle secret\n        if len(groups) &gt;= 2:\n            prefix = groups[0]\n            secret = groups[1]\n            suffix = groups[2] if len(groups) &gt;= 3 else \"\"\n            return f\"{prefix}{mask_secret(secret)}{suffix}\"\n        # Fallback to original text (should not happen with defined patterns)\n        return m.group(0)\n\n    result = text\n    for pattern in _REDACT_PATTERNS:\n        result = pattern.sub(_sub, result)\n    return result\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.providers","title":"<code>providers</code>","text":"<p>Empty file to make providers a package.</p>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.providers.aws_secrets_manager","title":"<code>aws_secrets_manager</code>","text":"<p>AWS Secrets Manager authentication provider.</p>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.providers.aws_secrets_manager.AWSSecretsManagerAuthProvider","title":"<code>AWSSecretsManagerAuthProvider()</code>","text":"<p>               Bases: <code>SecretsBackedAuthProvider</code></p> <p>Authentication provider using AWS Secrets Manager.</p> <p>Requires the optional dependency <code>boto3</code>.</p> Environment variables <p>AWS_REGION: AWS region (e.g., \"eu-west-1\"). Required. MLFLOW_AWS_SECRET_ID: Secret identifier or ARN. Required. MLFLOW_AWS_AUTH_MODE: \"bearer\" (default) or \"basic\". MLFLOW_AWS_TTL_SEC: Cache TTL in seconds (defaults to provider's default TTL).</p> <p>Initialize the provider with a default TTL and lazy AWS client.</p> Source code in <code>src/mlflow_secrets_auth/providers/aws_secrets_manager.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the provider with a default TTL and lazy AWS client.\"\"\"\n    super().__init__(\"aws-secrets-manager\", default_ttl=300)\n    self._secrets_client: Any | None = None  # boto3 client when available\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.providers.azure_key_vault","title":"<code>azure_key_vault</code>","text":"<p>Azure Key Vault authentication provider.</p>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.providers.azure_key_vault.AzureKeyVaultAuthProvider","title":"<code>AzureKeyVaultAuthProvider()</code>","text":"<p>               Bases: <code>SecretsBackedAuthProvider</code></p> <p>Authentication provider using Azure Key Vault.</p> <p>Requires optional dependencies: <code>azure-identity</code> and <code>azure-keyvault-secrets</code>.</p> Environment variables <p>AZURE_KEY_VAULT_URL: Full Key Vault URL (e.g., \"https://myvault.vault.azure.net\"). Required. MLFLOW_AZURE_SECRET_NAME: Secret name to retrieve. Required. MLFLOW_AZURE_AUTH_MODE: \"bearer\" (default) or \"basic\". MLFLOW_AZURE_TTL_SEC: Cache TTL in seconds (defaults to provider's default TTL).</p> <p>Initialize the provider with a default TTL and a lazy SecretClient.</p> Source code in <code>src/mlflow_secrets_auth/providers/azure_key_vault.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the provider with a default TTL and a lazy SecretClient.\"\"\"\n    super().__init__(\"azure-key-vault\", default_ttl=300)\n    self._secret_client: Any | None = None  # azure.keyvault.secrets.SecretClient when available\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.providers.vault","title":"<code>vault</code>","text":"<p>HashiCorp Vault authentication provider.</p>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.providers.vault.VaultAuthProvider","title":"<code>VaultAuthProvider()</code>","text":"<p>               Bases: <code>SecretsBackedAuthProvider</code></p> <p>Authentication provider using HashiCorp Vault.</p> <p>Supports token and AppRole authentication via the <code>hvac</code> client (optional dependency). Secrets are retrieved from KV v2 when possible with a graceful fallback to KV v1.</p> Environment variables <p>VAULT_ADDR: Vault server address, e.g. \"https://vault.example.com\" VAULT_TOKEN: Vault token for direct authentication (optional). VAULT_ROLE_ID: AppRole role ID (used if VAULT_TOKEN is not provided). VAULT_SECRET_ID: AppRole secret ID (used if VAULT_TOKEN is not provided). MLFLOW_VAULT_SECRET_PATH: Secret path (e.g. \"secret/mlflow/auth\" or \"secret/data/mlflow/auth\"). MLFLOW_VAULT_AUTH_MODE: \"bearer\" (default) or \"basic\". MLFLOW_VAULT_TTL_SEC: Cache TTL in seconds (defaults to provider's default TTL).</p> Notes <ul> <li>When using KV v2, this implementation auto-detects common path formats and   reads via <code>client.secrets.kv.v2.read_secret_version</code>.</li> <li>For KV v1, it falls back to <code>client.secrets.kv.v1.read_secret</code>.</li> <li>Secret dictionaries are JSON-encoded for centralized parsing in the base class.</li> </ul> <p>Initialize the provider with a default TTL and a lazy hvac client.</p> Source code in <code>src/mlflow_secrets_auth/providers/vault.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the provider with a default TTL and a lazy hvac client.\"\"\"\n    super().__init__(\"vault\", default_ttl=300)\n    self._vault_client: Any | None = None  # hvac.Client if available\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.utils","title":"<code>utils</code>","text":"<p>Utility functions for MLflow secrets auth providers.</p> This module centralizes <ul> <li>Logger setup with environment-driven log levels.</li> <li>Safe logging with automatic redaction of sensitive substrings.</li> <li>Secret parsing with automatic format detection (JSON vs. plain string).</li> <li>URL allowlist checks.</li> <li>Small helpers (duration formatting, TTL validation, masking).</li> <li>Retry functionality with exponential backoff and jitter.</li> </ul>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.utils.format_duration","title":"<code>format_duration(seconds)</code>","text":"<p>Format a duration in seconds into a short human-readable string.</p> <p>Examples:</p> <p>45 -&gt; \"45s\" 125 -&gt; \"2m 5s\" 3600 -&gt; \"1h\"</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>int</code> <p>Duration in seconds.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Short human-readable representation.</p> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def format_duration(seconds: int) -&gt; str:\n    \"\"\"Format a duration in seconds into a short human-readable string.\n\n    Examples:\n        45 -&gt; \"45s\"\n        125 -&gt; \"2m 5s\"\n        3600 -&gt; \"1h\"\n\n    Args:\n        seconds: Duration in seconds.\n\n    Returns:\n        Short human-readable representation.\n\n    \"\"\"\n    if seconds &lt; 60:\n        return f\"{seconds}s\"\n    if seconds &lt; 3600:\n        m, s = divmod(seconds, 60)\n        return f\"{m}m\" if s == 0 else f\"{m}m {s}s\"\n    h, rem = divmod(seconds, 3600)\n    m = rem // 60\n    return f\"{h}h\" if m == 0 else f\"{h}h {m}m\"\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.utils.is_host_allowed","title":"<code>is_host_allowed(url, allowed_hosts)</code>","text":"<p>Return whether the URL's host is in the provided allowlist.</p> <p>Supports exact hostname matches and wildcard patterns using shell-style globbing (e.g., \"*.corp.example.com\" matches \"api.corp.example.com\").</p> <p>Hostname matching is case-insensitive as per DNS standards.</p> <p>Examples:</p> <ul> <li>\"example.com\" matches exactly \"example.com\"</li> <li>\"*.corp.example.com\" matches \"api.corp.example.com\", \"web.corp.example.com\"</li> <li>\"mlflow.*.com\" matches \"mlflow.prod.com\", \"mlflow.staging.com\"</li> </ul> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Full URL to check.</p> required <code>allowed_hosts</code> <code>list[str] | None</code> <p>List of allowed hostname patterns, or None to allow all.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if allowed (or no allowlist configured), otherwise False.</p> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def is_host_allowed(url: str, allowed_hosts: list[str] | None) -&gt; bool:\n    \"\"\"Return whether the URL's host is in the provided allowlist.\n\n    Supports exact hostname matches and wildcard patterns using shell-style\n    globbing (e.g., \"*.corp.example.com\" matches \"api.corp.example.com\").\n\n    Hostname matching is case-insensitive as per DNS standards.\n\n    Examples:\n        - \"example.com\" matches exactly \"example.com\"\n        - \"*.corp.example.com\" matches \"api.corp.example.com\", \"web.corp.example.com\"\n        - \"mlflow.*.com\" matches \"mlflow.prod.com\", \"mlflow.staging.com\"\n\n    Args:\n        url: Full URL to check.\n        allowed_hosts: List of allowed hostname patterns, or None to allow all.\n\n    Returns:\n        True if allowed (or no allowlist configured), otherwise False.\n\n    \"\"\"\n    if allowed_hosts is None:\n        return True\n    try:\n        hostname = urlparse(url).hostname\n        if not hostname:\n            return False\n\n        # Normalize hostname to lowercase for case-insensitive comparison\n        hostname = hostname.lower()\n\n        # Check each pattern in the allowlist\n        for pattern in allowed_hosts:\n            # Normalize pattern to lowercase as well\n            pattern_lower = pattern.lower()\n            if fnmatch.fnmatch(hostname, pattern_lower):\n                return True\n\n        return False\n    except Exception:\n        return False\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.utils.mask_secret","title":"<code>mask_secret(secret, show_chars=4)</code>","text":"<p>Mask a secret for safe logging.</p> <p>For short inputs (&lt;= 2 * show_chars) returns a generic \"***\" to avoid revealing almost the entire secret.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <code>str</code> <p>Secret value.</p> required <code>show_chars</code> <code>int</code> <p>Number of leading and trailing characters to keep.</p> <code>4</code> <p>Returns:</p> Type Description <code>str</code> <p>Masked representation of the secret.</p> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def mask_secret(secret: str, show_chars: int = 4) -&gt; str:\n    \"\"\"Mask a secret for safe logging.\n\n    For short inputs (&lt;= 2 * show_chars) returns a generic \"***\" to avoid\n    revealing almost the entire secret.\n\n    Args:\n        secret: Secret value.\n        show_chars: Number of leading and trailing characters to keep.\n\n    Returns:\n        Masked representation of the secret.\n\n    \"\"\"\n    if not secret or len(secret) &lt;= show_chars * 2:\n        return \"***\"\n    return f\"{secret[:show_chars]}...{secret[-show_chars:]}\"\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.utils.parse_secret_json","title":"<code>parse_secret_json(secret_value)</code>","text":"<p>Parse secret material with automatic format detection.</p> Accepts either <ul> <li>JSON object with one of:<ul> <li>{\"token\": \"\"} <li>{\"username\": \"...\", \"password\": \"...\"}</li> <li>Plain string:<ul> <li>\"username:password\" \u2192 {\"username\": \"...\", \"password\": \"...\"}</li> <li>\"\" \u2192 {\"token\": \"\"} <p>Whitespace is stripped from string fields.</p> <p>Parameters:</p> Name Type Description Default <code>secret_value</code> <code>str</code> <p>Raw secret value.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A normalized dict with either {\"token\": \"...\"} or {\"username\": \"...\", \"password\": \"...\"}.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the JSON object is invalid or missing required fields.</p> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def parse_secret_json(secret_value: str) -&gt; dict[str, str]:\n    \"\"\"Parse secret material with automatic format detection.\n\n    Accepts either:\n      * JSON object with one of:\n          - {\"token\": \"&lt;opaque token&gt;\"}\n          - {\"username\": \"...\", \"password\": \"...\"}\n      * Plain string:\n          - \"username:password\" \u2192 {\"username\": \"...\", \"password\": \"...\"}\n          - \"&lt;token&gt;\" \u2192 {\"token\": \"&lt;token&gt;\"}\n\n    Whitespace is stripped from string fields.\n\n    Args:\n        secret_value: Raw secret value.\n\n    Returns:\n        A normalized dict with either {\"token\": \"...\"} or {\"username\": \"...\", \"password\": \"...\"}.\n\n    Raises:\n        ValueError: If the JSON object is invalid or missing required fields.\n\n    \"\"\"\n    # First attempt: JSON object\n    try:\n        data = json.loads(secret_value)\n    except json.JSONDecodeError:\n        # Fallback to plain string\n        value = secret_value.strip()\n        if not value:\n            msg = \"Secret is empty\"\n            raise ValueError(msg)\n\n        if \":\" in value:\n            username, password = value.split(\":\", 1)\n            username = (username or \"\").strip()\n            password = (password or \"\").strip()\n            if not username or not password:\n                msg = \"Secret 'username:password' must be non-empty\"\n                raise ValueError(msg)\n            return {\"username\": username, \"password\": password}\n        return {\"token\": value}\n\n    if not isinstance(data, dict):\n        msg = \"Secret value must be a JSON object\"\n        raise ValueError(msg)\n\n    # Token-based secret\n    if \"token\" in data:\n        token = data[\"token\"]\n        if not isinstance(token, str) or not token.strip():\n            msg = \"Secret 'token' field must be a non-empty string\"\n            raise ValueError(msg)\n        return {\"token\": token.strip()}\n\n    # Username/password secret\n    if \"username\" in data and \"password\" in data:\n        username = data[\"username\"]\n        password = data[\"password\"]\n        if not isinstance(username, str) or not username.strip():\n            msg = \"Secret 'username' field must be a non-empty string\"\n            raise ValueError(msg)\n        if not isinstance(password, str) or not password.strip():\n            msg = \"Secret 'password' field must be a non-empty string\"\n            raise ValueError(msg)\n        return {\"username\": username.strip(), \"password\": password.strip()}\n\n    msg = \"Secret must contain either 'token' field or both 'username' and 'password' fields\"\n    raise ValueError(\n        msg,\n    )\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.utils.retry_with_jitter","title":"<code>retry_with_jitter(fn, attempts=3, base_delay=0.1, backoff=2.0, max_delay=1.0, jitter=0.4, sleep=time.sleep)</code>","text":"<p>Retry a function with exponential backoff and jitter.</p> <p>Calls <code>fn</code> up to <code>attempts</code> times with exponential backoff and \u00b1jitter%, capped by <code>max_delay</code>. If all attempts fail, reraises the last exception.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[[], T]</code> <p>Function to call (should take no arguments).</p> required <code>attempts</code> <code>int</code> <p>Maximum number of attempts (must be &gt;= 1).</p> <code>3</code> <code>base_delay</code> <code>float</code> <p>Initial delay in seconds.</p> <code>0.1</code> <code>backoff</code> <code>float</code> <p>Exponential backoff multiplier.</p> <code>2.0</code> <code>max_delay</code> <code>float</code> <p>Maximum delay between attempts in seconds.</p> <code>1.0</code> <code>jitter</code> <code>float</code> <p>Jitter factor as a proportion (e.g., 0.4 = \u00b140%).</p> <code>0.4</code> <code>sleep</code> <code>Callable[[float], None]</code> <p>Sleep function (mainly for testing).</p> <code>sleep</code> <p>Returns:</p> Type Description <code>T</code> <p>Result of the successful function call.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>The last exception encountered if all attempts fail.</p> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def retry_with_jitter(\n    fn: Callable[[], T],\n    attempts: int = 3,\n    base_delay: float = 0.1,\n    backoff: float = 2.0,\n    max_delay: float = 1.0,\n    jitter: float = 0.4,\n    sleep: Callable[[float], None] = time.sleep,\n) -&gt; T:\n    \"\"\"Retry a function with exponential backoff and jitter.\n\n    Calls `fn` up to `attempts` times with exponential backoff and \u00b1jitter%,\n    capped by `max_delay`. If all attempts fail, reraises the last exception.\n\n    Args:\n        fn: Function to call (should take no arguments).\n        attempts: Maximum number of attempts (must be &gt;= 1).\n        base_delay: Initial delay in seconds.\n        backoff: Exponential backoff multiplier.\n        max_delay: Maximum delay between attempts in seconds.\n        jitter: Jitter factor as a proportion (e.g., 0.4 = \u00b140%).\n        sleep: Sleep function (mainly for testing).\n\n    Returns:\n        Result of the successful function call.\n\n    Raises:\n        Exception: The last exception encountered if all attempts fail.\n\n    \"\"\"\n    last_exception = None\n\n    for attempt in range(attempts):\n        try:\n            return fn()\n        except Exception as e:\n            last_exception = e\n\n            # Don't sleep after the last attempt\n            if attempt == attempts - 1:\n                break\n\n            # Calculate delay with exponential backoff\n            delay = min(base_delay * (backoff ** attempt), max_delay)\n\n            # Add jitter: \u00b1jitter% of the delay\n            jitter_amount = delay * jitter * (2 * random.random() - 1)\n            final_delay = max(0, delay + jitter_amount)\n\n            sleep(final_delay)\n\n    # Re-raise the last exception if all attempts failed\n    if last_exception is not None:\n        raise last_exception\n\n    # This should never happen, but just in case\n    msg = \"No attempts were made\"\n    raise RuntimeError(msg)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.utils.safe_log","title":"<code>safe_log(logger, level, message, *args)</code>","text":"<p>Log a message with automatic redaction of sensitive data.</p> <p>The message is first formatted with <code>args</code> (printf-style) and only then passed through the redactor to avoid leaking secrets via formatting.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>Target logger.</p> required <code>level</code> <code>int</code> <p>Logging level (e.g., <code>logging.INFO</code>).</p> required <code>message</code> <code>str</code> <p>Format string.</p> required <code>*args</code> <code>Any</code> <p>Arguments for printf-style substitution.</p> <code>()</code> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def safe_log(logger: logging.Logger, level: int, message: str, *args: Any) -&gt; None:\n    \"\"\"Log a message with automatic redaction of sensitive data.\n\n    The message is first formatted with `args` (printf-style) and only then\n    passed through the redactor to avoid leaking secrets via formatting.\n\n    Args:\n        logger: Target logger.\n        level: Logging level (e.g., `logging.INFO`).\n        message: Format string.\n        *args: Arguments for printf-style substitution.\n\n    \"\"\"\n    if args:\n        try:\n            message = message % args\n        except Exception:\n            # Fall back to a simple join if interpolation fails for any reason\n            message = \" \".join([message, *map(str, args)])\n    redacted_message = redact_sensitive_data(message)\n    logger.log(level, redacted_message)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.utils.setup_logger","title":"<code>setup_logger(name)</code>","text":"<p>Create or configure a namespaced logger.</p> <p>The logger level is always driven by the <code>MLFLOW_SECRETS_LOG_LEVEL</code> env var. A single stream handler is attached once; propagation is disabled to avoid duplicated messages under test runners or frameworks.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Logger name (typically package.module).</p> required <p>Returns:</p> Type Description <code>Logger</code> <p>A configured <code>logging.Logger</code> instance.</p> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def setup_logger(name: str) -&gt; logging.Logger:\n    \"\"\"Create or configure a namespaced logger.\n\n    The logger level is always driven by the `MLFLOW_SECRETS_LOG_LEVEL` env var.\n    A single stream handler is attached once; propagation is disabled to avoid\n    duplicated messages under test runners or frameworks.\n\n    Args:\n        name: Logger name (typically package.module).\n\n    Returns:\n        A configured `logging.Logger` instance.\n\n    \"\"\"\n    logger = logging.getLogger(name)\n\n    # Always set the level from config\n    level_name = get_log_level()\n    level = getattr(logging, level_name, logging.INFO)\n    logger.setLevel(level)\n\n    # Only add a handler if none exist (avoid duplicate logs under pytest)\n    if not logger.handlers:\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter(\n            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        )\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n\n    # Avoid double logging through parent loggers\n    logger.propagate = False\n    return logger\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/__init__/#mlflow_secrets_auth.utils.validate_ttl","title":"<code>validate_ttl(ttl_seconds, *, default=300, min_ttl=1, max_ttl=3600)</code>","text":"<p>Validate and clamp a TTL value.</p> Rules <ul> <li>If <code>ttl_seconds</code> is None or &lt;= 0, use <code>default</code>.</li> <li>Clamp the final value between <code>min_ttl</code> and <code>max_ttl</code> (inclusive).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>ttl_seconds</code> <code>int | None</code> <p>Requested TTL in seconds.</p> required <code>default</code> <code>int</code> <p>Fallback TTL when input is invalid or not provided.</p> <code>300</code> <code>min_ttl</code> <code>int</code> <p>Minimum allowed TTL (inclusive).</p> <code>1</code> <code>max_ttl</code> <code>int</code> <p>Maximum allowed TTL (inclusive).</p> <code>3600</code> <p>Returns:</p> Type Description <code>int</code> <p>A valid TTL in seconds.</p> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def validate_ttl(\n    ttl_seconds: int | None,\n    *,\n    default: int = 300,\n    min_ttl: int = 1,\n    max_ttl: int = 3600,\n) -&gt; int:\n    \"\"\"Validate and clamp a TTL value.\n\n    Rules:\n      * If `ttl_seconds` is None or &lt;= 0, use `default`.\n      * Clamp the final value between `min_ttl` and `max_ttl` (inclusive).\n\n    Args:\n        ttl_seconds: Requested TTL in seconds.\n        default: Fallback TTL when input is invalid or not provided.\n        min_ttl: Minimum allowed TTL (inclusive).\n        max_ttl: Maximum allowed TTL (inclusive).\n\n    Returns:\n        A valid TTL in seconds.\n\n    \"\"\"\n    try:\n        ttl = int(ttl_seconds) if ttl_seconds is not None else int(default)\n    except (TypeError, ValueError):\n        ttl = int(default)\n\n    if ttl &lt;= 0:\n        ttl = int(default)\n\n    if ttl &lt; min_ttl:\n        ttl = min_ttl\n    elif ttl &gt; max_ttl:\n        ttl = max_ttl\n\n    return ttl\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/base/","title":"base","text":""},{"location":"reference/mlflow_secrets_auth/base/#mlflow_secrets_auth.base","title":"<code>mlflow_secrets_auth.base</code>","text":"<p>Base classes and abstractions for MLflow secrets-backed authentication providers.</p> This module defines <ul> <li>Lightweight <code>requests.auth.AuthBase</code> implementations for Bearer, Basic, and custom-header auth.</li> <li><code>SecretsBackedAuthProvider</code>, an abstract base for MLflow <code>RequestAuthProvider</code>s that obtain   credentials from secret managers and cache them with a TTL.</li> </ul> Design notes <ul> <li>Providers implement <code>_fetch_secret</code>, <code>_get_cache_key</code>, <code>_get_auth_mode</code>, and <code>_get_ttl</code>.</li> <li>Caching is delegated to <code>cached_fetch</code> and TTL validation to <code>validate_ttl</code>.</li> <li>Secrets are parsed centrally via <code>parse_secret_json</code> and must resolve to either:<ul> <li>{\"token\": \"\"}  OR <li>{\"username\": \"...\", \"password\": \"...\"}</li> <li>Header name can be configured; \"Authorization\" is normalized to the canonical header.</li> <p>All logging goes through <code>safe_log</code> to avoid leaking sensitive values.</p>"},{"location":"reference/mlflow_secrets_auth/base/#mlflow_secrets_auth.base.BasicAuth","title":"<code>BasicAuth(username, password, header_name='Authorization')</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>HTTP Basic authentication for <code>requests</code>.</p> <p>If a non-standard header is configured, the base64 credentials are put into that header.</p> <p>Attributes:</p> Name Type Description <code>username</code> <p>Basic auth username.</p> <code>password</code> <p>Basic auth password.</p> <code>header_name</code> <p>Target header (defaults to \"Authorization\").</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def __init__(self, username: str, password: str, header_name: str = \"Authorization\") -&gt; None:\n    self.username = username\n    self.password = password\n    self.header_name = header_name\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/base/#mlflow_secrets_auth.base.BasicAuth.__call__","title":"<code>__call__(r)</code>","text":"<p>Attach the basic auth header to the outgoing request.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def __call__(self, r: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n    \"\"\"Attach the basic auth header to the outgoing request.\"\"\"\n    creds = f\"{self.username}:{self.password}\".encode()\n    r.headers[self.header_name] = f\"Basic {base64.b64encode(creds).decode()}\"\n    return r\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/base/#mlflow_secrets_auth.base.BearerAuth","title":"<code>BearerAuth(token, header_name='Authorization')</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Bearer token authentication for <code>requests</code>.</p> <p>The token is injected as: <code>&lt;header_name&gt;: Bearer &lt;token&gt;</code></p> <p>Attributes:</p> Name Type Description <code>token</code> <p>Opaque bearer token.</p> <code>header_name</code> <p>Target header (defaults to \"Authorization\").</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def __init__(self, token: str, header_name: str = \"Authorization\") -&gt; None:\n    self.token = token\n    self.header_name = header_name\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/base/#mlflow_secrets_auth.base.BearerAuth.__call__","title":"<code>__call__(r)</code>","text":"<p>Attach the bearer token header to the outgoing request.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def __call__(self, r: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n    \"\"\"Attach the bearer token header to the outgoing request.\"\"\"\n    r.headers[self.header_name] = f\"Bearer {self.token}\"\n    return r\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/base/#mlflow_secrets_auth.base.CustomHeaderAuth","title":"<code>CustomHeaderAuth(token, header_name)</code>","text":"<p>               Bases: <code>AuthBase</code></p> <p>Custom header authentication for <code>requests</code> (token placed as-is).</p> <p>Attributes:</p> Name Type Description <code>token</code> <p>Opaque token to inject.</p> <code>header_name</code> <p>Target header.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def __init__(self, token: str, header_name: str) -&gt; None:\n    self.token = token\n    self.header_name = header_name\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/base/#mlflow_secrets_auth.base.CustomHeaderAuth.__call__","title":"<code>__call__(r)</code>","text":"<p>Attach the opaque token to the configured header.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def __call__(self, r: requests.PreparedRequest) -&gt; requests.PreparedRequest:\n    \"\"\"Attach the opaque token to the configured header.\"\"\"\n    r.headers[self.header_name] = self.token\n    return r\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/base/#mlflow_secrets_auth.base.SecretData","title":"<code>SecretData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Structured representation of parsed secret material.</p>"},{"location":"reference/mlflow_secrets_auth/base/#mlflow_secrets_auth.base.SecretsBackedAuthProvider","title":"<code>SecretsBackedAuthProvider(provider_name, default_ttl=300)</code>","text":"<p>               Bases: <code>RequestAuthProvider</code>, <code>ABC</code></p> <p>Abstract base class for secrets-backed MLflow auth providers.</p> <p>Subclasses implement secret retrieval for a specific backend (e.g., Vault, AWS, Azure) and supply configuration inputs (cache key, auth mode, TTL).</p> This class handles <ul> <li>Provider enablement checks.</li> <li>Host allowlisting for <code>get_request_auth</code>.</li> <li>Cache + TTL validation.</li> <li>Secret parsing and Auth object construction.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>Stable identifier used for logging and configuration.</p> required <code>default_ttl</code> <code>int</code> <p>Fallback TTL in seconds if configured TTL is invalid.</p> <code>300</code> <p>Attributes:</p> Name Type Description <code>provider_name</code> <p>Provider identifier.</p> <code>default_ttl</code> <p>Default TTL for cache.</p> <code>logger</code> <p>Namespaced logger instance.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def __init__(self, provider_name: str, default_ttl: int = 300) -&gt; None:\n    self.provider_name = provider_name\n    self.default_ttl = default_ttl\n    self.logger = setup_logger(f\"mlflow_secrets_auth.{provider_name}\")\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/base/#mlflow_secrets_auth.base.SecretsBackedAuthProvider.get_auth","title":"<code>get_auth()</code>","text":"<p>Return a <code>requests</code> Auth object (no URL filtering).</p> <p>This method is used by MLflow when a per-request URL is not available.</p> <p>Returns:</p> Type Description <code>AuthBase | None</code> <p>A <code>requests.auth.AuthBase</code> instance or None when disabled/unavailable.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def get_auth(self) -&gt; requests.auth.AuthBase | None:\n    \"\"\"Return a `requests` Auth object (no URL filtering).\n\n    This method is used by MLflow when a per-request URL is not available.\n\n    Returns:\n        A `requests.auth.AuthBase` instance or None when disabled/unavailable.\n\n    \"\"\"\n    if not self._is_enabled():\n        safe_log(self.logger, logging.DEBUG, f\"{self.provider_name} provider not enabled\")\n        return None\n\n    try:\n        secret_data = self._fetch_secret_cached()\n        return None if not secret_data else self._create_auth(secret_data)\n    except Exception as e:  # pragma: no cover \u2014 defensive guard\n        safe_log(self.logger, logging.ERROR, f\"Unexpected error in {self.provider_name}: {e}\")\n        return None\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/base/#mlflow_secrets_auth.base.SecretsBackedAuthProvider.get_name","title":"<code>get_name()</code>","text":"<p>Return the provider name (instance method in recent MLflow versions).</p> <p>Returns:</p> Type Description <code>str</code> <p>Provider name for MLflow plugin discovery.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"Return the provider name (instance method in recent MLflow versions).\n\n    Returns:\n        Provider name for MLflow plugin discovery.\n\n    \"\"\"\n    return self.provider_name\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/base/#mlflow_secrets_auth.base.SecretsBackedAuthProvider.get_request_auth","title":"<code>get_request_auth(url)</code>","text":"<p>Return a <code>requests</code> Auth object for a given MLflow request URL.</p> <p>Applies host allowlisting to avoid credential leakage.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Full request URL for an MLflow call.</p> required <p>Returns:</p> Type Description <code>AuthBase | None</code> <p>A <code>requests.auth.AuthBase</code> instance or None if not allowed/available.</p> Source code in <code>src/mlflow_secrets_auth/base.py</code> <pre><code>def get_request_auth(self, url: str) -&gt; requests.auth.AuthBase | None:\n    \"\"\"Return a `requests` Auth object for a given MLflow request URL.\n\n    Applies host allowlisting to avoid credential leakage.\n\n    Args:\n        url: Full request URL for an MLflow call.\n\n    Returns:\n        A `requests.auth.AuthBase` instance or None if not allowed/available.\n\n    \"\"\"\n    if not self._is_enabled():\n        safe_log(self.logger, logging.DEBUG, f\"{self.provider_name} provider not enabled\")\n        return None\n\n    allowed_hosts = get_allowed_hosts()\n    if not is_host_allowed(url, allowed_hosts):\n        hostname = urlparse(url).hostname or \"&lt;unknown&gt;\"\n        safe_log(\n            self.logger,\n            logging.INFO,\n            f\"Host {hostname} not in allowed hosts list; skipping auth\",\n        )\n        return None\n\n    try:\n        secret_data = self._fetch_secret_cached()\n        if not secret_data:\n            safe_log(self.logger, logging.WARNING, f\"Failed to fetch secret from {self.provider_name}\")\n            return None\n        return self._create_auth(secret_data)\n    except ValueError as e:\n        # Configuration or parsing error \u2014 not fatal to the request.\n        safe_log(self.logger, logging.WARNING, f\"{self.provider_name} config error: {e}\")\n        return None\n    except Exception as e:  # pragma: no cover \u2014 defensive\n        safe_log(self.logger, logging.ERROR, f\"Unexpected error in {self.provider_name}: {e}\")\n        return None\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cache/","title":"cache","text":""},{"location":"reference/mlflow_secrets_auth/cache/#mlflow_secrets_auth.cache","title":"<code>mlflow_secrets_auth.cache</code>","text":"<p>TTL cache implementation for secrets.</p> <p>Provides a lightweight, thread-safe cache with monotonic-clock\u2013based TTLs and a simple decorator (<code>cached_fetch</code>) to memoize zero-argument callables.</p> Design goals <ul> <li>Monotonic time to avoid issues when the wall clock changes.</li> <li>Thread safety via <code>RLock</code>.</li> <li>No caching of failures: exceptions from the wrapped callable return <code>None</code>   and are not stored.</li> <li>Global cache instance for convenience, with helpers to clear and inspect size.</li> </ul>"},{"location":"reference/mlflow_secrets_auth/cache/#mlflow_secrets_auth.cache.TTLCache","title":"<code>TTLCache()</code>","text":"<p>Thread-safe TTL cache (monotonic-clock based).</p> Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._cache: dict[str, tuple[Any, float]] = {}\n    self._lock = threading.RLock()\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cache/#mlflow_secrets_auth.cache.TTLCache.clear","title":"<code>clear()</code>","text":"<p>Clear all cached items.</p> Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all cached items.\"\"\"\n    with self._lock:\n        self._cache.clear()\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cache/#mlflow_secrets_auth.cache.TTLCache.delete","title":"<code>delete(key)</code>","text":"<p>Remove a key from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Cache key to remove.</p> required Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Remove a key from the cache.\n\n    Args:\n        key: Cache key to remove.\n\n    \"\"\"\n    with self._lock:\n        self._cache.pop(key, None)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cache/#mlflow_secrets_auth.cache.TTLCache.get","title":"<code>get(key)</code>","text":"<p>Get a value from the cache if present and not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Cache key.</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>The cached value if present and valid, otherwise None.</p> Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def get(self, key: str) -&gt; Any | None:\n    \"\"\"Get a value from the cache if present and not expired.\n\n    Args:\n        key: Cache key.\n\n    Returns:\n        The cached value if present and valid, otherwise None.\n\n    \"\"\"\n    with self._lock:\n        entry = self._cache.get(key)\n        if entry is None:\n            return None\n        value, expiry = entry\n        if self._now() &gt; expiry:\n            self._cache.pop(key, None)\n            return None\n        return value\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cache/#mlflow_secrets_auth.cache.TTLCache.invalidate_prefix","title":"<code>invalidate_prefix(prefix)</code>","text":"<p>Remove all keys starting with a prefix.</p> <p>Useful for provider-wide invalidation using e.g. <code>f\"{provider_name}:\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix to match.</p> required Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def invalidate_prefix(self, prefix: str) -&gt; None:\n    \"\"\"Remove all keys starting with a prefix.\n\n    Useful for provider-wide invalidation using e.g. ``f\"{provider_name}:\"``.\n\n    Args:\n        prefix: Prefix to match.\n\n    \"\"\"\n    with self._lock:\n        to_delete = [k for k in self._cache if k.startswith(prefix)]\n        for k in to_delete:\n            self._cache.pop(k, None)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cache/#mlflow_secrets_auth.cache.TTLCache.set","title":"<code>set(key, value, ttl_seconds)</code>","text":"<p>Set a value in the cache with a TTL.</p> <p>Non-positive TTLs are treated as \"no caching\" (the key is removed).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Cache key.</p> required <code>value</code> <code>Any</code> <p>Value to store.</p> required <code>ttl_seconds</code> <code>float</code> <p>Time-to-live in seconds.</p> required Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def set(self, key: str, value: Any, ttl_seconds: float) -&gt; None:\n    \"\"\"Set a value in the cache with a TTL.\n\n    Non-positive TTLs are treated as \"no caching\" (the key is removed).\n\n    Args:\n        key: Cache key.\n        value: Value to store.\n        ttl_seconds: Time-to-live in seconds.\n\n    \"\"\"\n    with self._lock:\n        if ttl_seconds &lt;= 0:\n            self._cache.pop(key, None)\n            return\n        self._cache[key] = (value, self._now() + float(ttl_seconds))\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cache/#mlflow_secrets_auth.cache.TTLCache.size","title":"<code>size()</code>","text":"<p>Return the current cache size, pruning expired entries first.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of live (non-expired) entries.</p> Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def size(self) -&gt; int:\n    \"\"\"Return the current cache size, pruning expired entries first.\n\n    Returns:\n        Number of live (non-expired) entries.\n\n    \"\"\"\n    with self._lock:\n        now = self._now()\n        to_delete = [k for k, (_, exp) in self._cache.items() if now &gt; exp]\n        for k in to_delete:\n            self._cache.pop(k, None)\n        return len(self._cache)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cache/#mlflow_secrets_auth.cache.cached_fetch","title":"<code>cached_fetch(cache_key, ttl_seconds)</code>","text":"<p>Decorator to cache a zero-argument function's result with a TTL.</p> <p>Exceptions raised by the wrapped function are swallowed and result in <code>None</code>, which is not cached. Successful non-None results are cached.</p> <p>Parameters:</p> Name Type Description Default <code>cache_key</code> <code>str</code> <p>Unique cache key for the function result.</p> required <code>ttl_seconds</code> <code>int</code> <p>Time-to-live for the cached value.</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[[], T]], Callable[[], T | None]]</code> <p>A decorator that wraps a <code>Callable[[], T]</code> and returns <code>Callable[[], Optional[T]]</code>.</p> Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def cached_fetch(cache_key: str, ttl_seconds: int) -&gt; Callable[[Callable[[], T]], Callable[[], T | None]]:\n    \"\"\"Decorator to cache a zero-argument function's result with a TTL.\n\n    Exceptions raised by the wrapped function are swallowed and result in `None`,\n    which is not cached. Successful non-None results are cached.\n\n    Args:\n        cache_key: Unique cache key for the function result.\n        ttl_seconds: Time-to-live for the cached value.\n\n    Returns:\n        A decorator that wraps a `Callable[[], T]` and returns `Callable[[], Optional[T]]`.\n\n    \"\"\"\n\n    def decorator(fetch_func: Callable[[], T]) -&gt; Callable[[], T | None]:\n        def wrapper() -&gt; T | None:\n            cached_value = _global_cache.get(cache_key)\n            if cached_value is not None:\n                # Typing note: caller-provided T is preserved by construction.\n                return cached_value  # type: ignore[return-value]\n\n            try:\n                value = fetch_func()\n            except Exception:\n                # Do not cache failures; return None to the caller.\n                return None\n\n            if value is not None:\n                _global_cache.set(cache_key, value, ttl_seconds)\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cache/#mlflow_secrets_auth.cache.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear the global cache instance.</p> Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def clear_cache() -&gt; None:\n    \"\"\"Clear the global cache instance.\"\"\"\n    _global_cache.clear()\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cache/#mlflow_secrets_auth.cache.delete_cache_key","title":"<code>delete_cache_key(key)</code>","text":"<p>Remove a single cache entry by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Cache key to remove.</p> required Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def delete_cache_key(key: str) -&gt; None:\n    \"\"\"Remove a single cache entry by key.\n\n    Args:\n        key: Cache key to remove.\n\n    \"\"\"\n    _global_cache.delete(key)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cache/#mlflow_secrets_auth.cache.get_cache_size","title":"<code>get_cache_size()</code>","text":"<p>Get the current size of the global cache (after pruning).</p> Source code in <code>src/mlflow_secrets_auth/cache.py</code> <pre><code>def get_cache_size() -&gt; int:\n    \"\"\"Get the current size of the global cache (after pruning).\"\"\"\n    return _global_cache.size()\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cli/","title":"cli","text":""},{"location":"reference/mlflow_secrets_auth/cli/#mlflow_secrets_auth.cli","title":"<code>mlflow_secrets_auth.cli</code>","text":"<p>Command-line interface (CLI) for MLflow Secrets Auth.</p> Subcommands <ul> <li>info   \u2013 Show version, enabled providers, and configuration snapshot.</li> <li>doctor \u2013 Run diagnostics against the configured provider.</li> </ul>"},{"location":"reference/mlflow_secrets_auth/cli/#mlflow_secrets_auth.cli.doctor_command","title":"<code>doctor_command(args)</code>","text":"<p>Run diagnostics against the configured provider.</p> Steps <p>1) Resolve enabled provider. 2) Validate provider configuration (auth mode, TTL, header). 3) Fetch secret and construct an auth object. 4) Optional dry-run: issue a HEAD request to the given URL's origin.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Parsed CLI args (supports <code>--dry-run</code> URL).</p> required <p>Returns:</p> Type Description <code>int</code> <p>Process exit code (0 on success, non-zero on error).</p> Source code in <code>src/mlflow_secrets_auth/cli.py</code> <pre><code>def doctor_command(args: argparse.Namespace) -&gt; int:\n    \"\"\"Run diagnostics against the configured provider.\n\n    Steps:\n      1) Resolve enabled provider.\n      2) Validate provider configuration (auth mode, TTL, header).\n      3) Fetch secret and construct an auth object.\n      4) Optional dry-run: issue a HEAD request to the given URL's origin.\n\n    Args:\n        args: Parsed CLI args (supports `--dry-run` URL).\n\n    Returns:\n        Process exit code (0 on success, non-zero on error).\n\n    \"\"\"\n    setup_logger(\"mlflow_secrets_auth.cli\")\n\n    _print_header(\"MLflow Secrets Auth \u2013 Doctor\")\n\n    provider_name, provider = get_enabled_provider()\n    if provider_name is None or provider is None:\n        return 1\n\n    # Config snapshot\n    try:\n        _ = provider._get_auth_mode()\n        _ = get_auth_header_name()\n        _ = provider._get_ttl()\n        _ = get_cache_size()\n        allowed_hosts = get_allowed_hosts()\n    except Exception:  # pragma: no cover\n        return 1\n\n    # Test secret fetch + auth construction\n    try:\n        secret_data = provider._fetch_secret_cached()\n        if not secret_data:\n            return 1\n\n        try:\n            provider._create_auth(secret_data)\n        except Exception:\n            return 1\n    except Exception:  # pragma: no cover\n        return 1\n\n    # Optional dry-run against a URL\n    if args.dry_run:\n        parsed = urlparse(args.dry_run)\n        if not parsed.scheme or not parsed.netloc:\n            return 1\n\n        if allowed_hosts and parsed.hostname not in allowed_hosts:\n            return 1\n\n        try:\n            auth = provider.get_request_auth(args.dry_run)\n            if auth is None:\n                return 1\n\n            origin = f\"{parsed.scheme}://{parsed.netloc}/\"\n            with contextlib.suppress(requests.exceptions.RequestException):\n                requests.head(origin, auth=auth, timeout=10, allow_redirects=True)\n        except Exception:  # pragma: no cover\n            return 1\n\n    return 0\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cli/#mlflow_secrets_auth.cli.get_enabled_provider","title":"<code>get_enabled_provider()</code>","text":"<p>Return the first enabled provider as (name, instance), or (None, None).</p> <p>Returns:</p> Type Description <code>ProviderTuple</code> <p>Tuple of provider name and instance, or (None, None) if none enabled.</p> Source code in <code>src/mlflow_secrets_auth/cli.py</code> <pre><code>def get_enabled_provider() -&gt; ProviderTuple:\n    \"\"\"Return the first enabled provider as (name, instance), or (None, None).\n\n    Returns:\n        Tuple of provider name and instance, or (None, None) if none enabled.\n\n    \"\"\"\n    for name, cls in PROVIDERS.items():\n        if is_provider_enabled(name):\n            try:\n                return name, cls()  # type: ignore[call-arg]  # compatible ctor\n            except Exception:  # pragma: no cover \u2014 defensive\n                return name, None\n    return None, None\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cli/#mlflow_secrets_auth.cli.info_command","title":"<code>info_command(_)</code>","text":"<p>Show plugin version and configuration snapshot.</p> <p>Returns:</p> Type Description <code>int</code> <p>Process exit code (0 on success, non-zero on error).</p> Source code in <code>src/mlflow_secrets_auth/cli.py</code> <pre><code>def info_command(_: argparse.Namespace) -&gt; int:\n    \"\"\"Show plugin version and configuration snapshot.\n\n    Returns:\n        Process exit code (0 on success, non-zero on error).\n\n    \"\"\"\n    setup_logger(\"mlflow_secrets_auth.cli\")\n\n    _print_header(\"MLflow Secrets Auth \u2013 Info\")\n\n    # Version\n    try:\n        importlib.metadata.version(\"mlflow-secrets-auth\")\n    except importlib.metadata.PackageNotFoundError:\n        # Fallback for editable installs if distribution metadata is absent\n        try:\n            pass  # type: ignore\n        except Exception:\n            pass\n\n    # Providers\n    [name for name in PROVIDERS if is_provider_enabled(name)]\n\n    # Config snapshot\n    get_allowed_hosts()\n    return 0\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/cli/#mlflow_secrets_auth.cli.main","title":"<code>main()</code>","text":"<p>Main CLI entry point.</p> <p>Returns:</p> Type Description <code>int</code> <p>Process exit code (0 on success, non-zero on error).</p> Source code in <code>src/mlflow_secrets_auth/cli.py</code> <pre><code>def main() -&gt; int:\n    \"\"\"Main CLI entry point.\n\n    Returns:\n        Process exit code (0 on success, non-zero on error).\n\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"MLflow Secrets Auth CLI\")\n    subparsers = parser.add_subparsers(dest=\"command\", help=\"Available commands\")\n\n    # doctor\n    doctor_parser = subparsers.add_parser(\"doctor\", help=\"Run diagnostics\")\n    doctor_parser.add_argument(\n        \"--dry-run\",\n        metavar=\"URL\",\n        help=\"Test auth against specified MLflow tracking URL\",\n    )\n\n    # info\n    subparsers.add_parser(\"info\", help=\"Show plugin information and configuration\")\n\n    args = parser.parse_args()\n\n    if args.command == \"doctor\":\n        return doctor_command(args)\n    if args.command == \"info\":\n        return info_command(args)\n\n    parser.print_help()\n    return 1\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/config/","title":"config","text":""},{"location":"reference/mlflow_secrets_auth/config/#mlflow_secrets_auth.config","title":"<code>mlflow_secrets_auth.config</code>","text":"<p>Configuration utilities for MLflow secrets auth providers.</p> <p>This module centralizes environment-driven configuration and safe redaction helpers.</p> Key env vars <ul> <li>MLFLOW_SECRETS_ALLOWED_HOSTS: Comma-separated host allowlist.</li> <li>MLFLOW_AUTH_HEADER_NAME: Custom header for auth (defaults to \"Authorization\").</li> <li>MLFLOW_SECRETS_LOG_LEVEL: Logging level (defaults to \"INFO\").</li> <li>MLFLOW_SECRETS_AUTH_ENABLE: Comma-separated list of enabled providers.</li> <li>MLFLOW_SECRETS_AUTH_ENABLE_: Per-provider boolean toggle (e.g., AWS_SECRETS_MANAGER)."},{"location":"reference/mlflow_secrets_auth/config/#mlflow_secrets_auth.config.get_allowed_hosts","title":"<code>get_allowed_hosts()</code>","text":"<p>Return the host allowlist from MLFLOW_SECRETS_ALLOWED_HOSTS.</p> <p>Supports both exact hostnames and wildcard patterns using shell-style globbing.</p> <p>Examples:</p> <p>MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.example.com,.corp.example.com\" MLFLOW_SECRETS_ALLOWED_HOSTS=\"api.prod.com,.staging.com,localhost\"</p> Wildcard patterns <ul> <li>\"*.corp.example.com\" matches any subdomain of corp.example.com</li> <li>\"mlflow.*.com\" matches mlflow with any middle component</li> <li>\"api-*\" matches hostnames starting with \"api-\"</li> </ul> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>A list of hostname patterns, or None if not configured.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def get_allowed_hosts() -&gt; list[str] | None:\n    \"\"\"Return the host allowlist from MLFLOW_SECRETS_ALLOWED_HOSTS.\n\n    Supports both exact hostnames and wildcard patterns using shell-style globbing.\n\n    Examples:\n        MLFLOW_SECRETS_ALLOWED_HOSTS=\"mlflow.example.com,*.corp.example.com\"\n        MLFLOW_SECRETS_ALLOWED_HOSTS=\"api.prod.com,*.staging.com,localhost\"\n\n    Wildcard patterns:\n        - \"*.corp.example.com\" matches any subdomain of corp.example.com\n        - \"mlflow.*.com\" matches mlflow with any middle component\n        - \"api-*\" matches hostnames starting with \"api-\"\n\n    Returns:\n        A list of hostname patterns, or None if not configured.\n\n    \"\"\"\n    hosts_str = get_env_var(\"MLFLOW_SECRETS_ALLOWED_HOSTS\")\n    if not hosts_str:\n        return None\n    hosts = [h.strip() for h in hosts_str.split(\",\") if h.strip()]\n    return hosts or None\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/config/#mlflow_secrets_auth.config.get_auth_header_name","title":"<code>get_auth_header_name()</code>","text":"<p>Return the configured auth header name.</p> <p>Defaults to \"Authorization\" when MLFLOW_AUTH_HEADER_NAME is unset.</p> <p>Returns:</p> Type Description <code>str</code> <p>Header name as a string.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def get_auth_header_name() -&gt; str:\n    \"\"\"Return the configured auth header name.\n\n    Defaults to \"Authorization\" when MLFLOW_AUTH_HEADER_NAME is unset.\n\n    Returns:\n        Header name as a string.\n\n    \"\"\"\n    return get_env_var(\"MLFLOW_AUTH_HEADER_NAME\", \"Authorization\") or \"Authorization\"\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/config/#mlflow_secrets_auth.config.get_env_bool","title":"<code>get_env_bool(name, default=False)</code>","text":"<p>Return an environment variable parsed as a boolean.</p> <p>Recognized truthy values (case-insensitive): {\"1\", \"true\", \"yes\", \"on\"}.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Environment variable name.</p> required <code>default</code> <code>bool</code> <p>Fallback when the variable is unset.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>Parsed boolean value.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def get_env_bool(name: str, default: bool = False) -&gt; bool:\n    \"\"\"Return an environment variable parsed as a boolean.\n\n    Recognized truthy values (case-insensitive): {\"1\", \"true\", \"yes\", \"on\"}.\n\n    Args:\n        name: Environment variable name.\n        default: Fallback when the variable is unset.\n\n    Returns:\n        Parsed boolean value.\n\n    \"\"\"\n    value = get_env_var(name)\n    if value is None:\n        return default\n    return value.strip().lower() in {\"1\", \"true\", \"yes\", \"on\"}\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/config/#mlflow_secrets_auth.config.get_env_int","title":"<code>get_env_int(name, default)</code>","text":"<p>Return an environment variable parsed as int.</p> <p>On parsing error or if unset, returns <code>default</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Environment variable name.</p> required <code>default</code> <code>int</code> <p>Fallback value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Parsed integer or <code>default</code>.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def get_env_int(name: str, default: int) -&gt; int:\n    \"\"\"Return an environment variable parsed as int.\n\n    On parsing error or if unset, returns `default`.\n\n    Args:\n        name: Environment variable name.\n        default: Fallback value.\n\n    Returns:\n        Parsed integer or `default`.\n\n    \"\"\"\n    value = get_env_var(name)\n    if value is None:\n        return default\n    try:\n        return int(value.strip())\n    except (TypeError, ValueError):\n        return default\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/config/#mlflow_secrets_auth.config.get_env_var","title":"<code>get_env_var(name, default=None)</code>","text":"<p>Return an environment variable or a default.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Environment variable name.</p> required <code>default</code> <code>str | None</code> <p>Value to return if not set.</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>The environment value as a string, or <code>default</code> when unset.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def get_env_var(name: str, default: str | None = None) -&gt; str | None:\n    \"\"\"Return an environment variable or a default.\n\n    Args:\n        name: Environment variable name.\n        default: Value to return if not set.\n\n    Returns:\n        The environment value as a string, or `default` when unset.\n\n    \"\"\"\n    return os.environ.get(name, default)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/config/#mlflow_secrets_auth.config.get_log_level","title":"<code>get_log_level()</code>","text":"<p>Return the configured log level for secrets auth.</p> <p>Defaults to \"INFO\" and uppercases the value for consistency.</p> <p>Returns:</p> Type Description <code>str</code> <p>Uppercased logging level string (e.g., \"INFO\", \"DEBUG\").</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def get_log_level() -&gt; str:\n    \"\"\"Return the configured log level for secrets auth.\n\n    Defaults to \"INFO\" and uppercases the value for consistency.\n\n    Returns:\n        Uppercased logging level string (e.g., \"INFO\", \"DEBUG\").\n\n    \"\"\"\n    return (get_env_var(\"MLFLOW_SECRETS_LOG_LEVEL\", \"INFO\") or \"INFO\").upper()\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/config/#mlflow_secrets_auth.config.is_provider_enabled","title":"<code>is_provider_enabled(provider_name)</code>","text":"<p>Return whether a specific provider is enabled.</p> Two mechanisms <p>1) Global list: MLFLOW_SECRETS_AUTH_ENABLE=\"vault,aws-secrets-manager,azure-key-vault\" 2) Per-provider boolean: MLFLOW_SECRETS_AUTH_ENABLE_=true    e.g. MLFLOW_SECRETS_AUTH_ENABLE_AWS_SECRETS_MANAGER=true <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>Provider slug (case-insensitive), e.g. \"vault\".</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if enabled via either mechanism, False otherwise.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def is_provider_enabled(provider_name: str) -&gt; bool:\n    \"\"\"Return whether a specific provider is enabled.\n\n    Two mechanisms:\n      1) Global list: MLFLOW_SECRETS_AUTH_ENABLE=\"vault,aws-secrets-manager,azure-key-vault\"\n      2) Per-provider boolean: MLFLOW_SECRETS_AUTH_ENABLE_&lt;PROVIDER&gt;=true\n         e.g. MLFLOW_SECRETS_AUTH_ENABLE_AWS_SECRETS_MANAGER=true\n\n    Args:\n        provider_name: Provider slug (case-insensitive), e.g. \"vault\".\n\n    Returns:\n        True if enabled via either mechanism, False otherwise.\n\n    \"\"\"\n    # Global list\n    global_enable = get_env_var(\"MLFLOW_SECRETS_AUTH_ENABLE\", \"\") or \"\"\n    enabled = {p.strip().lower() for p in global_enable.split(\",\") if p.strip()}\n    if provider_name.strip().lower() in enabled:\n        return True\n\n    # Provider-specific toggle\n    env_key = f\"MLFLOW_SECRETS_AUTH_ENABLE_{provider_name.upper().replace('-', '_')}\"\n    return get_env_bool(env_key, False)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/config/#mlflow_secrets_auth.config.mask_secret","title":"<code>mask_secret(value, mask_char='*', show_chars=4)</code>","text":"<p>Mask a secret value for safe logging.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mask_secret(\"abcd1234\")\n'abcd********1234'\n&gt;&gt;&gt; mask_secret(\"ab\")\n'***'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Secret value to mask.</p> required <code>mask_char</code> <code>str</code> <p>Masking character (default '*').</p> <code>'*'</code> <code>show_chars</code> <code>int</code> <p>Number of leading and trailing chars to keep (default 4).</p> <code>4</code> <p>Returns:</p> Type Description <code>str</code> <p>Masked representation with the center portion obfuscated.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def mask_secret(value: str, mask_char: str = \"*\", show_chars: int = 4) -&gt; str:\n    \"\"\"Mask a secret value for safe logging.\n\n    Examples:\n        &gt;&gt;&gt; mask_secret(\"abcd1234\")\n        'abcd********1234'\n        &gt;&gt;&gt; mask_secret(\"ab\")\n        '***'\n\n    Args:\n        value: Secret value to mask.\n        mask_char: Masking character (default '*').\n        show_chars: Number of leading and trailing chars to keep (default 4).\n\n    Returns:\n        Masked representation with the center portion obfuscated.\n\n    \"\"\"\n    if not value:\n        return mask_char * 8\n\n    # Guard against non-positive show_chars\n    show = max(0, int(show_chars))\n\n    if len(value) &lt;= show:\n        return mask_char * max(3, len(value))\n    if len(value) &lt;= show * 2:\n        # Keep a small preview while masking the middle\n        keep = min(2, len(value))\n        return f\"{value[:keep]}{mask_char * 4}{value[-keep:]}\"\n    return f\"{value[:show]}{mask_char * 8}{value[-show:]}\"\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/config/#mlflow_secrets_auth.config.redact_sensitive_data","title":"<code>redact_sensitive_data(text)</code>","text":"<p>Redact common credential patterns from text.</p> <p>Safely handles patterns with different group counts. Intended for logs and messages.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Input string possibly containing sensitive material.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Redacted string with secrets masked.</p> Source code in <code>src/mlflow_secrets_auth/config.py</code> <pre><code>def redact_sensitive_data(text: str) -&gt; str:\n    \"\"\"Redact common credential patterns from text.\n\n    Safely handles patterns with different group counts. Intended for logs and messages.\n\n    Args:\n        text: Input string possibly containing sensitive material.\n\n    Returns:\n        Redacted string with secrets masked.\n\n    \"\"\"\n    if not text:\n        return text\n\n    def _sub(m: re.Match[str]) -&gt; str:\n        groups = m.groups()\n        # One-group pattern: mask entire match\n        if len(groups) == 1:\n            return mask_secret(groups[0])\n        # Two/three-group patterns: mask the middle secret\n        if len(groups) &gt;= 2:\n            prefix = groups[0]\n            secret = groups[1]\n            suffix = groups[2] if len(groups) &gt;= 3 else \"\"\n            return f\"{prefix}{mask_secret(secret)}{suffix}\"\n        # Fallback to original text (should not happen with defined patterns)\n        return m.group(0)\n\n    result = text\n    for pattern in _REDACT_PATTERNS:\n        result = pattern.sub(_sub, result)\n    return result\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/utils/","title":"utils","text":""},{"location":"reference/mlflow_secrets_auth/utils/#mlflow_secrets_auth.utils","title":"<code>mlflow_secrets_auth.utils</code>","text":"<p>Utility functions for MLflow secrets auth providers.</p> This module centralizes <ul> <li>Logger setup with environment-driven log levels.</li> <li>Safe logging with automatic redaction of sensitive substrings.</li> <li>Secret parsing with automatic format detection (JSON vs. plain string).</li> <li>URL allowlist checks.</li> <li>Small helpers (duration formatting, TTL validation, masking).</li> <li>Retry functionality with exponential backoff and jitter.</li> </ul>"},{"location":"reference/mlflow_secrets_auth/utils/#mlflow_secrets_auth.utils.format_duration","title":"<code>format_duration(seconds)</code>","text":"<p>Format a duration in seconds into a short human-readable string.</p> <p>Examples:</p> <p>45 -&gt; \"45s\" 125 -&gt; \"2m 5s\" 3600 -&gt; \"1h\"</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>int</code> <p>Duration in seconds.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Short human-readable representation.</p> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def format_duration(seconds: int) -&gt; str:\n    \"\"\"Format a duration in seconds into a short human-readable string.\n\n    Examples:\n        45 -&gt; \"45s\"\n        125 -&gt; \"2m 5s\"\n        3600 -&gt; \"1h\"\n\n    Args:\n        seconds: Duration in seconds.\n\n    Returns:\n        Short human-readable representation.\n\n    \"\"\"\n    if seconds &lt; 60:\n        return f\"{seconds}s\"\n    if seconds &lt; 3600:\n        m, s = divmod(seconds, 60)\n        return f\"{m}m\" if s == 0 else f\"{m}m {s}s\"\n    h, rem = divmod(seconds, 3600)\n    m = rem // 60\n    return f\"{h}h\" if m == 0 else f\"{h}h {m}m\"\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/utils/#mlflow_secrets_auth.utils.is_host_allowed","title":"<code>is_host_allowed(url, allowed_hosts)</code>","text":"<p>Return whether the URL's host is in the provided allowlist.</p> <p>Supports exact hostname matches and wildcard patterns using shell-style globbing (e.g., \"*.corp.example.com\" matches \"api.corp.example.com\").</p> <p>Hostname matching is case-insensitive as per DNS standards.</p> <p>Examples:</p> <ul> <li>\"example.com\" matches exactly \"example.com\"</li> <li>\"*.corp.example.com\" matches \"api.corp.example.com\", \"web.corp.example.com\"</li> <li>\"mlflow.*.com\" matches \"mlflow.prod.com\", \"mlflow.staging.com\"</li> </ul> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Full URL to check.</p> required <code>allowed_hosts</code> <code>list[str] | None</code> <p>List of allowed hostname patterns, or None to allow all.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if allowed (or no allowlist configured), otherwise False.</p> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def is_host_allowed(url: str, allowed_hosts: list[str] | None) -&gt; bool:\n    \"\"\"Return whether the URL's host is in the provided allowlist.\n\n    Supports exact hostname matches and wildcard patterns using shell-style\n    globbing (e.g., \"*.corp.example.com\" matches \"api.corp.example.com\").\n\n    Hostname matching is case-insensitive as per DNS standards.\n\n    Examples:\n        - \"example.com\" matches exactly \"example.com\"\n        - \"*.corp.example.com\" matches \"api.corp.example.com\", \"web.corp.example.com\"\n        - \"mlflow.*.com\" matches \"mlflow.prod.com\", \"mlflow.staging.com\"\n\n    Args:\n        url: Full URL to check.\n        allowed_hosts: List of allowed hostname patterns, or None to allow all.\n\n    Returns:\n        True if allowed (or no allowlist configured), otherwise False.\n\n    \"\"\"\n    if allowed_hosts is None:\n        return True\n    try:\n        hostname = urlparse(url).hostname\n        if not hostname:\n            return False\n\n        # Normalize hostname to lowercase for case-insensitive comparison\n        hostname = hostname.lower()\n\n        # Check each pattern in the allowlist\n        for pattern in allowed_hosts:\n            # Normalize pattern to lowercase as well\n            pattern_lower = pattern.lower()\n            if fnmatch.fnmatch(hostname, pattern_lower):\n                return True\n\n        return False\n    except Exception:\n        return False\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/utils/#mlflow_secrets_auth.utils.mask_secret","title":"<code>mask_secret(secret, show_chars=4)</code>","text":"<p>Mask a secret for safe logging.</p> <p>For short inputs (&lt;= 2 * show_chars) returns a generic \"***\" to avoid revealing almost the entire secret.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <code>str</code> <p>Secret value.</p> required <code>show_chars</code> <code>int</code> <p>Number of leading and trailing characters to keep.</p> <code>4</code> <p>Returns:</p> Type Description <code>str</code> <p>Masked representation of the secret.</p> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def mask_secret(secret: str, show_chars: int = 4) -&gt; str:\n    \"\"\"Mask a secret for safe logging.\n\n    For short inputs (&lt;= 2 * show_chars) returns a generic \"***\" to avoid\n    revealing almost the entire secret.\n\n    Args:\n        secret: Secret value.\n        show_chars: Number of leading and trailing characters to keep.\n\n    Returns:\n        Masked representation of the secret.\n\n    \"\"\"\n    if not secret or len(secret) &lt;= show_chars * 2:\n        return \"***\"\n    return f\"{secret[:show_chars]}...{secret[-show_chars:]}\"\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/utils/#mlflow_secrets_auth.utils.parse_secret_json","title":"<code>parse_secret_json(secret_value)</code>","text":"<p>Parse secret material with automatic format detection.</p> Accepts either <ul> <li>JSON object with one of:<ul> <li>{\"token\": \"\"} <li>{\"username\": \"...\", \"password\": \"...\"}</li> <li>Plain string:<ul> <li>\"username:password\" \u2192 {\"username\": \"...\", \"password\": \"...\"}</li> <li>\"\" \u2192 {\"token\": \"\"} <p>Whitespace is stripped from string fields.</p> <p>Parameters:</p> Name Type Description Default <code>secret_value</code> <code>str</code> <p>Raw secret value.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A normalized dict with either {\"token\": \"...\"} or {\"username\": \"...\", \"password\": \"...\"}.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the JSON object is invalid or missing required fields.</p> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def parse_secret_json(secret_value: str) -&gt; dict[str, str]:\n    \"\"\"Parse secret material with automatic format detection.\n\n    Accepts either:\n      * JSON object with one of:\n          - {\"token\": \"&lt;opaque token&gt;\"}\n          - {\"username\": \"...\", \"password\": \"...\"}\n      * Plain string:\n          - \"username:password\" \u2192 {\"username\": \"...\", \"password\": \"...\"}\n          - \"&lt;token&gt;\" \u2192 {\"token\": \"&lt;token&gt;\"}\n\n    Whitespace is stripped from string fields.\n\n    Args:\n        secret_value: Raw secret value.\n\n    Returns:\n        A normalized dict with either {\"token\": \"...\"} or {\"username\": \"...\", \"password\": \"...\"}.\n\n    Raises:\n        ValueError: If the JSON object is invalid or missing required fields.\n\n    \"\"\"\n    # First attempt: JSON object\n    try:\n        data = json.loads(secret_value)\n    except json.JSONDecodeError:\n        # Fallback to plain string\n        value = secret_value.strip()\n        if not value:\n            msg = \"Secret is empty\"\n            raise ValueError(msg)\n\n        if \":\" in value:\n            username, password = value.split(\":\", 1)\n            username = (username or \"\").strip()\n            password = (password or \"\").strip()\n            if not username or not password:\n                msg = \"Secret 'username:password' must be non-empty\"\n                raise ValueError(msg)\n            return {\"username\": username, \"password\": password}\n        return {\"token\": value}\n\n    if not isinstance(data, dict):\n        msg = \"Secret value must be a JSON object\"\n        raise ValueError(msg)\n\n    # Token-based secret\n    if \"token\" in data:\n        token = data[\"token\"]\n        if not isinstance(token, str) or not token.strip():\n            msg = \"Secret 'token' field must be a non-empty string\"\n            raise ValueError(msg)\n        return {\"token\": token.strip()}\n\n    # Username/password secret\n    if \"username\" in data and \"password\" in data:\n        username = data[\"username\"]\n        password = data[\"password\"]\n        if not isinstance(username, str) or not username.strip():\n            msg = \"Secret 'username' field must be a non-empty string\"\n            raise ValueError(msg)\n        if not isinstance(password, str) or not password.strip():\n            msg = \"Secret 'password' field must be a non-empty string\"\n            raise ValueError(msg)\n        return {\"username\": username.strip(), \"password\": password.strip()}\n\n    msg = \"Secret must contain either 'token' field or both 'username' and 'password' fields\"\n    raise ValueError(\n        msg,\n    )\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/utils/#mlflow_secrets_auth.utils.retry_with_jitter","title":"<code>retry_with_jitter(fn, attempts=3, base_delay=0.1, backoff=2.0, max_delay=1.0, jitter=0.4, sleep=time.sleep)</code>","text":"<p>Retry a function with exponential backoff and jitter.</p> <p>Calls <code>fn</code> up to <code>attempts</code> times with exponential backoff and \u00b1jitter%, capped by <code>max_delay</code>. If all attempts fail, reraises the last exception.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[[], T]</code> <p>Function to call (should take no arguments).</p> required <code>attempts</code> <code>int</code> <p>Maximum number of attempts (must be &gt;= 1).</p> <code>3</code> <code>base_delay</code> <code>float</code> <p>Initial delay in seconds.</p> <code>0.1</code> <code>backoff</code> <code>float</code> <p>Exponential backoff multiplier.</p> <code>2.0</code> <code>max_delay</code> <code>float</code> <p>Maximum delay between attempts in seconds.</p> <code>1.0</code> <code>jitter</code> <code>float</code> <p>Jitter factor as a proportion (e.g., 0.4 = \u00b140%).</p> <code>0.4</code> <code>sleep</code> <code>Callable[[float], None]</code> <p>Sleep function (mainly for testing).</p> <code>sleep</code> <p>Returns:</p> Type Description <code>T</code> <p>Result of the successful function call.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>The last exception encountered if all attempts fail.</p> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def retry_with_jitter(\n    fn: Callable[[], T],\n    attempts: int = 3,\n    base_delay: float = 0.1,\n    backoff: float = 2.0,\n    max_delay: float = 1.0,\n    jitter: float = 0.4,\n    sleep: Callable[[float], None] = time.sleep,\n) -&gt; T:\n    \"\"\"Retry a function with exponential backoff and jitter.\n\n    Calls `fn` up to `attempts` times with exponential backoff and \u00b1jitter%,\n    capped by `max_delay`. If all attempts fail, reraises the last exception.\n\n    Args:\n        fn: Function to call (should take no arguments).\n        attempts: Maximum number of attempts (must be &gt;= 1).\n        base_delay: Initial delay in seconds.\n        backoff: Exponential backoff multiplier.\n        max_delay: Maximum delay between attempts in seconds.\n        jitter: Jitter factor as a proportion (e.g., 0.4 = \u00b140%).\n        sleep: Sleep function (mainly for testing).\n\n    Returns:\n        Result of the successful function call.\n\n    Raises:\n        Exception: The last exception encountered if all attempts fail.\n\n    \"\"\"\n    last_exception = None\n\n    for attempt in range(attempts):\n        try:\n            return fn()\n        except Exception as e:\n            last_exception = e\n\n            # Don't sleep after the last attempt\n            if attempt == attempts - 1:\n                break\n\n            # Calculate delay with exponential backoff\n            delay = min(base_delay * (backoff ** attempt), max_delay)\n\n            # Add jitter: \u00b1jitter% of the delay\n            jitter_amount = delay * jitter * (2 * random.random() - 1)\n            final_delay = max(0, delay + jitter_amount)\n\n            sleep(final_delay)\n\n    # Re-raise the last exception if all attempts failed\n    if last_exception is not None:\n        raise last_exception\n\n    # This should never happen, but just in case\n    msg = \"No attempts were made\"\n    raise RuntimeError(msg)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/utils/#mlflow_secrets_auth.utils.safe_log","title":"<code>safe_log(logger, level, message, *args)</code>","text":"<p>Log a message with automatic redaction of sensitive data.</p> <p>The message is first formatted with <code>args</code> (printf-style) and only then passed through the redactor to avoid leaking secrets via formatting.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>Target logger.</p> required <code>level</code> <code>int</code> <p>Logging level (e.g., <code>logging.INFO</code>).</p> required <code>message</code> <code>str</code> <p>Format string.</p> required <code>*args</code> <code>Any</code> <p>Arguments for printf-style substitution.</p> <code>()</code> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def safe_log(logger: logging.Logger, level: int, message: str, *args: Any) -&gt; None:\n    \"\"\"Log a message with automatic redaction of sensitive data.\n\n    The message is first formatted with `args` (printf-style) and only then\n    passed through the redactor to avoid leaking secrets via formatting.\n\n    Args:\n        logger: Target logger.\n        level: Logging level (e.g., `logging.INFO`).\n        message: Format string.\n        *args: Arguments for printf-style substitution.\n\n    \"\"\"\n    if args:\n        try:\n            message = message % args\n        except Exception:\n            # Fall back to a simple join if interpolation fails for any reason\n            message = \" \".join([message, *map(str, args)])\n    redacted_message = redact_sensitive_data(message)\n    logger.log(level, redacted_message)\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/utils/#mlflow_secrets_auth.utils.setup_logger","title":"<code>setup_logger(name)</code>","text":"<p>Create or configure a namespaced logger.</p> <p>The logger level is always driven by the <code>MLFLOW_SECRETS_LOG_LEVEL</code> env var. A single stream handler is attached once; propagation is disabled to avoid duplicated messages under test runners or frameworks.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Logger name (typically package.module).</p> required <p>Returns:</p> Type Description <code>Logger</code> <p>A configured <code>logging.Logger</code> instance.</p> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def setup_logger(name: str) -&gt; logging.Logger:\n    \"\"\"Create or configure a namespaced logger.\n\n    The logger level is always driven by the `MLFLOW_SECRETS_LOG_LEVEL` env var.\n    A single stream handler is attached once; propagation is disabled to avoid\n    duplicated messages under test runners or frameworks.\n\n    Args:\n        name: Logger name (typically package.module).\n\n    Returns:\n        A configured `logging.Logger` instance.\n\n    \"\"\"\n    logger = logging.getLogger(name)\n\n    # Always set the level from config\n    level_name = get_log_level()\n    level = getattr(logging, level_name, logging.INFO)\n    logger.setLevel(level)\n\n    # Only add a handler if none exist (avoid duplicate logs under pytest)\n    if not logger.handlers:\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter(\n            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        )\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n\n    # Avoid double logging through parent loggers\n    logger.propagate = False\n    return logger\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/utils/#mlflow_secrets_auth.utils.validate_ttl","title":"<code>validate_ttl(ttl_seconds, *, default=300, min_ttl=1, max_ttl=3600)</code>","text":"<p>Validate and clamp a TTL value.</p> Rules <ul> <li>If <code>ttl_seconds</code> is None or &lt;= 0, use <code>default</code>.</li> <li>Clamp the final value between <code>min_ttl</code> and <code>max_ttl</code> (inclusive).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>ttl_seconds</code> <code>int | None</code> <p>Requested TTL in seconds.</p> required <code>default</code> <code>int</code> <p>Fallback TTL when input is invalid or not provided.</p> <code>300</code> <code>min_ttl</code> <code>int</code> <p>Minimum allowed TTL (inclusive).</p> <code>1</code> <code>max_ttl</code> <code>int</code> <p>Maximum allowed TTL (inclusive).</p> <code>3600</code> <p>Returns:</p> Type Description <code>int</code> <p>A valid TTL in seconds.</p> Source code in <code>src/mlflow_secrets_auth/utils.py</code> <pre><code>def validate_ttl(\n    ttl_seconds: int | None,\n    *,\n    default: int = 300,\n    min_ttl: int = 1,\n    max_ttl: int = 3600,\n) -&gt; int:\n    \"\"\"Validate and clamp a TTL value.\n\n    Rules:\n      * If `ttl_seconds` is None or &lt;= 0, use `default`.\n      * Clamp the final value between `min_ttl` and `max_ttl` (inclusive).\n\n    Args:\n        ttl_seconds: Requested TTL in seconds.\n        default: Fallback TTL when input is invalid or not provided.\n        min_ttl: Minimum allowed TTL (inclusive).\n        max_ttl: Maximum allowed TTL (inclusive).\n\n    Returns:\n        A valid TTL in seconds.\n\n    \"\"\"\n    try:\n        ttl = int(ttl_seconds) if ttl_seconds is not None else int(default)\n    except (TypeError, ValueError):\n        ttl = int(default)\n\n    if ttl &lt;= 0:\n        ttl = int(default)\n\n    if ttl &lt; min_ttl:\n        ttl = min_ttl\n    elif ttl &gt; max_ttl:\n        ttl = max_ttl\n\n    return ttl\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/providers/__init__/","title":"providers","text":""},{"location":"reference/mlflow_secrets_auth/providers/__init__/#mlflow_secrets_auth.providers","title":"<code>mlflow_secrets_auth.providers</code>","text":"<p>Empty file to make providers a package.</p>"},{"location":"reference/mlflow_secrets_auth/providers/__init__/#mlflow_secrets_auth.providers.aws_secrets_manager","title":"<code>aws_secrets_manager</code>","text":"<p>AWS Secrets Manager authentication provider.</p>"},{"location":"reference/mlflow_secrets_auth/providers/__init__/#mlflow_secrets_auth.providers.aws_secrets_manager.AWSSecretsManagerAuthProvider","title":"<code>AWSSecretsManagerAuthProvider()</code>","text":"<p>               Bases: <code>SecretsBackedAuthProvider</code></p> <p>Authentication provider using AWS Secrets Manager.</p> <p>Requires the optional dependency <code>boto3</code>.</p> Environment variables <p>AWS_REGION: AWS region (e.g., \"eu-west-1\"). Required. MLFLOW_AWS_SECRET_ID: Secret identifier or ARN. Required. MLFLOW_AWS_AUTH_MODE: \"bearer\" (default) or \"basic\". MLFLOW_AWS_TTL_SEC: Cache TTL in seconds (defaults to provider's default TTL).</p> <p>Initialize the provider with a default TTL and lazy AWS client.</p> Source code in <code>src/mlflow_secrets_auth/providers/aws_secrets_manager.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the provider with a default TTL and lazy AWS client.\"\"\"\n    super().__init__(\"aws-secrets-manager\", default_ttl=300)\n    self._secrets_client: Any | None = None  # boto3 client when available\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/providers/__init__/#mlflow_secrets_auth.providers.azure_key_vault","title":"<code>azure_key_vault</code>","text":"<p>Azure Key Vault authentication provider.</p>"},{"location":"reference/mlflow_secrets_auth/providers/__init__/#mlflow_secrets_auth.providers.azure_key_vault.AzureKeyVaultAuthProvider","title":"<code>AzureKeyVaultAuthProvider()</code>","text":"<p>               Bases: <code>SecretsBackedAuthProvider</code></p> <p>Authentication provider using Azure Key Vault.</p> <p>Requires optional dependencies: <code>azure-identity</code> and <code>azure-keyvault-secrets</code>.</p> Environment variables <p>AZURE_KEY_VAULT_URL: Full Key Vault URL (e.g., \"https://myvault.vault.azure.net\"). Required. MLFLOW_AZURE_SECRET_NAME: Secret name to retrieve. Required. MLFLOW_AZURE_AUTH_MODE: \"bearer\" (default) or \"basic\". MLFLOW_AZURE_TTL_SEC: Cache TTL in seconds (defaults to provider's default TTL).</p> <p>Initialize the provider with a default TTL and a lazy SecretClient.</p> Source code in <code>src/mlflow_secrets_auth/providers/azure_key_vault.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the provider with a default TTL and a lazy SecretClient.\"\"\"\n    super().__init__(\"azure-key-vault\", default_ttl=300)\n    self._secret_client: Any | None = None  # azure.keyvault.secrets.SecretClient when available\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/providers/__init__/#mlflow_secrets_auth.providers.vault","title":"<code>vault</code>","text":"<p>HashiCorp Vault authentication provider.</p>"},{"location":"reference/mlflow_secrets_auth/providers/__init__/#mlflow_secrets_auth.providers.vault.VaultAuthProvider","title":"<code>VaultAuthProvider()</code>","text":"<p>               Bases: <code>SecretsBackedAuthProvider</code></p> <p>Authentication provider using HashiCorp Vault.</p> <p>Supports token and AppRole authentication via the <code>hvac</code> client (optional dependency). Secrets are retrieved from KV v2 when possible with a graceful fallback to KV v1.</p> Environment variables <p>VAULT_ADDR: Vault server address, e.g. \"https://vault.example.com\" VAULT_TOKEN: Vault token for direct authentication (optional). VAULT_ROLE_ID: AppRole role ID (used if VAULT_TOKEN is not provided). VAULT_SECRET_ID: AppRole secret ID (used if VAULT_TOKEN is not provided). MLFLOW_VAULT_SECRET_PATH: Secret path (e.g. \"secret/mlflow/auth\" or \"secret/data/mlflow/auth\"). MLFLOW_VAULT_AUTH_MODE: \"bearer\" (default) or \"basic\". MLFLOW_VAULT_TTL_SEC: Cache TTL in seconds (defaults to provider's default TTL).</p> Notes <ul> <li>When using KV v2, this implementation auto-detects common path formats and   reads via <code>client.secrets.kv.v2.read_secret_version</code>.</li> <li>For KV v1, it falls back to <code>client.secrets.kv.v1.read_secret</code>.</li> <li>Secret dictionaries are JSON-encoded for centralized parsing in the base class.</li> </ul> <p>Initialize the provider with a default TTL and a lazy hvac client.</p> Source code in <code>src/mlflow_secrets_auth/providers/vault.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the provider with a default TTL and a lazy hvac client.\"\"\"\n    super().__init__(\"vault\", default_ttl=300)\n    self._vault_client: Any | None = None  # hvac.Client if available\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/providers/aws_secrets_manager/","title":"aws_secrets_manager","text":""},{"location":"reference/mlflow_secrets_auth/providers/aws_secrets_manager/#mlflow_secrets_auth.providers.aws_secrets_manager","title":"<code>mlflow_secrets_auth.providers.aws_secrets_manager</code>","text":"<p>AWS Secrets Manager authentication provider.</p>"},{"location":"reference/mlflow_secrets_auth/providers/aws_secrets_manager/#mlflow_secrets_auth.providers.aws_secrets_manager.AWSSecretsManagerAuthProvider","title":"<code>AWSSecretsManagerAuthProvider()</code>","text":"<p>               Bases: <code>SecretsBackedAuthProvider</code></p> <p>Authentication provider using AWS Secrets Manager.</p> <p>Requires the optional dependency <code>boto3</code>.</p> Environment variables <p>AWS_REGION: AWS region (e.g., \"eu-west-1\"). Required. MLFLOW_AWS_SECRET_ID: Secret identifier or ARN. Required. MLFLOW_AWS_AUTH_MODE: \"bearer\" (default) or \"basic\". MLFLOW_AWS_TTL_SEC: Cache TTL in seconds (defaults to provider's default TTL).</p> <p>Initialize the provider with a default TTL and lazy AWS client.</p> Source code in <code>src/mlflow_secrets_auth/providers/aws_secrets_manager.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the provider with a default TTL and lazy AWS client.\"\"\"\n    super().__init__(\"aws-secrets-manager\", default_ttl=300)\n    self._secrets_client: Any | None = None  # boto3 client when available\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/providers/azure_key_vault/","title":"azure_key_vault","text":""},{"location":"reference/mlflow_secrets_auth/providers/azure_key_vault/#mlflow_secrets_auth.providers.azure_key_vault","title":"<code>mlflow_secrets_auth.providers.azure_key_vault</code>","text":"<p>Azure Key Vault authentication provider.</p>"},{"location":"reference/mlflow_secrets_auth/providers/azure_key_vault/#mlflow_secrets_auth.providers.azure_key_vault.AzureKeyVaultAuthProvider","title":"<code>AzureKeyVaultAuthProvider()</code>","text":"<p>               Bases: <code>SecretsBackedAuthProvider</code></p> <p>Authentication provider using Azure Key Vault.</p> <p>Requires optional dependencies: <code>azure-identity</code> and <code>azure-keyvault-secrets</code>.</p> Environment variables <p>AZURE_KEY_VAULT_URL: Full Key Vault URL (e.g., \"https://myvault.vault.azure.net\"). Required. MLFLOW_AZURE_SECRET_NAME: Secret name to retrieve. Required. MLFLOW_AZURE_AUTH_MODE: \"bearer\" (default) or \"basic\". MLFLOW_AZURE_TTL_SEC: Cache TTL in seconds (defaults to provider's default TTL).</p> <p>Initialize the provider with a default TTL and a lazy SecretClient.</p> Source code in <code>src/mlflow_secrets_auth/providers/azure_key_vault.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the provider with a default TTL and a lazy SecretClient.\"\"\"\n    super().__init__(\"azure-key-vault\", default_ttl=300)\n    self._secret_client: Any | None = None  # azure.keyvault.secrets.SecretClient when available\n</code></pre>"},{"location":"reference/mlflow_secrets_auth/providers/vault/","title":"vault","text":""},{"location":"reference/mlflow_secrets_auth/providers/vault/#mlflow_secrets_auth.providers.vault","title":"<code>mlflow_secrets_auth.providers.vault</code>","text":"<p>HashiCorp Vault authentication provider.</p>"},{"location":"reference/mlflow_secrets_auth/providers/vault/#mlflow_secrets_auth.providers.vault.VaultAuthProvider","title":"<code>VaultAuthProvider()</code>","text":"<p>               Bases: <code>SecretsBackedAuthProvider</code></p> <p>Authentication provider using HashiCorp Vault.</p> <p>Supports token and AppRole authentication via the <code>hvac</code> client (optional dependency). Secrets are retrieved from KV v2 when possible with a graceful fallback to KV v1.</p> Environment variables <p>VAULT_ADDR: Vault server address, e.g. \"https://vault.example.com\" VAULT_TOKEN: Vault token for direct authentication (optional). VAULT_ROLE_ID: AppRole role ID (used if VAULT_TOKEN is not provided). VAULT_SECRET_ID: AppRole secret ID (used if VAULT_TOKEN is not provided). MLFLOW_VAULT_SECRET_PATH: Secret path (e.g. \"secret/mlflow/auth\" or \"secret/data/mlflow/auth\"). MLFLOW_VAULT_AUTH_MODE: \"bearer\" (default) or \"basic\". MLFLOW_VAULT_TTL_SEC: Cache TTL in seconds (defaults to provider's default TTL).</p> Notes <ul> <li>When using KV v2, this implementation auto-detects common path formats and   reads via <code>client.secrets.kv.v2.read_secret_version</code>.</li> <li>For KV v1, it falls back to <code>client.secrets.kv.v1.read_secret</code>.</li> <li>Secret dictionaries are JSON-encoded for centralized parsing in the base class.</li> </ul> <p>Initialize the provider with a default TTL and a lazy hvac client.</p> Source code in <code>src/mlflow_secrets_auth/providers/vault.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the provider with a default TTL and a lazy hvac client.\"\"\"\n    super().__init__(\"vault\", default_ttl=300)\n    self._vault_client: Any | None = None  # hvac.Client if available\n</code></pre>"}]}